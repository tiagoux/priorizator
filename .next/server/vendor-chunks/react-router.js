"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router/dist/development/dom-export.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-router/dist/development/dom-export.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * react-router v7.6.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// dom-export.ts\nvar dom_export_exports = {};\n__export(dom_export_exports, {\n    HydratedRouter: ()=>HydratedRouter,\n    RouterProvider: ()=>RouterProvider\n});\nmodule.exports = __toCommonJS(dom_export_exports);\n// lib/dom-export/dom-router-provider.tsx\nvar React = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar ReactDOM = __toESM(__webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\"));\nvar import_react_router = __webpack_require__(/*! react-router */ \"(ssr)/./node_modules/react-router/dist/development/index.js\");\nfunction RouterProvider(props) {\n    return /* @__PURE__ */ React.createElement(import_react_router.RouterProvider, {\n        flushSync: ReactDOM.flushSync,\n        ...props\n    });\n}\n// lib/dom-export/hydrated-router.tsx\nvar React2 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar import_react_router2 = __webpack_require__(/*! react-router */ \"(ssr)/./node_modules/react-router/dist/development/index.js\");\nvar ssrInfo = null;\nvar router = null;\nfunction initSsrInfo() {\n    if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {\n        if (window.__reactRouterManifest.sri === true) {\n            const importMap = document.querySelector(\"script[rr-importmap]\");\n            if (importMap?.textContent) {\n                try {\n                    window.__reactRouterManifest.sri = JSON.parse(importMap.textContent).integrity;\n                } catch (err) {\n                    console.error(\"Failed to parse import map\", err);\n                }\n            }\n        }\n        ssrInfo = {\n            context: window.__reactRouterContext,\n            manifest: window.__reactRouterManifest,\n            routeModules: window.__reactRouterRouteModules,\n            stateDecodingPromise: void 0,\n            router: void 0,\n            routerInitialized: false\n        };\n    }\n}\nfunction createHydratedRouter({ unstable_getContext }) {\n    initSsrInfo();\n    if (!ssrInfo) {\n        throw new Error(\"You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`\");\n    }\n    let localSsrInfo = ssrInfo;\n    if (!ssrInfo.stateDecodingPromise) {\n        let stream = ssrInfo.context.stream;\n        (0, import_react_router2.UNSAFE_invariant)(stream, \"No stream found for single fetch decoding\");\n        ssrInfo.context.stream = void 0;\n        ssrInfo.stateDecodingPromise = (0, import_react_router2.UNSAFE_decodeViaTurboStream)(stream, window).then((value)=>{\n            ssrInfo.context.state = value.value;\n            localSsrInfo.stateDecodingPromise.value = true;\n        }).catch((e)=>{\n            localSsrInfo.stateDecodingPromise.error = e;\n        });\n    }\n    if (ssrInfo.stateDecodingPromise.error) {\n        throw ssrInfo.stateDecodingPromise.error;\n    }\n    if (!ssrInfo.stateDecodingPromise.value) {\n        throw ssrInfo.stateDecodingPromise;\n    }\n    let routes = (0, import_react_router2.UNSAFE_createClientRoutes)(ssrInfo.manifest.routes, ssrInfo.routeModules, ssrInfo.context.state, ssrInfo.context.ssr, ssrInfo.context.isSpaMode);\n    let hydrationData = void 0;\n    if (ssrInfo.context.isSpaMode) {\n        let { loaderData } = ssrInfo.context.state;\n        if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && \"root\" in loaderData) {\n            hydrationData = {\n                loaderData: {\n                    root: loaderData.root\n                }\n            };\n        }\n    } else {\n        hydrationData = (0, import_react_router2.UNSAFE_getHydrationData)(ssrInfo.context.state, routes, (routeId)=>({\n                clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,\n                hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,\n                hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null\n            }), window.location, window.__reactRouterContext?.basename, ssrInfo.context.isSpaMode);\n        if (hydrationData && hydrationData.errors) {\n            hydrationData.errors = (0, import_react_router2.UNSAFE_deserializeErrors)(hydrationData.errors);\n        }\n    }\n    let router2 = (0, import_react_router2.UNSAFE_createRouter)({\n        routes,\n        history: (0, import_react_router2.UNSAFE_createBrowserHistory)(),\n        basename: ssrInfo.context.basename,\n        unstable_getContext,\n        hydrationData,\n        hydrationRouteProperties: import_react_router2.UNSAFE_hydrationRouteProperties,\n        mapRouteProperties: import_react_router2.UNSAFE_mapRouteProperties,\n        future: {\n            unstable_middleware: ssrInfo.context.future.unstable_middleware\n        },\n        dataStrategy: (0, import_react_router2.UNSAFE_getTurboStreamSingleFetchDataStrategy)(()=>router2, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.basename),\n        patchRoutesOnNavigation: (0, import_react_router2.UNSAFE_getPatchRoutesOnNavigationFunction)(ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode, ssrInfo.context.basename)\n    });\n    ssrInfo.router = router2;\n    if (router2.state.initialized) {\n        ssrInfo.routerInitialized = true;\n        router2.initialize();\n    }\n    router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */ import_react_router2.UNSAFE_createClientRoutesWithHMRRevalidationOptOut;\n    window.__reactRouterDataRouter = router2;\n    return router2;\n}\nfunction HydratedRouter(props) {\n    if (!router) {\n        router = createHydratedRouter({\n            unstable_getContext: props.unstable_getContext\n        });\n    }\n    let [criticalCss, setCriticalCss] = React2.useState( true ? ssrInfo?.context.criticalCss : 0);\n    if (true) {\n        if (ssrInfo) {\n            window.__reactRouterClearCriticalCss = ()=>setCriticalCss(void 0);\n        }\n    }\n    let [location, setLocation] = React2.useState(router.state.location);\n    React2.useLayoutEffect(()=>{\n        if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\n            ssrInfo.routerInitialized = true;\n            ssrInfo.router.initialize();\n        }\n    }, []);\n    React2.useLayoutEffect(()=>{\n        if (ssrInfo && ssrInfo.router) {\n            return ssrInfo.router.subscribe((newState)=>{\n                if (newState.location !== location) {\n                    setLocation(newState.location);\n                }\n            });\n        }\n    }, [\n        location\n    ]);\n    (0, import_react_router2.UNSAFE_invariant)(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\n    (0, import_react_router2.UNSAFE_useFogOFWarDiscovery)(router, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode);\n    return(// This fragment is important to ensure we match the <ServerRouter> JSX\n    // structure so that useId values hydrate correctly\n    /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(import_react_router2.UNSAFE_FrameworkContext.Provider, {\n        value: {\n            manifest: ssrInfo.manifest,\n            routeModules: ssrInfo.routeModules,\n            future: ssrInfo.context.future,\n            criticalCss,\n            ssr: ssrInfo.context.ssr,\n            isSpaMode: ssrInfo.context.isSpaMode,\n            routeDiscovery: ssrInfo.context.routeDiscovery\n        }\n    }, /* @__PURE__ */ React2.createElement(import_react_router2.UNSAFE_RemixErrorBoundary, {\n        location\n    }, /* @__PURE__ */ React2.createElement(RouterProvider, {\n        router\n    }))), /* @__PURE__ */ React2.createElement(React2.Fragment, null)));\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvZG9tLWV4cG9ydC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0NBU0MsR0FDWTtBQUNiLElBQUlBLFdBQVdDLE9BQU9DLE1BQU07QUFDNUIsSUFBSUMsWUFBWUYsT0FBT0csY0FBYztBQUNyQyxJQUFJQyxtQkFBbUJKLE9BQU9LLHdCQUF3QjtBQUN0RCxJQUFJQyxvQkFBb0JOLE9BQU9PLG1CQUFtQjtBQUNsRCxJQUFJQyxlQUFlUixPQUFPUyxjQUFjO0FBQ3hDLElBQUlDLGVBQWVWLE9BQU9XLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxXQUFXLENBQUNDLFFBQVFDO0lBQ3RCLElBQUssSUFBSUMsUUFBUUQsSUFDZmIsVUFBVVksUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPbEIsa0JBQWtCZSxNQUNoQyxJQUFJLENBQUNYLGFBQWFlLElBQUksQ0FBQ0wsSUFBSUksUUFBUUEsUUFBUUYsUUFDekNwQixVQUFVa0IsSUFBSUksS0FBSztZQUFFUCxLQUFLLElBQU1JLElBQUksQ0FBQ0csSUFBSTtZQUFFTixZQUFZLENBQUVLLENBQUFBLE9BQU9uQixpQkFBaUJpQixNQUFNRyxJQUFHLEtBQU1ELEtBQUtMLFVBQVU7UUFBQztJQUN0SDtJQUNBLE9BQU9FO0FBQ1Q7QUFDQSxJQUFJTSxVQUFVLENBQUNDLEtBQUtDLFlBQVlkLFNBQVlBLENBQUFBLFNBQVNhLE9BQU8sT0FBTzVCLFNBQVNTLGFBQWFtQixRQUFRLENBQUMsR0FBR1IsWUFDbkcsc0VBQXNFO0lBQ3RFLGlFQUFpRTtJQUNqRSxzRUFBc0U7SUFD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bkQsSUFBR0QscUJBQXFCaUYsMkJBQTJCLEVBQ2xEL0UsUUFDQUQsUUFBUW1CLFFBQVEsRUFDaEJuQixRQUFRb0IsWUFBWSxFQUNwQnBCLFFBQVFrQixPQUFPLENBQUNrQixHQUFHLEVBQ25CcEMsUUFBUWtCLE9BQU8sQ0FBQytDLGNBQWMsRUFDOUJqRSxRQUFRa0IsT0FBTyxDQUFDbUIsU0FBUztJQUUzQixPQUNFLHVFQUF1RTtJQUN2RSxtREFBbUQ7SUFDbkQsYUFBYSxHQUFHdkMsT0FBT0YsYUFBYSxDQUFDRSxPQUFPbUYsUUFBUSxFQUFFLE1BQU0sYUFBYSxHQUFHbkYsT0FBT0YsYUFBYSxDQUM5RkcscUJBQXFCbUYsdUJBQXVCLENBQUNDLFFBQVEsRUFDckQ7UUFDRW5HLE9BQU87WUFDTG1DLFVBQVVuQixRQUFRbUIsUUFBUTtZQUMxQkMsY0FBY3BCLFFBQVFvQixZQUFZO1lBQ2xDdUMsUUFBUTNELFFBQVFrQixPQUFPLENBQUN5QyxNQUFNO1lBQzlCWTtZQUNBbkMsS0FBS3BDLFFBQVFrQixPQUFPLENBQUNrQixHQUFHO1lBQ3hCQyxXQUFXckMsUUFBUWtCLE9BQU8sQ0FBQ21CLFNBQVM7WUFDcEM0QixnQkFBZ0JqRSxRQUFRa0IsT0FBTyxDQUFDK0MsY0FBYztRQUNoRDtJQUNGLEdBQ0EsYUFBYSxHQUFHbkUsT0FBT0YsYUFBYSxDQUFDRyxxQkFBcUJxRix5QkFBeUIsRUFBRTtRQUFFckM7SUFBUyxHQUFHLGFBQWEsR0FBR2pELE9BQU9GLGFBQWEsQ0FBQ1IsZ0JBQWdCO1FBQUVhO0lBQU8sTUFDaEssYUFBYSxHQUFHSCxPQUFPRixhQUFhLENBQUNFLE9BQU9tRixRQUFRLEVBQUU7QUFFN0Q7QUFDQSw2REFBNkQ7QUFDN0QsS0FBTTVGLENBQUFBLENBR04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2JyLXByaW9yaXphY2FvLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2RldmVsb3BtZW50L2RvbS1leHBvcnQuanM/NzQzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHJlYWN0LXJvdXRlciB2Ny42LjFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xuXG4vLyBkb20tZXhwb3J0LnRzXG52YXIgZG9tX2V4cG9ydF9leHBvcnRzID0ge307XG5fX2V4cG9ydChkb21fZXhwb3J0X2V4cG9ydHMsIHtcbiAgSHlkcmF0ZWRSb3V0ZXI6ICgpID0+IEh5ZHJhdGVkUm91dGVyLFxuICBSb3V0ZXJQcm92aWRlcjogKCkgPT4gUm91dGVyUHJvdmlkZXJcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoZG9tX2V4cG9ydF9leHBvcnRzKTtcblxuLy8gbGliL2RvbS1leHBvcnQvZG9tLXJvdXRlci1wcm92aWRlci50c3hcbnZhciBSZWFjdCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBSZWFjdERPTSA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG52YXIgaW1wb3J0X3JlYWN0X3JvdXRlciA9IHJlcXVpcmUoXCJyZWFjdC1yb3V0ZXJcIik7XG5mdW5jdGlvbiBSb3V0ZXJQcm92aWRlcihwcm9wcykge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoaW1wb3J0X3JlYWN0X3JvdXRlci5Sb3V0ZXJQcm92aWRlciwgeyBmbHVzaFN5bmM6IFJlYWN0RE9NLmZsdXNoU3luYywgLi4ucHJvcHMgfSk7XG59XG5cbi8vIGxpYi9kb20tZXhwb3J0L2h5ZHJhdGVkLXJvdXRlci50c3hcbnZhciBSZWFjdDIgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgaW1wb3J0X3JlYWN0X3JvdXRlcjIgPSByZXF1aXJlKFwicmVhY3Qtcm91dGVyXCIpO1xudmFyIHNzckluZm8gPSBudWxsO1xudmFyIHJvdXRlciA9IG51bGw7XG5mdW5jdGlvbiBpbml0U3NySW5mbygpIHtcbiAgaWYgKCFzc3JJbmZvICYmIHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dCAmJiB3aW5kb3cuX19yZWFjdFJvdXRlck1hbmlmZXN0ICYmIHdpbmRvdy5fX3JlYWN0Um91dGVyUm91dGVNb2R1bGVzKSB7XG4gICAgaWYgKHdpbmRvdy5fX3JlYWN0Um91dGVyTWFuaWZlc3Quc3JpID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBpbXBvcnRNYXAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwic2NyaXB0W3JyLWltcG9ydG1hcF1cIik7XG4gICAgICBpZiAoaW1wb3J0TWFwPy50ZXh0Q29udGVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdpbmRvdy5fX3JlYWN0Um91dGVyTWFuaWZlc3Quc3JpID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgIGltcG9ydE1hcC50ZXh0Q29udGVudFxuICAgICAgICAgICkuaW50ZWdyaXR5O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIGltcG9ydCBtYXBcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzc3JJbmZvID0ge1xuICAgICAgY29udGV4dDogd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LFxuICAgICAgbWFuaWZlc3Q6IHdpbmRvdy5fX3JlYWN0Um91dGVyTWFuaWZlc3QsXG4gICAgICByb3V0ZU1vZHVsZXM6IHdpbmRvdy5fX3JlYWN0Um91dGVyUm91dGVNb2R1bGVzLFxuICAgICAgc3RhdGVEZWNvZGluZ1Byb21pc2U6IHZvaWQgMCxcbiAgICAgIHJvdXRlcjogdm9pZCAwLFxuICAgICAgcm91dGVySW5pdGlhbGl6ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0ZWRSb3V0ZXIoe1xuICB1bnN0YWJsZV9nZXRDb250ZXh0XG59KSB7XG4gIGluaXRTc3JJbmZvKCk7XG4gIGlmICghc3NySW5mbykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IG11c3QgYmUgdXNpbmcgdGhlIFNTUiBmZWF0dXJlcyBvZiBSZWFjdCBSb3V0ZXIgaW4gb3JkZXIgdG8gc2tpcCBwYXNzaW5nIGEgYHJvdXRlcmAgcHJvcCB0byBgPFJvdXRlclByb3ZpZGVyPmBcIlxuICAgICk7XG4gIH1cbiAgbGV0IGxvY2FsU3NySW5mbyA9IHNzckluZm87XG4gIGlmICghc3NySW5mby5zdGF0ZURlY29kaW5nUHJvbWlzZSkge1xuICAgIGxldCBzdHJlYW0gPSBzc3JJbmZvLmNvbnRleHQuc3RyZWFtO1xuICAgICgwLCBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfaW52YXJpYW50KShzdHJlYW0sIFwiTm8gc3RyZWFtIGZvdW5kIGZvciBzaW5nbGUgZmV0Y2ggZGVjb2RpbmdcIik7XG4gICAgc3NySW5mby5jb250ZXh0LnN0cmVhbSA9IHZvaWQgMDtcbiAgICBzc3JJbmZvLnN0YXRlRGVjb2RpbmdQcm9taXNlID0gKDAsIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9kZWNvZGVWaWFUdXJib1N0cmVhbSkoc3RyZWFtLCB3aW5kb3cpLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICBzc3JJbmZvLmNvbnRleHQuc3RhdGUgPSB2YWx1ZS52YWx1ZTtcbiAgICAgIGxvY2FsU3NySW5mby5zdGF0ZURlY29kaW5nUHJvbWlzZS52YWx1ZSA9IHRydWU7XG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIGxvY2FsU3NySW5mby5zdGF0ZURlY29kaW5nUHJvbWlzZS5lcnJvciA9IGU7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHNzckluZm8uc3RhdGVEZWNvZGluZ1Byb21pc2UuZXJyb3IpIHtcbiAgICB0aHJvdyBzc3JJbmZvLnN0YXRlRGVjb2RpbmdQcm9taXNlLmVycm9yO1xuICB9XG4gIGlmICghc3NySW5mby5zdGF0ZURlY29kaW5nUHJvbWlzZS52YWx1ZSkge1xuICAgIHRocm93IHNzckluZm8uc3RhdGVEZWNvZGluZ1Byb21pc2U7XG4gIH1cbiAgbGV0IHJvdXRlcyA9ICgwLCBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzKShcbiAgICBzc3JJbmZvLm1hbmlmZXN0LnJvdXRlcyxcbiAgICBzc3JJbmZvLnJvdXRlTW9kdWxlcyxcbiAgICBzc3JJbmZvLmNvbnRleHQuc3RhdGUsXG4gICAgc3NySW5mby5jb250ZXh0LnNzcixcbiAgICBzc3JJbmZvLmNvbnRleHQuaXNTcGFNb2RlXG4gICk7XG4gIGxldCBoeWRyYXRpb25EYXRhID0gdm9pZCAwO1xuICBpZiAoc3NySW5mby5jb250ZXh0LmlzU3BhTW9kZSkge1xuICAgIGxldCB7IGxvYWRlckRhdGEgfSA9IHNzckluZm8uY29udGV4dC5zdGF0ZTtcbiAgICBpZiAoc3NySW5mby5tYW5pZmVzdC5yb3V0ZXMucm9vdD8uaGFzTG9hZGVyICYmIGxvYWRlckRhdGEgJiYgXCJyb290XCIgaW4gbG9hZGVyRGF0YSkge1xuICAgICAgaHlkcmF0aW9uRGF0YSA9IHtcbiAgICAgICAgbG9hZGVyRGF0YToge1xuICAgICAgICAgIHJvb3Q6IGxvYWRlckRhdGEucm9vdFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoeWRyYXRpb25EYXRhID0gKDAsIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9nZXRIeWRyYXRpb25EYXRhKShcbiAgICAgIHNzckluZm8uY29udGV4dC5zdGF0ZSxcbiAgICAgIHJvdXRlcyxcbiAgICAgIChyb3V0ZUlkKSA9PiAoe1xuICAgICAgICBjbGllbnRMb2FkZXI6IHNzckluZm8ucm91dGVNb2R1bGVzW3JvdXRlSWRdPy5jbGllbnRMb2FkZXIsXG4gICAgICAgIGhhc0xvYWRlcjogc3NySW5mby5tYW5pZmVzdC5yb3V0ZXNbcm91dGVJZF0/Lmhhc0xvYWRlciA9PT0gdHJ1ZSxcbiAgICAgICAgaGFzSHlkcmF0ZUZhbGxiYWNrOiBzc3JJbmZvLnJvdXRlTW9kdWxlc1tyb3V0ZUlkXT8uSHlkcmF0ZUZhbGxiYWNrICE9IG51bGxcbiAgICAgIH0pLFxuICAgICAgd2luZG93LmxvY2F0aW9uLFxuICAgICAgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0Py5iYXNlbmFtZSxcbiAgICAgIHNzckluZm8uY29udGV4dC5pc1NwYU1vZGVcbiAgICApO1xuICAgIGlmIChoeWRyYXRpb25EYXRhICYmIGh5ZHJhdGlvbkRhdGEuZXJyb3JzKSB7XG4gICAgICBoeWRyYXRpb25EYXRhLmVycm9ycyA9ICgwLCBpbXBvcnRfcmVhY3Rfcm91dGVyMi5VTlNBRkVfZGVzZXJpYWxpemVFcnJvcnMpKGh5ZHJhdGlvbkRhdGEuZXJyb3JzKTtcbiAgICB9XG4gIH1cbiAgbGV0IHJvdXRlcjIgPSAoMCwgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX2NyZWF0ZVJvdXRlcikoe1xuICAgIHJvdXRlcyxcbiAgICBoaXN0b3J5OiAoMCwgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX2NyZWF0ZUJyb3dzZXJIaXN0b3J5KSgpLFxuICAgIGJhc2VuYW1lOiBzc3JJbmZvLmNvbnRleHQuYmFzZW5hbWUsXG4gICAgdW5zdGFibGVfZ2V0Q29udGV4dCxcbiAgICBoeWRyYXRpb25EYXRhLFxuICAgIGh5ZHJhdGlvblJvdXRlUHJvcGVydGllczogaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX2h5ZHJhdGlvblJvdXRlUHJvcGVydGllcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXM6IGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgZnV0dXJlOiB7XG4gICAgICB1bnN0YWJsZV9taWRkbGV3YXJlOiBzc3JJbmZvLmNvbnRleHQuZnV0dXJlLnVuc3RhYmxlX21pZGRsZXdhcmVcbiAgICB9LFxuICAgIGRhdGFTdHJhdGVneTogKDAsIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9nZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5KShcbiAgICAgICgpID0+IHJvdXRlcjIsXG4gICAgICBzc3JJbmZvLm1hbmlmZXN0LFxuICAgICAgc3NySW5mby5yb3V0ZU1vZHVsZXMsXG4gICAgICBzc3JJbmZvLmNvbnRleHQuc3NyLFxuICAgICAgc3NySW5mby5jb250ZXh0LmJhc2VuYW1lXG4gICAgKSxcbiAgICBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbjogKDAsIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV9nZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uKShcbiAgICAgIHNzckluZm8ubWFuaWZlc3QsXG4gICAgICBzc3JJbmZvLnJvdXRlTW9kdWxlcyxcbiAgICAgIHNzckluZm8uY29udGV4dC5zc3IsXG4gICAgICBzc3JJbmZvLmNvbnRleHQucm91dGVEaXNjb3ZlcnksXG4gICAgICBzc3JJbmZvLmNvbnRleHQuaXNTcGFNb2RlLFxuICAgICAgc3NySW5mby5jb250ZXh0LmJhc2VuYW1lXG4gICAgKVxuICB9KTtcbiAgc3NySW5mby5yb3V0ZXIgPSByb3V0ZXIyO1xuICBpZiAocm91dGVyMi5zdGF0ZS5pbml0aWFsaXplZCkge1xuICAgIHNzckluZm8ucm91dGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHJvdXRlcjIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHJvdXRlcjIuY3JlYXRlUm91dGVzRm9ySE1SID0gLyogc3BhY2VyIHNvIHRzLWlnbm9yZSBkb2VzIG5vdCBhZmZlY3QgdGhlIHJpZ2h0IGhhbmQgb2YgdGhlIGFzc2lnbm1lbnQgKi9cbiAgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlc1dpdGhITVJSZXZhbGlkYXRpb25PcHRPdXQ7XG4gIHdpbmRvdy5fX3JlYWN0Um91dGVyRGF0YVJvdXRlciA9IHJvdXRlcjI7XG4gIHJldHVybiByb3V0ZXIyO1xufVxuZnVuY3Rpb24gSHlkcmF0ZWRSb3V0ZXIocHJvcHMpIHtcbiAgaWYgKCFyb3V0ZXIpIHtcbiAgICByb3V0ZXIgPSBjcmVhdGVIeWRyYXRlZFJvdXRlcih7XG4gICAgICB1bnN0YWJsZV9nZXRDb250ZXh0OiBwcm9wcy51bnN0YWJsZV9nZXRDb250ZXh0XG4gICAgfSk7XG4gIH1cbiAgbGV0IFtjcml0aWNhbENzcywgc2V0Q3JpdGljYWxDc3NdID0gUmVhY3QyLnVzZVN0YXRlKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIgPyBzc3JJbmZvPy5jb250ZXh0LmNyaXRpY2FsQ3NzIDogdm9pZCAwXG4gICk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgaWYgKHNzckluZm8pIHtcbiAgICAgIHdpbmRvdy5fX3JlYWN0Um91dGVyQ2xlYXJDcml0aWNhbENzcyA9ICgpID0+IHNldENyaXRpY2FsQ3NzKHZvaWQgMCk7XG4gICAgfVxuICB9XG4gIGxldCBbbG9jYXRpb24sIHNldExvY2F0aW9uXSA9IFJlYWN0Mi51c2VTdGF0ZShyb3V0ZXIuc3RhdGUubG9jYXRpb24pO1xuICBSZWFjdDIudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc3NySW5mbyAmJiBzc3JJbmZvLnJvdXRlciAmJiAhc3NySW5mby5yb3V0ZXJJbml0aWFsaXplZCkge1xuICAgICAgc3NySW5mby5yb3V0ZXJJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBzc3JJbmZvLnJvdXRlci5pbml0aWFsaXplKCk7XG4gICAgfVxuICB9LCBbXSk7XG4gIFJlYWN0Mi51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzc3JJbmZvICYmIHNzckluZm8ucm91dGVyKSB7XG4gICAgICByZXR1cm4gc3NySW5mby5yb3V0ZXIuc3Vic2NyaWJlKChuZXdTdGF0ZSkgPT4ge1xuICAgICAgICBpZiAobmV3U3RhdGUubG9jYXRpb24gIT09IGxvY2F0aW9uKSB7XG4gICAgICAgICAgc2V0TG9jYXRpb24obmV3U3RhdGUubG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtsb2NhdGlvbl0pO1xuICAoMCwgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX2ludmFyaWFudCkoc3NySW5mbywgXCJzc3JJbmZvIHVuYXZhaWxhYmxlIGZvciBIeWRyYXRlZFJvdXRlclwiKTtcbiAgKDAsIGltcG9ydF9yZWFjdF9yb3V0ZXIyLlVOU0FGRV91c2VGb2dPRldhckRpc2NvdmVyeSkoXG4gICAgcm91dGVyLFxuICAgIHNzckluZm8ubWFuaWZlc3QsXG4gICAgc3NySW5mby5yb3V0ZU1vZHVsZXMsXG4gICAgc3NySW5mby5jb250ZXh0LnNzcixcbiAgICBzc3JJbmZvLmNvbnRleHQucm91dGVEaXNjb3ZlcnksXG4gICAgc3NySW5mby5jb250ZXh0LmlzU3BhTW9kZVxuICApO1xuICByZXR1cm4gKFxuICAgIC8vIFRoaXMgZnJhZ21lbnQgaXMgaW1wb3J0YW50IHRvIGVuc3VyZSB3ZSBtYXRjaCB0aGUgPFNlcnZlclJvdXRlcj4gSlNYXG4gICAgLy8gc3RydWN0dXJlIHNvIHRoYXQgdXNlSWQgdmFsdWVzIGh5ZHJhdGUgY29ycmVjdGx5XG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJlYWN0Mi5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX0ZyYW1ld29ya0NvbnRleHQuUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgbWFuaWZlc3Q6IHNzckluZm8ubWFuaWZlc3QsXG4gICAgICAgICAgcm91dGVNb2R1bGVzOiBzc3JJbmZvLnJvdXRlTW9kdWxlcyxcbiAgICAgICAgICBmdXR1cmU6IHNzckluZm8uY29udGV4dC5mdXR1cmUsXG4gICAgICAgICAgY3JpdGljYWxDc3MsXG4gICAgICAgICAgc3NyOiBzc3JJbmZvLmNvbnRleHQuc3NyLFxuICAgICAgICAgIGlzU3BhTW9kZTogc3NySW5mby5jb250ZXh0LmlzU3BhTW9kZSxcbiAgICAgICAgICByb3V0ZURpc2NvdmVyeTogc3NySW5mby5jb250ZXh0LnJvdXRlRGlzY292ZXJ5XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoaW1wb3J0X3JlYWN0X3JvdXRlcjIuVU5TQUZFX1JlbWl4RXJyb3JCb3VuZGFyeSwgeyBsb2NhdGlvbiB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUm91dGVyUHJvdmlkZXIsIHsgcm91dGVyIH0pKVxuICAgICksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSZWFjdDIuRnJhZ21lbnQsIG51bGwpKVxuICApO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIEh5ZHJhdGVkUm91dGVyLFxuICBSb3V0ZXJQcm92aWRlclxufSk7XG4iXSwibmFtZXMiOlsiX19jcmVhdGUiLCJPYmplY3QiLCJjcmVhdGUiLCJfX2RlZlByb3AiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcERlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2dldE93blByb3BOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX2dldFByb3RvT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9faGFzT3duUHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsIl9fY29weVByb3BzIiwidG8iLCJmcm9tIiwiZXhjZXB0IiwiZGVzYyIsImtleSIsImNhbGwiLCJfX3RvRVNNIiwibW9kIiwiaXNOb2RlTW9kZSIsIl9fZXNNb2R1bGUiLCJ2YWx1ZSIsIl9fdG9Db21tb25KUyIsImRvbV9leHBvcnRfZXhwb3J0cyIsIkh5ZHJhdGVkUm91dGVyIiwiUm91dGVyUHJvdmlkZXIiLCJtb2R1bGUiLCJleHBvcnRzIiwiUmVhY3QiLCJyZXF1aXJlIiwiUmVhY3RET00iLCJpbXBvcnRfcmVhY3Rfcm91dGVyIiwicHJvcHMiLCJjcmVhdGVFbGVtZW50IiwiZmx1c2hTeW5jIiwiUmVhY3QyIiwiaW1wb3J0X3JlYWN0X3JvdXRlcjIiLCJzc3JJbmZvIiwicm91dGVyIiwiaW5pdFNzckluZm8iLCJ3aW5kb3ciLCJfX3JlYWN0Um91dGVyQ29udGV4dCIsIl9fcmVhY3RSb3V0ZXJNYW5pZmVzdCIsIl9fcmVhY3RSb3V0ZXJSb3V0ZU1vZHVsZXMiLCJzcmkiLCJpbXBvcnRNYXAiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZXh0Q29udGVudCIsIkpTT04iLCJwYXJzZSIsImludGVncml0eSIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImNvbnRleHQiLCJtYW5pZmVzdCIsInJvdXRlTW9kdWxlcyIsInN0YXRlRGVjb2RpbmdQcm9taXNlIiwicm91dGVySW5pdGlhbGl6ZWQiLCJjcmVhdGVIeWRyYXRlZFJvdXRlciIsInVuc3RhYmxlX2dldENvbnRleHQiLCJFcnJvciIsImxvY2FsU3NySW5mbyIsInN0cmVhbSIsIlVOU0FGRV9pbnZhcmlhbnQiLCJVTlNBRkVfZGVjb2RlVmlhVHVyYm9TdHJlYW0iLCJ0aGVuIiwic3RhdGUiLCJjYXRjaCIsImUiLCJyb3V0ZXMiLCJVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzIiwic3NyIiwiaXNTcGFNb2RlIiwiaHlkcmF0aW9uRGF0YSIsImxvYWRlckRhdGEiLCJyb290IiwiaGFzTG9hZGVyIiwiVU5TQUZFX2dldEh5ZHJhdGlvbkRhdGEiLCJyb3V0ZUlkIiwiY2xpZW50TG9hZGVyIiwiaGFzSHlkcmF0ZUZhbGxiYWNrIiwiSHlkcmF0ZUZhbGxiYWNrIiwibG9jYXRpb24iLCJiYXNlbmFtZSIsImVycm9ycyIsIlVOU0FGRV9kZXNlcmlhbGl6ZUVycm9ycyIsInJvdXRlcjIiLCJVTlNBRkVfY3JlYXRlUm91dGVyIiwiaGlzdG9yeSIsIlVOU0FGRV9jcmVhdGVCcm93c2VySGlzdG9yeSIsImh5ZHJhdGlvblJvdXRlUHJvcGVydGllcyIsIlVOU0FGRV9oeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMiLCJtYXBSb3V0ZVByb3BlcnRpZXMiLCJVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzIiwiZnV0dXJlIiwidW5zdGFibGVfbWlkZGxld2FyZSIsImRhdGFTdHJhdGVneSIsIlVOU0FGRV9nZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5IiwicGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24iLCJVTlNBRkVfZ2V0UGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25GdW5jdGlvbiIsInJvdXRlRGlzY292ZXJ5IiwiaW5pdGlhbGl6ZWQiLCJpbml0aWFsaXplIiwiY3JlYXRlUm91dGVzRm9ySE1SIiwiVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlc1dpdGhITVJSZXZhbGlkYXRpb25PcHRPdXQiLCJfX3JlYWN0Um91dGVyRGF0YVJvdXRlciIsImNyaXRpY2FsQ3NzIiwic2V0Q3JpdGljYWxDc3MiLCJ1c2VTdGF0ZSIsInByb2Nlc3MiLCJfX3JlYWN0Um91dGVyQ2xlYXJDcml0aWNhbENzcyIsInNldExvY2F0aW9uIiwidXNlTGF5b3V0RWZmZWN0Iiwic3Vic2NyaWJlIiwibmV3U3RhdGUiLCJVTlNBRkVfdXNlRm9nT0ZXYXJEaXNjb3ZlcnkiLCJGcmFnbWVudCIsIlVOU0FGRV9GcmFtZXdvcmtDb250ZXh0IiwiUHJvdmlkZXIiLCJVTlNBRkVfUmVtaXhFcnJvckJvdW5kYXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/development/dom-export.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-router/dist/development/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-router/dist/development/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * react-router v7.6.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __typeError = (msg)=>{\n    throw TypeError(msg);\n};\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\nvar __accessCheck = (obj, member, msg)=>member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter)=>(__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value)=>member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n// index.ts\nvar react_router_exports = {};\n__export(react_router_exports, {\n    Await: ()=>Await,\n    BrowserRouter: ()=>BrowserRouter,\n    Form: ()=>Form,\n    HashRouter: ()=>HashRouter,\n    IDLE_BLOCKER: ()=>IDLE_BLOCKER,\n    IDLE_FETCHER: ()=>IDLE_FETCHER,\n    IDLE_NAVIGATION: ()=>IDLE_NAVIGATION,\n    Link: ()=>Link,\n    Links: ()=>Links,\n    MemoryRouter: ()=>MemoryRouter,\n    Meta: ()=>Meta,\n    NavLink: ()=>NavLink,\n    Navigate: ()=>Navigate,\n    NavigationType: ()=>Action,\n    Outlet: ()=>Outlet,\n    PrefetchPageLinks: ()=>PrefetchPageLinks,\n    Route: ()=>Route,\n    Router: ()=>Router,\n    RouterProvider: ()=>RouterProvider,\n    Routes: ()=>Routes,\n    Scripts: ()=>Scripts,\n    ScrollRestoration: ()=>ScrollRestoration,\n    ServerRouter: ()=>ServerRouter,\n    StaticRouter: ()=>StaticRouter,\n    StaticRouterProvider: ()=>StaticRouterProvider,\n    UNSAFE_DataRouterContext: ()=>DataRouterContext,\n    UNSAFE_DataRouterStateContext: ()=>DataRouterStateContext,\n    UNSAFE_ErrorResponseImpl: ()=>ErrorResponseImpl,\n    UNSAFE_FetchersContext: ()=>FetchersContext,\n    UNSAFE_FrameworkContext: ()=>FrameworkContext,\n    UNSAFE_LocationContext: ()=>LocationContext,\n    UNSAFE_NavigationContext: ()=>NavigationContext,\n    UNSAFE_RemixErrorBoundary: ()=>RemixErrorBoundary,\n    UNSAFE_RouteContext: ()=>RouteContext,\n    UNSAFE_ServerMode: ()=>ServerMode,\n    UNSAFE_SingleFetchRedirectSymbol: ()=>SingleFetchRedirectSymbol,\n    UNSAFE_ViewTransitionContext: ()=>ViewTransitionContext,\n    UNSAFE_createBrowserHistory: ()=>createBrowserHistory,\n    UNSAFE_createClientRoutes: ()=>createClientRoutes,\n    UNSAFE_createClientRoutesWithHMRRevalidationOptOut: ()=>createClientRoutesWithHMRRevalidationOptOut,\n    UNSAFE_createRouter: ()=>createRouter,\n    UNSAFE_decodeViaTurboStream: ()=>decodeViaTurboStream,\n    UNSAFE_deserializeErrors: ()=>deserializeErrors2,\n    UNSAFE_getHydrationData: ()=>getHydrationData,\n    UNSAFE_getPatchRoutesOnNavigationFunction: ()=>getPatchRoutesOnNavigationFunction,\n    UNSAFE_getTurboStreamSingleFetchDataStrategy: ()=>getTurboStreamSingleFetchDataStrategy,\n    UNSAFE_hydrationRouteProperties: ()=>hydrationRouteProperties,\n    UNSAFE_invariant: ()=>invariant,\n    UNSAFE_mapRouteProperties: ()=>mapRouteProperties,\n    UNSAFE_shouldHydrateRouteLoader: ()=>shouldHydrateRouteLoader,\n    UNSAFE_useFogOFWarDiscovery: ()=>useFogOFWarDiscovery,\n    UNSAFE_useScrollRestoration: ()=>useScrollRestoration,\n    createBrowserRouter: ()=>createBrowserRouter,\n    createCookie: ()=>createCookie,\n    createCookieSessionStorage: ()=>createCookieSessionStorage,\n    createHashRouter: ()=>createHashRouter,\n    createMemoryRouter: ()=>createMemoryRouter,\n    createMemorySessionStorage: ()=>createMemorySessionStorage,\n    createPath: ()=>createPath,\n    createRequestHandler: ()=>createRequestHandler,\n    createRoutesFromChildren: ()=>createRoutesFromChildren,\n    createRoutesFromElements: ()=>createRoutesFromElements,\n    createRoutesStub: ()=>createRoutesStub,\n    createSearchParams: ()=>createSearchParams,\n    createSession: ()=>createSession,\n    createSessionStorage: ()=>createSessionStorage,\n    createStaticHandler: ()=>createStaticHandler2,\n    createStaticRouter: ()=>createStaticRouter,\n    data: ()=>data,\n    generatePath: ()=>generatePath,\n    href: ()=>href,\n    isCookie: ()=>isCookie,\n    isRouteErrorResponse: ()=>isRouteErrorResponse,\n    isSession: ()=>isSession,\n    matchPath: ()=>matchPath,\n    matchRoutes: ()=>matchRoutes,\n    parsePath: ()=>parsePath,\n    redirect: ()=>redirect,\n    redirectDocument: ()=>redirectDocument,\n    renderMatches: ()=>renderMatches,\n    replace: ()=>replace,\n    resolvePath: ()=>resolvePath,\n    unstable_HistoryRouter: ()=>HistoryRouter,\n    unstable_RouterContextProvider: ()=>unstable_RouterContextProvider,\n    unstable_createContext: ()=>unstable_createContext,\n    unstable_setDevServerHooks: ()=>setDevServerHooks,\n    unstable_usePrompt: ()=>usePrompt,\n    useActionData: ()=>useActionData,\n    useAsyncError: ()=>useAsyncError,\n    useAsyncValue: ()=>useAsyncValue,\n    useBeforeUnload: ()=>useBeforeUnload,\n    useBlocker: ()=>useBlocker,\n    useFetcher: ()=>useFetcher,\n    useFetchers: ()=>useFetchers,\n    useFormAction: ()=>useFormAction,\n    useHref: ()=>useHref,\n    useInRouterContext: ()=>useInRouterContext,\n    useLinkClickHandler: ()=>useLinkClickHandler,\n    useLoaderData: ()=>useLoaderData,\n    useLocation: ()=>useLocation,\n    useMatch: ()=>useMatch,\n    useMatches: ()=>useMatches,\n    useNavigate: ()=>useNavigate,\n    useNavigation: ()=>useNavigation,\n    useNavigationType: ()=>useNavigationType,\n    useOutlet: ()=>useOutlet,\n    useOutletContext: ()=>useOutletContext,\n    useParams: ()=>useParams,\n    useResolvedPath: ()=>useResolvedPath,\n    useRevalidator: ()=>useRevalidator,\n    useRouteError: ()=>useRouteError,\n    useRouteLoaderData: ()=>useRouteLoaderData,\n    useRoutes: ()=>useRoutes,\n    useSearchParams: ()=>useSearchParams,\n    useSubmit: ()=>useSubmit,\n    useViewTransitionState: ()=>useViewTransitionState\n});\nmodule.exports = __toCommonJS(react_router_exports);\n// lib/router/history.ts\nvar Action = /* @__PURE__ */ ((Action2)=>{\n    Action2[\"Pop\"] = \"POP\";\n    Action2[\"Push\"] = \"PUSH\";\n    Action2[\"Replace\"] = \"REPLACE\";\n    return Action2;\n})(Action || {});\nvar PopStateEventType = \"popstate\";\nfunction createMemoryHistory(options = {}) {\n    let { initialEntries = [\n        \"/\"\n    ], initialIndex, v5Compat = false } = options;\n    let entries;\n    entries = initialEntries.map((entry, index2)=>createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index2 === 0 ? \"default\" : void 0));\n    let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n    let action = \"POP\" /* Pop */ ;\n    let listener = null;\n    function clampIndex(n) {\n        return Math.min(Math.max(n, 0), entries.length - 1);\n    }\n    function getCurrentLocation() {\n        return entries[index];\n    }\n    function createMemoryLocation(to, state = null, key) {\n        let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n        warning(location.pathname.charAt(0) === \"/\", `relative pathnames are not supported in memory history: ${JSON.stringify(to)}`);\n        return location;\n    }\n    function createHref2(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    let history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return getCurrentLocation();\n        },\n        createHref: createHref2,\n        createURL (to) {\n            return new URL(createHref2(to), \"http://localhost\");\n        },\n        encodeLocation (to) {\n            let path = typeof to === \"string\" ? parsePath(to) : to;\n            return {\n                pathname: path.pathname || \"\",\n                search: path.search || \"\",\n                hash: path.hash || \"\"\n            };\n        },\n        push (to, state) {\n            action = \"PUSH\" /* Push */ ;\n            let nextLocation = createMemoryLocation(to, state);\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 1\n                });\n            }\n        },\n        replace (to, state) {\n            action = \"REPLACE\" /* Replace */ ;\n            let nextLocation = createMemoryLocation(to, state);\n            entries[index] = nextLocation;\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 0\n                });\n            }\n        },\n        go (delta) {\n            action = \"POP\" /* Pop */ ;\n            let nextIndex = clampIndex(index + delta);\n            let nextLocation = entries[nextIndex];\n            index = nextIndex;\n            if (listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta\n                });\n            }\n        },\n        listen (fn) {\n            listener = fn;\n            return ()=>{\n                listener = null;\n            };\n        }\n    };\n    return history;\n}\nfunction createBrowserHistory(options = {}) {\n    function createBrowserLocation(window2, globalHistory) {\n        let { pathname, search, hash } = window2.location;\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createBrowserHref(window2, to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\nfunction createHashHistory(options = {}) {\n    function createHashLocation(window2, globalHistory) {\n        let { pathname = \"/\", search = \"\", hash = \"\" } = parsePath(window2.location.hash.substring(1));\n        if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n            pathname = \"/\" + pathname;\n        }\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createHashHref(window2, to) {\n        let base = window2.document.querySelector(\"base\");\n        let href2 = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            let url = window2.location.href;\n            let hashIndex = url.indexOf(\"#\");\n            href2 = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href2 + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function validateHashLocation(location, to) {\n        warning(location.pathname.charAt(0) === \"/\", `relative pathnames are not supported in hash history.push(${JSON.stringify(to)})`);\n    }\n    return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\nfunction warning(cond, message) {\n    if (!cond) {\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            throw new Error(message);\n        } catch (e) {}\n    }\n}\nfunction createKey() {\n    return Math.random().toString(36).substring(2, 10);\n}\nfunction getHistoryState(location, index) {\n    return {\n        usr: location.state,\n        key: location.key,\n        idx: index\n    };\n}\nfunction createLocation(current, to, state = null, key) {\n    let location = {\n        pathname: typeof current === \"string\" ? current : current.pathname,\n        search: \"\",\n        hash: \"\",\n        ...typeof to === \"string\" ? parsePath(to) : to,\n        state,\n        // TODO: This could be cleaned up.  push/replace should probably just take\n        // full Locations now and avoid the need to run through this flow at all\n        // But that's a pretty big refactor to the current test suite so going to\n        // keep as is for the time being and just let any incoming keys take precedence\n        key: to && to.key || key || createKey()\n    };\n    return location;\n}\nfunction createPath({ pathname = \"/\", search = \"\", hash = \"\" }) {\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\nfunction parsePath(path) {\n    let parsedPath = {};\n    if (path) {\n        let hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substring(hashIndex);\n            path = path.substring(0, hashIndex);\n        }\n        let searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substring(searchIndex);\n            path = path.substring(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {\n    let { window: window2 = document.defaultView, v5Compat = false } = options;\n    let globalHistory = window2.history;\n    let action = \"POP\" /* Pop */ ;\n    let listener = null;\n    let index = getIndex();\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState({\n            ...globalHistory.state,\n            idx: index\n        }, \"\");\n    }\n    function getIndex() {\n        let state = globalHistory.state || {\n            idx: null\n        };\n        return state.idx;\n    }\n    function handlePop() {\n        action = \"POP\" /* Pop */ ;\n        let nextIndex = getIndex();\n        let delta = nextIndex == null ? null : nextIndex - index;\n        index = nextIndex;\n        if (listener) {\n            listener({\n                action,\n                location: history.location,\n                delta\n            });\n        }\n    }\n    function push(to, state) {\n        action = \"PUSH\" /* Push */ ;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex() + 1;\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        try {\n            globalHistory.pushState(historyState, \"\", url);\n        } catch (error) {\n            if (error instanceof DOMException && error.name === \"DataCloneError\") {\n                throw error;\n            }\n            window2.location.assign(url);\n        }\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 1\n            });\n        }\n    }\n    function replace2(to, state) {\n        action = \"REPLACE\" /* Replace */ ;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex();\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        globalHistory.replaceState(historyState, \"\", url);\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 0\n            });\n        }\n    }\n    function createURL(to) {\n        return createBrowserURLImpl(to);\n    }\n    let history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return getLocation(window2, globalHistory);\n        },\n        listen (fn) {\n            if (listener) {\n                throw new Error(\"A history only accepts one active listener\");\n            }\n            window2.addEventListener(PopStateEventType, handlePop);\n            listener = fn;\n            return ()=>{\n                window2.removeEventListener(PopStateEventType, handlePop);\n                listener = null;\n            };\n        },\n        createHref (to) {\n            return createHref2(window2, to);\n        },\n        createURL,\n        encodeLocation (to) {\n            let url = createURL(to);\n            return {\n                pathname: url.pathname,\n                search: url.search,\n                hash: url.hash\n            };\n        },\n        push,\n        replace: replace2,\n        go (n) {\n            return globalHistory.go(n);\n        }\n    };\n    return history;\n}\nfunction createBrowserURLImpl(to, isAbsolute = false) {\n    let base = \"http://localhost\";\n    if (false) {}\n    invariant(base, \"No window.location.(origin|href) available to create URL\");\n    let href2 = typeof to === \"string\" ? to : createPath(to);\n    href2 = href2.replace(/ $/, \"%20\");\n    if (!isAbsolute && href2.startsWith(\"//\")) {\n        href2 = base + href2;\n    }\n    return new URL(href2, base);\n}\n// lib/router/utils.ts\nfunction unstable_createContext(defaultValue) {\n    return {\n        defaultValue\n    };\n}\nvar _map;\nvar unstable_RouterContextProvider = class {\n    constructor(init){\n        __privateAdd(this, _map, /* @__PURE__ */ new Map());\n        if (init) {\n            for (let [context, value] of init){\n                this.set(context, value);\n            }\n        }\n    }\n    get(context) {\n        if (__privateGet(this, _map).has(context)) {\n            return __privateGet(this, _map).get(context);\n        }\n        if (context.defaultValue !== void 0) {\n            return context.defaultValue;\n        }\n        throw new Error(\"No value found for context\");\n    }\n    set(context, value) {\n        __privateGet(this, _map).set(context, value);\n    }\n};\n_map = new WeakMap();\nvar unsupportedLazyRouteObjectKeys = /* @__PURE__ */ new Set([\n    \"lazy\",\n    \"caseSensitive\",\n    \"path\",\n    \"id\",\n    \"index\",\n    \"children\"\n]);\nfunction isUnsupportedLazyRouteObjectKey(key) {\n    return unsupportedLazyRouteObjectKeys.has(key);\n}\nvar unsupportedLazyRouteFunctionKeys = /* @__PURE__ */ new Set([\n    \"lazy\",\n    \"caseSensitive\",\n    \"path\",\n    \"id\",\n    \"index\",\n    \"unstable_middleware\",\n    \"children\"\n]);\nfunction isUnsupportedLazyRouteFunctionKey(key) {\n    return unsupportedLazyRouteFunctionKeys.has(key);\n}\nfunction isIndexRoute(route) {\n    return route.index === true;\n}\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {\n    return routes.map((route, index)=>{\n        let treePath = [\n            ...parentPath,\n            String(index)\n        ];\n        let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n        invariant(route.index !== true || !route.children, `Cannot specify children on an index route`);\n        invariant(!manifest[id], `Found a route id collision on id \"${id}\".  Route id's must be globally unique within Data Router usages`);\n        if (isIndexRoute(route)) {\n            let indexRoute = {\n                ...route,\n                ...mapRouteProperties2(route),\n                id\n            };\n            manifest[id] = indexRoute;\n            return indexRoute;\n        } else {\n            let pathOrLayoutRoute = {\n                ...route,\n                ...mapRouteProperties2(route),\n                id,\n                children: void 0\n            };\n            manifest[id] = pathOrLayoutRoute;\n            if (route.children) {\n                pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);\n            }\n            return pathOrLayoutRoute;\n        }\n    });\n}\nfunction matchRoutes(routes, locationArg, basename = \"/\") {\n    return matchRoutesImpl(routes, locationArg, basename, false);\n}\nfunction matchRoutesImpl(routes, locationArg, basename, allowPartial) {\n    let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    let pathname = stripBasename(location.pathname || \"/\", basename);\n    if (pathname == null) {\n        return null;\n    }\n    let branches = flattenRoutes(routes);\n    rankRouteBranches(branches);\n    let matches = null;\n    for(let i = 0; matches == null && i < branches.length; ++i){\n        let decoded = decodePath(pathname);\n        matches = matchRouteBranch(branches[i], decoded, allowPartial);\n    }\n    return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n    let { route, pathname, params } = match;\n    return {\n        id: route.id,\n        pathname,\n        params,\n        data: loaderData[route.id],\n        handle: route.handle\n    };\n}\nfunction flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = \"\") {\n    let flattenRoute = (route, index, relativePath)=>{\n        let meta = {\n            relativePath: relativePath === void 0 ? route.path || \"\" : relativePath,\n            caseSensitive: route.caseSensitive === true,\n            childrenIndex: index,\n            route\n        };\n        if (meta.relativePath.startsWith(\"/\")) {\n            invariant(meta.relativePath.startsWith(parentPath), `Absolute route path \"${meta.relativePath}\" nested under path \"${parentPath}\" is not valid. An absolute child route path must start with the combined path of all its parent routes.`);\n            meta.relativePath = meta.relativePath.slice(parentPath.length);\n        }\n        let path = joinPaths([\n            parentPath,\n            meta.relativePath\n        ]);\n        let routesMeta = parentsMeta.concat(meta);\n        if (route.children && route.children.length > 0) {\n            invariant(// Our types know better, but runtime JS may not!\n            // @ts-expect-error\n            route.index !== true, `Index routes must not have child routes. Please remove all child routes from route path \"${path}\".`);\n            flattenRoutes(route.children, branches, routesMeta, path);\n        }\n        if (route.path == null && !route.index) {\n            return;\n        }\n        branches.push({\n            path,\n            score: computeScore(path, route.index),\n            routesMeta\n        });\n    };\n    routes.forEach((route, index)=>{\n        if (route.path === \"\" || !route.path?.includes(\"?\")) {\n            flattenRoute(route, index);\n        } else {\n            for (let exploded of explodeOptionalSegments(route.path)){\n                flattenRoute(route, index, exploded);\n            }\n        }\n    });\n    return branches;\n}\nfunction explodeOptionalSegments(path) {\n    let segments = path.split(\"/\");\n    if (segments.length === 0) return [];\n    let [first, ...rest] = segments;\n    let isOptional = first.endsWith(\"?\");\n    let required = first.replace(/\\?$/, \"\");\n    if (rest.length === 0) {\n        return isOptional ? [\n            required,\n            \"\"\n        ] : [\n            required\n        ];\n    }\n    let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n    let result = [];\n    result.push(...restExploded.map((subpath)=>subpath === \"\" ? required : [\n            required,\n            subpath\n        ].join(\"/\")));\n    if (isOptional) {\n        result.push(...restExploded);\n    }\n    return result.map((exploded)=>path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n    branches.sort((a, b)=>a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta)=>meta.childrenIndex), b.routesMeta.map((meta)=>meta.childrenIndex)));\n}\nvar paramRe = /^:[\\w-]+$/;\nvar dynamicSegmentValue = 3;\nvar indexRouteValue = 2;\nvar emptySegmentValue = 1;\nvar staticSegmentValue = 10;\nvar splatPenalty = -2;\nvar isSplat = (s)=>s === \"*\";\nfunction computeScore(path, index) {\n    let segments = path.split(\"/\");\n    let initialScore = segments.length;\n    if (segments.some(isSplat)) {\n        initialScore += splatPenalty;\n    }\n    if (index) {\n        initialScore += indexRouteValue;\n    }\n    return segments.filter((s)=>!isSplat(s)).reduce((score, segment)=>score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n    let siblings = a.length === b.length && a.slice(0, -1).every((n, i)=>n === b[i]);\n    return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0;\n}\nfunction matchRouteBranch(branch, pathname, allowPartial = false) {\n    let { routesMeta } = branch;\n    let matchedParams = {};\n    let matchedPathname = \"/\";\n    let matches = [];\n    for(let i = 0; i < routesMeta.length; ++i){\n        let meta = routesMeta[i];\n        let end = i === routesMeta.length - 1;\n        let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n        let match = matchPath({\n            path: meta.relativePath,\n            caseSensitive: meta.caseSensitive,\n            end\n        }, remainingPathname);\n        let route = meta.route;\n        if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {\n            match = matchPath({\n                path: meta.relativePath,\n                caseSensitive: meta.caseSensitive,\n                end: false\n            }, remainingPathname);\n        }\n        if (!match) {\n            return null;\n        }\n        Object.assign(matchedParams, match.params);\n        matches.push({\n            // TODO: Can this as be avoided?\n            params: matchedParams,\n            pathname: joinPaths([\n                matchedPathname,\n                match.pathname\n            ]),\n            pathnameBase: normalizePathname(joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ])),\n            route\n        });\n        if (match.pathnameBase !== \"/\") {\n            matchedPathname = joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ]);\n        }\n    }\n    return matches;\n}\nfunction generatePath(originalPath, params = {}) {\n    let path = originalPath;\n    if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n        warning(false, `Route path \"${path}\" will be treated as if it were \"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must always follow a \\`/\\` in the pattern. To get rid of this warning, please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`);\n        path = path.replace(/\\*$/, \"/*\");\n    }\n    const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n    const stringify2 = (p)=>p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n    const segments = path.split(/\\/+/).map((segment, index, array)=>{\n        const isLastSegment = index === array.length - 1;\n        if (isLastSegment && segment === \"*\") {\n            const star = \"*\";\n            return stringify2(params[star]);\n        }\n        const keyMatch = segment.match(/^:([\\w-]+)(\\??)$/);\n        if (keyMatch) {\n            const [, key, optional] = keyMatch;\n            let param = params[key];\n            invariant(optional === \"?\" || param != null, `Missing \":${key}\" param`);\n            return stringify2(param);\n        }\n        return segment.replace(/\\?$/g, \"\");\n    }).filter((segment)=>!!segment);\n    return prefix + segments.join(\"/\");\n}\nfunction matchPath(pattern, pathname) {\n    if (typeof pattern === \"string\") {\n        pattern = {\n            path: pattern,\n            caseSensitive: false,\n            end: true\n        };\n    }\n    let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n    let match = pathname.match(matcher);\n    if (!match) return null;\n    let matchedPathname = match[0];\n    let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n    let captureGroups = match.slice(1);\n    let params = compiledParams.reduce((memo2, { paramName, isOptional }, index)=>{\n        if (paramName === \"*\") {\n            let splatValue = captureGroups[index] || \"\";\n            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        const value = captureGroups[index];\n        if (isOptional && !value) {\n            memo2[paramName] = void 0;\n        } else {\n            memo2[paramName] = (value || \"\").replace(/%2F/g, \"/\");\n        }\n        return memo2;\n    }, {});\n    return {\n        params,\n        pathname: matchedPathname,\n        pathnameBase,\n        pattern\n    };\n}\nfunction compilePath(path, caseSensitive = false, end = true) {\n    warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), `Route path \"${path}\" will be treated as if it were \"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must always follow a \\`/\\` in the pattern. To get rid of this warning, please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`);\n    let params = [];\n    let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\").replace(/^\\/*/, \"/\").replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\").replace(/\\/:([\\w-]+)(\\?)?/g, (_, paramName, isOptional)=>{\n        params.push({\n            paramName,\n            isOptional: isOptional != null\n        });\n        return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n    });\n    if (path.endsWith(\"*\")) {\n        params.push({\n            paramName: \"*\"\n        });\n        regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" : \"(?:\\\\/(.+)|\\\\/*)$\";\n    } else if (end) {\n        regexpSource += \"\\\\/*$\";\n    } else if (path !== \"\" && path !== \"/\") {\n        regexpSource += \"(?:(?=\\\\/|$))\";\n    } else {}\n    let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : \"i\");\n    return [\n        matcher,\n        params\n    ];\n}\nfunction decodePath(value) {\n    try {\n        return value.split(\"/\").map((v)=>decodeURIComponent(v).replace(/\\//g, \"%2F\")).join(\"/\");\n    } catch (error) {\n        warning(false, `The URL path \"${value}\" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`);\n        return value;\n    }\n}\nfunction stripBasename(pathname, basename) {\n    if (basename === \"/\") return pathname;\n    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n        return null;\n    }\n    let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n    let nextChar = pathname.charAt(startIndex);\n    if (nextChar && nextChar !== \"/\") {\n        return null;\n    }\n    return pathname.slice(startIndex) || \"/\";\n}\nfunction resolvePath(to, fromPathname = \"/\") {\n    let { pathname: toPathname, search = \"\", hash = \"\" } = typeof to === \"string\" ? parsePath(to) : to;\n    let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n    return {\n        pathname,\n        search: normalizeSearch(search),\n        hash: normalizeHash(hash)\n    };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n    let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n    let relativeSegments = relativePath.split(\"/\");\n    relativeSegments.forEach((segment)=>{\n        if (segment === \"..\") {\n            if (segments.length > 1) segments.pop();\n        } else if (segment !== \".\") {\n            segments.push(segment);\n        }\n    });\n    return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n    return `Cannot include a '${char}' character in a manually specified \\`to.${field}\\` field [${JSON.stringify(path)}].  Please separate it out to the \\`to.${dest}\\` field. Alternatively you may provide the full path as a string in <Link to=\"...\"> and the router will parse it for you.`;\n}\nfunction getPathContributingMatches(matches) {\n    return matches.filter((match, index)=>index === 0 || match.route.path && match.route.path.length > 0);\n}\nfunction getResolveToMatches(matches) {\n    let pathMatches = getPathContributingMatches(matches);\n    return pathMatches.map((match, idx)=>idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);\n}\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {\n    let to;\n    if (typeof toArg === \"string\") {\n        to = parsePath(toArg);\n    } else {\n        to = {\n            ...toArg\n        };\n        invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n        invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n        invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n    }\n    let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n    let toPathname = isEmptyPath ? \"/\" : to.pathname;\n    let from;\n    if (toPathname == null) {\n        from = locationPathname;\n    } else {\n        let routePathnameIndex = routePathnames.length - 1;\n        if (!isPathRelative && toPathname.startsWith(\"..\")) {\n            let toSegments = toPathname.split(\"/\");\n            while(toSegments[0] === \"..\"){\n                toSegments.shift();\n                routePathnameIndex -= 1;\n            }\n            to.pathname = toSegments.join(\"/\");\n        }\n        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n    }\n    let path = resolvePath(to, from);\n    let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n    if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n        path.pathname += \"/\";\n    }\n    return path;\n}\nvar joinPaths = (paths)=>paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\nvar normalizePathname = (pathname)=>pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\nvar normalizeSearch = (search)=>!search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\nvar normalizeHash = (hash)=>!hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\nvar DataWithResponseInit = class {\n    constructor(data2, init){\n        this.type = \"DataWithResponseInit\";\n        this.data = data2;\n        this.init = init || null;\n    }\n};\nfunction data(data2, init) {\n    return new DataWithResponseInit(data2, typeof init === \"number\" ? {\n        status: init\n    } : init);\n}\nvar redirect = (url, init = 302)=>{\n    let responseInit = init;\n    if (typeof responseInit === \"number\") {\n        responseInit = {\n            status: responseInit\n        };\n    } else if (typeof responseInit.status === \"undefined\") {\n        responseInit.status = 302;\n    }\n    let headers = new Headers(responseInit.headers);\n    headers.set(\"Location\", url);\n    return new Response(null, {\n        ...responseInit,\n        headers\n    });\n};\nvar redirectDocument = (url, init)=>{\n    let response = redirect(url, init);\n    response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n    return response;\n};\nvar replace = (url, init)=>{\n    let response = redirect(url, init);\n    response.headers.set(\"X-Remix-Replace\", \"true\");\n    return response;\n};\nvar ErrorResponseImpl = class {\n    constructor(status, statusText, data2, internal = false){\n        this.status = status;\n        this.statusText = statusText || \"\";\n        this.internal = internal;\n        if (data2 instanceof Error) {\n            this.data = data2.toString();\n            this.error = data2;\n        } else {\n            this.data = data2;\n        }\n    }\n};\nfunction isRouteErrorResponse(error) {\n    return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\n// lib/router/router.ts\nvar validMutationMethodsArr = [\n    \"POST\",\n    \"PUT\",\n    \"PATCH\",\n    \"DELETE\"\n];\nvar validMutationMethods = new Set(validMutationMethodsArr);\nvar validRequestMethodsArr = [\n    \"GET\",\n    ...validMutationMethodsArr\n];\nvar validRequestMethods = new Set(validRequestMethodsArr);\nvar redirectStatusCodes = /* @__PURE__ */ new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\nvar redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([\n    307,\n    308\n]);\nvar IDLE_NAVIGATION = {\n    state: \"idle\",\n    location: void 0,\n    formMethod: void 0,\n    formAction: void 0,\n    formEncType: void 0,\n    formData: void 0,\n    json: void 0,\n    text: void 0\n};\nvar IDLE_FETCHER = {\n    state: \"idle\",\n    data: void 0,\n    formMethod: void 0,\n    formAction: void 0,\n    formEncType: void 0,\n    formData: void 0,\n    json: void 0,\n    text: void 0\n};\nvar IDLE_BLOCKER = {\n    state: \"unblocked\",\n    proceed: void 0,\n    reset: void 0,\n    location: void 0\n};\nvar ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar defaultMapRouteProperties = (route)=>({\n        hasErrorBoundary: Boolean(route.hasErrorBoundary)\n    });\nvar TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\nvar ResetLoaderDataSymbol = Symbol(\"ResetLoaderData\");\nfunction createRouter(init) {\n    const routerWindow = init.window ? init.window :  false ? 0 : void 0;\n    const isBrowser2 = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n    invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n    let hydrationRouteProperties2 = init.hydrationRouteProperties || [];\n    let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;\n    let manifest = {};\n    let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);\n    let inFlightDataRoutes;\n    let basename = init.basename || \"/\";\n    let dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware;\n    let future = {\n        unstable_middleware: false,\n        ...init.future\n    };\n    let unlistenHistory = null;\n    let subscribers = /* @__PURE__ */ new Set();\n    let savedScrollPositions2 = null;\n    let getScrollRestorationKey2 = null;\n    let getScrollPosition = null;\n    let initialScrollRestored = init.hydrationData != null;\n    let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n    let initialMatchesIsFOW = false;\n    let initialErrors = null;\n    let initialized;\n    if (initialMatches == null && !init.patchRoutesOnNavigation) {\n        let error = getInternalRouterError(404, {\n            pathname: init.history.location.pathname\n        });\n        let { matches, route } = getShortCircuitMatches(dataRoutes);\n        initialized = true;\n        initialMatches = matches;\n        initialErrors = {\n            [route.id]: error\n        };\n    } else {\n        if (initialMatches && !init.hydrationData) {\n            let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname);\n            if (fogOfWar.active) {\n                initialMatches = null;\n            }\n        }\n        if (!initialMatches) {\n            initialized = false;\n            initialMatches = [];\n            let fogOfWar = checkFogOfWar(null, dataRoutes, init.history.location.pathname);\n            if (fogOfWar.active && fogOfWar.matches) {\n                initialMatchesIsFOW = true;\n                initialMatches = fogOfWar.matches;\n            }\n        } else if (initialMatches.some((m)=>m.route.lazy)) {\n            initialized = false;\n        } else if (!initialMatches.some((m)=>m.route.loader)) {\n            initialized = true;\n        } else {\n            let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;\n            let errors = init.hydrationData ? init.hydrationData.errors : null;\n            if (errors) {\n                let idx = initialMatches.findIndex((m)=>errors[m.route.id] !== void 0);\n                initialized = initialMatches.slice(0, idx + 1).every((m)=>!shouldLoadRouteOnHydration(m.route, loaderData, errors));\n            } else {\n                initialized = initialMatches.every((m)=>!shouldLoadRouteOnHydration(m.route, loaderData, errors));\n            }\n        }\n    }\n    let router;\n    let state = {\n        historyAction: init.history.action,\n        location: init.history.location,\n        matches: initialMatches,\n        initialized,\n        navigation: IDLE_NAVIGATION,\n        // Don't restore on initial updateState() if we were SSR'd\n        restoreScrollPosition: init.hydrationData != null ? false : null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n        actionData: init.hydrationData && init.hydrationData.actionData || null,\n        errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n        fetchers: /* @__PURE__ */ new Map(),\n        blockers: /* @__PURE__ */ new Map()\n    };\n    let pendingAction = \"POP\" /* Pop */ ;\n    let pendingPreventScrollReset = false;\n    let pendingNavigationController;\n    let pendingViewTransitionEnabled = false;\n    let appliedViewTransitions = /* @__PURE__ */ new Map();\n    let removePageHideEventListener = null;\n    let isUninterruptedRevalidation = false;\n    let isRevalidationRequired = false;\n    let cancelledFetcherLoads = /* @__PURE__ */ new Set();\n    let fetchControllers = /* @__PURE__ */ new Map();\n    let incrementingLoadId = 0;\n    let pendingNavigationLoadId = -1;\n    let fetchReloadIds = /* @__PURE__ */ new Map();\n    let fetchRedirectIds = /* @__PURE__ */ new Set();\n    let fetchLoadMatches = /* @__PURE__ */ new Map();\n    let activeFetchers = /* @__PURE__ */ new Map();\n    let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();\n    let blockerFunctions = /* @__PURE__ */ new Map();\n    let unblockBlockerHistoryUpdate = void 0;\n    let pendingRevalidationDfd = null;\n    function initialize() {\n        unlistenHistory = init.history.listen(({ action: historyAction, location, delta })=>{\n            if (unblockBlockerHistoryUpdate) {\n                unblockBlockerHistoryUpdate();\n                unblockBlockerHistoryUpdate = void 0;\n                return;\n            }\n            warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.\");\n            let blockerKey = shouldBlockNavigation({\n                currentLocation: state.location,\n                nextLocation: location,\n                historyAction\n            });\n            if (blockerKey && delta != null) {\n                let nextHistoryUpdatePromise = new Promise((resolve)=>{\n                    unblockBlockerHistoryUpdate = resolve;\n                });\n                init.history.go(delta * -1);\n                updateBlocker(blockerKey, {\n                    state: \"blocked\",\n                    location,\n                    proceed () {\n                        updateBlocker(blockerKey, {\n                            state: \"proceeding\",\n                            proceed: void 0,\n                            reset: void 0,\n                            location\n                        });\n                        nextHistoryUpdatePromise.then(()=>init.history.go(delta));\n                    },\n                    reset () {\n                        let blockers = new Map(state.blockers);\n                        blockers.set(blockerKey, IDLE_BLOCKER);\n                        updateState({\n                            blockers\n                        });\n                    }\n                });\n                return;\n            }\n            return startNavigation(historyAction, location);\n        });\n        if (isBrowser2) {\n            restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n            let _saveAppliedTransitions = ()=>persistAppliedTransitions(routerWindow, appliedViewTransitions);\n            routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n            removePageHideEventListener = ()=>routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n        }\n        if (!state.initialized) {\n            startNavigation(\"POP\" /* Pop */ , state.location, {\n                initialHydration: true\n            });\n        }\n        return router;\n    }\n    function dispose() {\n        if (unlistenHistory) {\n            unlistenHistory();\n        }\n        if (removePageHideEventListener) {\n            removePageHideEventListener();\n        }\n        subscribers.clear();\n        pendingNavigationController && pendingNavigationController.abort();\n        state.fetchers.forEach((_, key)=>deleteFetcher(key));\n        state.blockers.forEach((_, key)=>deleteBlocker(key));\n    }\n    function subscribe(fn) {\n        subscribers.add(fn);\n        return ()=>subscribers.delete(fn);\n    }\n    function updateState(newState, opts = {}) {\n        state = {\n            ...state,\n            ...newState\n        };\n        let unmountedFetchers = [];\n        let mountedFetchers = [];\n        state.fetchers.forEach((fetcher, key)=>{\n            if (fetcher.state === \"idle\") {\n                if (fetchersQueuedForDeletion.has(key)) {\n                    unmountedFetchers.push(key);\n                } else {\n                    mountedFetchers.push(key);\n                }\n            }\n        });\n        fetchersQueuedForDeletion.forEach((key)=>{\n            if (!state.fetchers.has(key) && !fetchControllers.has(key)) {\n                unmountedFetchers.push(key);\n            }\n        });\n        [\n            ...subscribers\n        ].forEach((subscriber)=>subscriber(state, {\n                deletedFetchers: unmountedFetchers,\n                viewTransitionOpts: opts.viewTransitionOpts,\n                flushSync: opts.flushSync === true\n            }));\n        unmountedFetchers.forEach((key)=>deleteFetcher(key));\n        mountedFetchers.forEach((key)=>state.fetchers.delete(key));\n    }\n    function completeNavigation(location, newState, { flushSync } = {}) {\n        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && location.state?._isRedirect !== true;\n        let actionData;\n        if (newState.actionData) {\n            if (Object.keys(newState.actionData).length > 0) {\n                actionData = newState.actionData;\n            } else {\n                actionData = null;\n            }\n        } else if (isActionReload) {\n            actionData = state.actionData;\n        } else {\n            actionData = null;\n        }\n        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n        let blockers = state.blockers;\n        if (blockers.size > 0) {\n            blockers = new Map(blockers);\n            blockers.forEach((_, k)=>blockers.set(k, IDLE_BLOCKER));\n        }\n        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && location.state?._isRedirect !== true;\n        if (inFlightDataRoutes) {\n            dataRoutes = inFlightDataRoutes;\n            inFlightDataRoutes = void 0;\n        }\n        if (isUninterruptedRevalidation) {} else if (pendingAction === \"POP\" /* Pop */ ) {} else if (pendingAction === \"PUSH\" /* Push */ ) {\n            init.history.push(location, location.state);\n        } else if (pendingAction === \"REPLACE\" /* Replace */ ) {\n            init.history.replace(location, location.state);\n        }\n        let viewTransitionOpts;\n        if (pendingAction === \"POP\" /* Pop */ ) {\n            let priorPaths = appliedViewTransitions.get(state.location.pathname);\n            if (priorPaths && priorPaths.has(location.pathname)) {\n                viewTransitionOpts = {\n                    currentLocation: state.location,\n                    nextLocation: location\n                };\n            } else if (appliedViewTransitions.has(location.pathname)) {\n                viewTransitionOpts = {\n                    currentLocation: location,\n                    nextLocation: state.location\n                };\n            }\n        } else if (pendingViewTransitionEnabled) {\n            let toPaths = appliedViewTransitions.get(state.location.pathname);\n            if (toPaths) {\n                toPaths.add(location.pathname);\n            } else {\n                toPaths = /* @__PURE__ */ new Set([\n                    location.pathname\n                ]);\n                appliedViewTransitions.set(state.location.pathname, toPaths);\n            }\n            viewTransitionOpts = {\n                currentLocation: state.location,\n                nextLocation: location\n            };\n        }\n        updateState({\n            ...newState,\n            // matches, errors, fetchers go through as-is\n            actionData,\n            loaderData,\n            historyAction: pendingAction,\n            location,\n            initialized: true,\n            navigation: IDLE_NAVIGATION,\n            revalidation: \"idle\",\n            restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n            preventScrollReset,\n            blockers\n        }, {\n            viewTransitionOpts,\n            flushSync: flushSync === true\n        });\n        pendingAction = \"POP\" /* Pop */ ;\n        pendingPreventScrollReset = false;\n        pendingViewTransitionEnabled = false;\n        isUninterruptedRevalidation = false;\n        isRevalidationRequired = false;\n        pendingRevalidationDfd?.resolve();\n        pendingRevalidationDfd = null;\n    }\n    async function navigate(to, opts) {\n        if (typeof to === \"number\") {\n            init.history.go(to);\n            return;\n        }\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, to, opts?.fromRouteId, opts?.relative);\n        let { path, submission, error } = normalizeNavigateOptions(false, normalizedPath, opts);\n        let currentLocation = state.location;\n        let nextLocation = createLocation(state.location, path, opts && opts.state);\n        nextLocation = {\n            ...nextLocation,\n            ...init.history.encodeLocation(nextLocation)\n        };\n        let userReplace = opts && opts.replace != null ? opts.replace : void 0;\n        let historyAction = \"PUSH\" /* Push */ ;\n        if (userReplace === true) {\n            historyAction = \"REPLACE\" /* Replace */ ;\n        } else if (userReplace === false) {} else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n            historyAction = \"REPLACE\" /* Replace */ ;\n        }\n        let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : void 0;\n        let flushSync = (opts && opts.flushSync) === true;\n        let blockerKey = shouldBlockNavigation({\n            currentLocation,\n            nextLocation,\n            historyAction\n        });\n        if (blockerKey) {\n            updateBlocker(blockerKey, {\n                state: \"blocked\",\n                location: nextLocation,\n                proceed () {\n                    updateBlocker(blockerKey, {\n                        state: \"proceeding\",\n                        proceed: void 0,\n                        reset: void 0,\n                        location: nextLocation\n                    });\n                    navigate(to, opts);\n                },\n                reset () {\n                    let blockers = new Map(state.blockers);\n                    blockers.set(blockerKey, IDLE_BLOCKER);\n                    updateState({\n                        blockers\n                    });\n                }\n            });\n            return;\n        }\n        await startNavigation(historyAction, nextLocation, {\n            submission,\n            // Send through the formData serialization error if we have one so we can\n            // render at the right error boundary after we match routes\n            pendingError: error,\n            preventScrollReset,\n            replace: opts && opts.replace,\n            enableViewTransition: opts && opts.viewTransition,\n            flushSync\n        });\n    }\n    function revalidate() {\n        if (!pendingRevalidationDfd) {\n            pendingRevalidationDfd = createDeferred();\n        }\n        interruptActiveLoads();\n        updateState({\n            revalidation: \"loading\"\n        });\n        let promise = pendingRevalidationDfd.promise;\n        if (state.navigation.state === \"submitting\") {\n            return promise;\n        }\n        if (state.navigation.state === \"idle\") {\n            startNavigation(state.historyAction, state.location, {\n                startUninterruptedRevalidation: true\n            });\n            return promise;\n        }\n        startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n            overrideNavigation: state.navigation,\n            // Proxy through any rending view transition\n            enableViewTransition: pendingViewTransitionEnabled === true\n        });\n        return promise;\n    }\n    async function startNavigation(historyAction, location, opts) {\n        pendingNavigationController && pendingNavigationController.abort();\n        pendingNavigationController = null;\n        pendingAction = historyAction;\n        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n        saveScrollPosition(state.location, state.matches);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let loadingNavigation = opts && opts.overrideNavigation;\n        let matches = opts?.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? // `matchRoutes()` has already been called if we're in here via `router.initialize()`\n        state.matches : matchRoutes(routesToUse, location, basename);\n        let flushSync = (opts && opts.flushSync) === true;\n        if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n            completeNavigation(location, {\n                matches\n            }, {\n                flushSync\n            });\n            return;\n        }\n        let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);\n        if (fogOfWar.active && fogOfWar.matches) {\n            matches = fogOfWar.matches;\n        }\n        if (!matches) {\n            let { error, notFoundMatches, route } = handleNavigational404(location.pathname);\n            completeNavigation(location, {\n                matches: notFoundMatches,\n                loaderData: {},\n                errors: {\n                    [route.id]: error\n                }\n            }, {\n                flushSync\n            });\n            return;\n        }\n        pendingNavigationController = new AbortController();\n        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n        let scopedContext = new unstable_RouterContextProvider(init.unstable_getContext ? await init.unstable_getContext() : void 0);\n        let pendingActionResult;\n        if (opts && opts.pendingError) {\n            pendingActionResult = [\n                findNearestBoundary(matches).route.id,\n                {\n                    type: \"error\" /* error */ ,\n                    error: opts.pendingError\n                }\n            ];\n        } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n            let actionResult = await handleAction(request, location, opts.submission, matches, scopedContext, fogOfWar.active, opts && opts.initialHydration === true, {\n                replace: opts.replace,\n                flushSync\n            });\n            if (actionResult.shortCircuited) {\n                return;\n            }\n            if (actionResult.pendingActionResult) {\n                let [routeId, result] = actionResult.pendingActionResult;\n                if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {\n                    pendingNavigationController = null;\n                    completeNavigation(location, {\n                        matches: actionResult.matches,\n                        loaderData: {},\n                        errors: {\n                            [routeId]: result.error\n                        }\n                    });\n                    return;\n                }\n            }\n            matches = actionResult.matches || matches;\n            pendingActionResult = actionResult.pendingActionResult;\n            loadingNavigation = getLoadingNavigation(location, opts.submission);\n            flushSync = false;\n            fogOfWar.active = false;\n            request = createClientSideRequest(init.history, request.url, request.signal);\n        }\n        let { shortCircuited, matches: updatedMatches, loaderData, errors } = await handleLoaders(request, location, matches, scopedContext, fogOfWar.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);\n        if (shortCircuited) {\n            return;\n        }\n        pendingNavigationController = null;\n        completeNavigation(location, {\n            matches: updatedMatches || matches,\n            ...getActionDataForCommit(pendingActionResult),\n            loaderData,\n            errors\n        });\n    }\n    async function handleAction(request, location, submission, matches, scopedContext, isFogOfWar, initialHydration, opts = {}) {\n        interruptActiveLoads();\n        let navigation = getSubmittingNavigation(location, submission);\n        updateState({\n            navigation\n        }, {\n            flushSync: opts.flushSync === true\n        });\n        if (isFogOfWar) {\n            let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);\n            if (discoverResult.type === \"aborted\") {\n                return {\n                    shortCircuited: true\n                };\n            } else if (discoverResult.type === \"error\") {\n                let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n                return {\n                    matches: discoverResult.partialMatches,\n                    pendingActionResult: [\n                        boundaryId,\n                        {\n                            type: \"error\" /* error */ ,\n                            error: discoverResult.error\n                        }\n                    ]\n                };\n            } else if (!discoverResult.matches) {\n                let { notFoundMatches, error, route } = handleNavigational404(location.pathname);\n                return {\n                    matches: notFoundMatches,\n                    pendingActionResult: [\n                        route.id,\n                        {\n                            type: \"error\" /* error */ ,\n                            error\n                        }\n                    ]\n                };\n            } else {\n                matches = discoverResult.matches;\n            }\n        }\n        let result;\n        let actionMatch = getTargetMatch(matches, location);\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            result = {\n                type: \"error\" /* error */ ,\n                error: getInternalRouterError(405, {\n                    method: request.method,\n                    pathname: location.pathname,\n                    routeId: actionMatch.route.id\n                })\n            };\n        } else {\n            let dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, actionMatch, initialHydration ? [] : hydrationRouteProperties2, scopedContext);\n            let results = await callDataStrategy(request, dsMatches, scopedContext, null);\n            result = results[actionMatch.route.id];\n            if (!result) {\n                for (let match of matches){\n                    if (results[match.route.id]) {\n                        result = results[match.route.id];\n                        break;\n                    }\n                }\n            }\n            if (request.signal.aborted) {\n                return {\n                    shortCircuited: true\n                };\n            }\n        }\n        if (isRedirectResult(result)) {\n            let replace2;\n            if (opts && opts.replace != null) {\n                replace2 = opts.replace;\n            } else {\n                let location2 = normalizeRedirectLocation(result.response.headers.get(\"Location\"), new URL(request.url), basename);\n                replace2 = location2 === state.location.pathname + state.location.search;\n            }\n            await startRedirectNavigation(request, result, true, {\n                submission,\n                replace: replace2\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        if (isErrorResult(result)) {\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            if ((opts && opts.replace) !== true) {\n                pendingAction = \"PUSH\" /* Push */ ;\n            }\n            return {\n                matches,\n                pendingActionResult: [\n                    boundaryMatch.route.id,\n                    result,\n                    actionMatch.route.id\n                ]\n            };\n        }\n        return {\n            matches,\n            pendingActionResult: [\n                actionMatch.route.id,\n                result\n            ]\n        };\n    }\n    async function handleLoaders(request, location, matches, scopedContext, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {\n        let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n        let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n        let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;\n        if (isFogOfWar) {\n            if (shouldUpdateNavigationState) {\n                let actionData = getUpdatedActionData(pendingActionResult);\n                updateState({\n                    navigation: loadingNavigation,\n                    ...actionData !== void 0 ? {\n                        actionData\n                    } : {}\n                }, {\n                    flushSync\n                });\n            }\n            let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);\n            if (discoverResult.type === \"aborted\") {\n                return {\n                    shortCircuited: true\n                };\n            } else if (discoverResult.type === \"error\") {\n                let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;\n                return {\n                    matches: discoverResult.partialMatches,\n                    loaderData: {},\n                    errors: {\n                        [boundaryId]: discoverResult.error\n                    }\n                };\n            } else if (!discoverResult.matches) {\n                let { error, notFoundMatches, route } = handleNavigational404(location.pathname);\n                return {\n                    matches: notFoundMatches,\n                    loaderData: {},\n                    errors: {\n                        [route.id]: error\n                    }\n                };\n            } else {\n                matches = discoverResult.matches;\n            }\n        }\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let { dsMatches, revalidatingFetchers } = getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, init.history, state, matches, activeSubmission, location, initialHydration ? [] : hydrationRouteProperties2, initialHydration === true, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, init.patchRoutesOnNavigation != null, pendingActionResult);\n        pendingNavigationLoadId = ++incrementingLoadId;\n        if (!init.dataStrategy && !dsMatches.some((m)=>m.shouldLoad) && revalidatingFetchers.length === 0) {\n            let updatedFetchers2 = markFetchRedirectsDone();\n            completeNavigation(location, {\n                matches,\n                loaderData: {},\n                // Commit pending error if we're short circuiting\n                errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n                    [pendingActionResult[0]]: pendingActionResult[1].error\n                } : null,\n                ...getActionDataForCommit(pendingActionResult),\n                ...updatedFetchers2 ? {\n                    fetchers: new Map(state.fetchers)\n                } : {}\n            }, {\n                flushSync\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        if (shouldUpdateNavigationState) {\n            let updates = {};\n            if (!isFogOfWar) {\n                updates.navigation = loadingNavigation;\n                let actionData = getUpdatedActionData(pendingActionResult);\n                if (actionData !== void 0) {\n                    updates.actionData = actionData;\n                }\n            }\n            if (revalidatingFetchers.length > 0) {\n                updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);\n            }\n            updateState(updates, {\n                flushSync\n            });\n        }\n        revalidatingFetchers.forEach((rf)=>{\n            abortFetcher(rf.key);\n            if (rf.controller) {\n                fetchControllers.set(rf.key, rf.controller);\n            }\n        });\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((f)=>abortFetcher(f.key));\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(dsMatches, revalidatingFetchers, request, scopedContext);\n        if (request.signal.aborted) {\n            return {\n                shortCircuited: true\n            };\n        }\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        revalidatingFetchers.forEach((rf)=>fetchControllers.delete(rf.key));\n        let redirect2 = findRedirect(loaderResults);\n        if (redirect2) {\n            await startRedirectNavigation(request, redirect2.result, true, {\n                replace: replace2\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        redirect2 = findRedirect(fetcherResults);\n        if (redirect2) {\n            fetchRedirectIds.add(redirect2.key);\n            await startRedirectNavigation(request, redirect2.result, true, {\n                replace: replace2\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        let { loaderData, errors } = processLoaderData(state, matches, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults);\n        if (initialHydration && state.errors) {\n            errors = {\n                ...state.errors,\n                ...errors\n            };\n        }\n        let updatedFetchers = markFetchRedirectsDone();\n        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n        return {\n            matches,\n            loaderData,\n            errors,\n            ...shouldUpdateFetchers ? {\n                fetchers: new Map(state.fetchers)\n            } : {}\n        };\n    }\n    function getUpdatedActionData(pendingActionResult) {\n        if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {\n            return {\n                [pendingActionResult[0]]: pendingActionResult[1].data\n            };\n        } else if (state.actionData) {\n            if (Object.keys(state.actionData).length === 0) {\n                return null;\n            } else {\n                return state.actionData;\n            }\n        }\n    }\n    function getUpdatedRevalidatingFetchers(revalidatingFetchers) {\n        revalidatingFetchers.forEach((rf)=>{\n            let fetcher = state.fetchers.get(rf.key);\n            let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);\n            state.fetchers.set(rf.key, revalidatingFetcher);\n        });\n        return new Map(state.fetchers);\n    }\n    async function fetch2(key, routeId, href2, opts) {\n        abortFetcher(key);\n        let flushSync = (opts && opts.flushSync) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, href2, routeId, opts?.relative);\n        let matches = matchRoutes(routesToUse, normalizedPath, basename);\n        let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);\n        if (fogOfWar.active && fogOfWar.matches) {\n            matches = fogOfWar.matches;\n        }\n        if (!matches) {\n            setFetcherError(key, routeId, getInternalRouterError(404, {\n                pathname: normalizedPath\n            }), {\n                flushSync\n            });\n            return;\n        }\n        let { path, submission, error } = normalizeNavigateOptions(true, normalizedPath, opts);\n        if (error) {\n            setFetcherError(key, routeId, error, {\n                flushSync\n            });\n            return;\n        }\n        let match = getTargetMatch(matches, path);\n        let scopedContext = new unstable_RouterContextProvider(init.unstable_getContext ? await init.unstable_getContext() : void 0);\n        let preventScrollReset = (opts && opts.preventScrollReset) === true;\n        if (submission && isMutationMethod(submission.formMethod)) {\n            await handleFetcherAction(key, routeId, path, match, matches, scopedContext, fogOfWar.active, flushSync, preventScrollReset, submission);\n            return;\n        }\n        fetchLoadMatches.set(key, {\n            routeId,\n            path\n        });\n        await handleFetcherLoader(key, routeId, path, match, matches, scopedContext, fogOfWar.active, flushSync, preventScrollReset, submission);\n    }\n    async function handleFetcherAction(key, routeId, path, match, requestMatches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {\n        interruptActiveLoads();\n        fetchLoadMatches.delete(key);\n        function detectAndHandle405Error(m) {\n            if (!m.route.action && !m.route.lazy) {\n                let error = getInternalRouterError(405, {\n                    method: submission.formMethod,\n                    pathname: path,\n                    routeId\n                });\n                setFetcherError(key, routeId, error, {\n                    flushSync\n                });\n                return true;\n            }\n            return false;\n        }\n        if (!isFogOfWar && detectAndHandle405Error(match)) {\n            return;\n        }\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n            flushSync\n        });\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n        if (isFogOfWar) {\n            let discoverResult = await discoverRoutes(requestMatches, path, fetchRequest.signal, key);\n            if (discoverResult.type === \"aborted\") {\n                return;\n            } else if (discoverResult.type === \"error\") {\n                setFetcherError(key, routeId, discoverResult.error, {\n                    flushSync\n                });\n                return;\n            } else if (!discoverResult.matches) {\n                setFetcherError(key, routeId, getInternalRouterError(404, {\n                    pathname: path\n                }), {\n                    flushSync\n                });\n                return;\n            } else {\n                requestMatches = discoverResult.matches;\n                match = getTargetMatch(requestMatches, path);\n                if (detectAndHandle405Error(match)) {\n                    return;\n                }\n            }\n        }\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let fetchMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, requestMatches, match, hydrationRouteProperties2, scopedContext);\n        let actionResults = await callDataStrategy(fetchRequest, fetchMatches, scopedContext, key);\n        let actionResult = actionResults[match.route.id];\n        if (fetchRequest.signal.aborted) {\n            if (fetchControllers.get(key) === abortController) {\n                fetchControllers.delete(key);\n            }\n            return;\n        }\n        if (fetchersQueuedForDeletion.has(key)) {\n            if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {\n                updateFetcherState(key, getDoneFetcher(void 0));\n                return;\n            }\n        } else {\n            if (isRedirectResult(actionResult)) {\n                fetchControllers.delete(key);\n                if (pendingNavigationLoadId > originatingLoadId) {\n                    updateFetcherState(key, getDoneFetcher(void 0));\n                    return;\n                } else {\n                    fetchRedirectIds.add(key);\n                    updateFetcherState(key, getLoadingFetcher(submission));\n                    return startRedirectNavigation(fetchRequest, actionResult, false, {\n                        fetcherSubmission: submission,\n                        preventScrollReset\n                    });\n                }\n            }\n            if (isErrorResult(actionResult)) {\n                setFetcherError(key, routeId, actionResult.error);\n                return;\n            }\n        }\n        let nextLocation = state.navigation.location || state.location;\n        let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n        invariant(matches, \"Didn't find any matches after fetcher action\");\n        let loadId = ++incrementingLoadId;\n        fetchReloadIds.set(key, loadId);\n        let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n        state.fetchers.set(key, loadFetcher);\n        let { dsMatches, revalidatingFetchers } = getMatchesToLoad(revalidationRequest, scopedContext, mapRouteProperties2, manifest, init.history, state, matches, submission, nextLocation, hydrationRouteProperties2, false, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, init.patchRoutesOnNavigation != null, [\n            match.route.id,\n            actionResult\n        ]);\n        revalidatingFetchers.filter((rf)=>rf.key !== key).forEach((rf)=>{\n            let staleKey = rf.key;\n            let existingFetcher2 = state.fetchers.get(staleKey);\n            let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);\n            state.fetchers.set(staleKey, revalidatingFetcher);\n            abortFetcher(staleKey);\n            if (rf.controller) {\n                fetchControllers.set(staleKey, rf.controller);\n            }\n        });\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((rf)=>abortFetcher(rf.key));\n        abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(dsMatches, revalidatingFetchers, revalidationRequest, scopedContext);\n        if (abortController.signal.aborted) {\n            return;\n        }\n        abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        fetchReloadIds.delete(key);\n        fetchControllers.delete(key);\n        revalidatingFetchers.forEach((r)=>fetchControllers.delete(r.key));\n        if (state.fetchers.has(key)) {\n            let doneFetcher = getDoneFetcher(actionResult.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n        let redirect2 = findRedirect(loaderResults);\n        if (redirect2) {\n            return startRedirectNavigation(revalidationRequest, redirect2.result, false, {\n                preventScrollReset\n            });\n        }\n        redirect2 = findRedirect(fetcherResults);\n        if (redirect2) {\n            fetchRedirectIds.add(redirect2.key);\n            return startRedirectNavigation(revalidationRequest, redirect2.result, false, {\n                preventScrollReset\n            });\n        }\n        let { loaderData, errors } = processLoaderData(state, matches, loaderResults, void 0, revalidatingFetchers, fetcherResults);\n        abortStaleFetchLoads(loadId);\n        if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n            invariant(pendingAction, \"Expected pending action\");\n            pendingNavigationController && pendingNavigationController.abort();\n            completeNavigation(state.navigation.location, {\n                matches,\n                loaderData,\n                errors,\n                fetchers: new Map(state.fetchers)\n            });\n        } else {\n            updateState({\n                errors,\n                loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n                fetchers: new Map(state.fetchers)\n            });\n            isRevalidationRequired = false;\n        }\n    }\n    async function handleFetcherLoader(key, routeId, path, match, matches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {\n            flushSync\n        });\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n        if (isFogOfWar) {\n            let discoverResult = await discoverRoutes(matches, path, fetchRequest.signal, key);\n            if (discoverResult.type === \"aborted\") {\n                return;\n            } else if (discoverResult.type === \"error\") {\n                setFetcherError(key, routeId, discoverResult.error, {\n                    flushSync\n                });\n                return;\n            } else if (!discoverResult.matches) {\n                setFetcherError(key, routeId, getInternalRouterError(404, {\n                    pathname: path\n                }), {\n                    flushSync\n                });\n                return;\n            } else {\n                matches = discoverResult.matches;\n                match = getTargetMatch(matches, path);\n            }\n        }\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, matches, match, hydrationRouteProperties2, scopedContext);\n        let results = await callDataStrategy(fetchRequest, dsMatches, scopedContext, key);\n        let result = results[match.route.id];\n        if (fetchControllers.get(key) === abortController) {\n            fetchControllers.delete(key);\n        }\n        if (fetchRequest.signal.aborted) {\n            return;\n        }\n        if (fetchersQueuedForDeletion.has(key)) {\n            updateFetcherState(key, getDoneFetcher(void 0));\n            return;\n        }\n        if (isRedirectResult(result)) {\n            if (pendingNavigationLoadId > originatingLoadId) {\n                updateFetcherState(key, getDoneFetcher(void 0));\n                return;\n            } else {\n                fetchRedirectIds.add(key);\n                await startRedirectNavigation(fetchRequest, result, false, {\n                    preventScrollReset\n                });\n                return;\n            }\n        }\n        if (isErrorResult(result)) {\n            setFetcherError(key, routeId, result.error);\n            return;\n        }\n        updateFetcherState(key, getDoneFetcher(result.data));\n    }\n    async function startRedirectNavigation(request, redirect2, isNavigation, { submission, fetcherSubmission, preventScrollReset, replace: replace2 } = {}) {\n        if (redirect2.response.headers.has(\"X-Remix-Revalidate\")) {\n            isRevalidationRequired = true;\n        }\n        let location = redirect2.response.headers.get(\"Location\");\n        invariant(location, \"Expected a Location header on the redirect Response\");\n        location = normalizeRedirectLocation(location, new URL(request.url), basename);\n        let redirectLocation = createLocation(state.location, location, {\n            _isRedirect: true\n        });\n        if (isBrowser2) {\n            let isDocumentReload = false;\n            if (redirect2.response.headers.has(\"X-Remix-Reload-Document\")) {\n                isDocumentReload = true;\n            } else if (ABSOLUTE_URL_REGEX.test(location)) {\n                const url = createBrowserURLImpl(location, true);\n                isDocumentReload = url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n                stripBasename(url.pathname, basename) == null;\n            }\n            if (isDocumentReload) {\n                if (replace2) {\n                    routerWindow.location.replace(location);\n                } else {\n                    routerWindow.location.assign(location);\n                }\n                return;\n            }\n        }\n        pendingNavigationController = null;\n        let redirectNavigationType = replace2 === true || redirect2.response.headers.has(\"X-Remix-Replace\") ? \"REPLACE\" /* Replace */  : \"PUSH\" /* Push */ ;\n        let { formMethod, formAction, formEncType } = state.navigation;\n        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n            submission = getSubmissionFromNavigation(state.navigation);\n        }\n        let activeSubmission = submission || fetcherSubmission;\n        if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n            await startNavigation(redirectNavigationType, redirectLocation, {\n                submission: {\n                    ...activeSubmission,\n                    formAction: location\n                },\n                // Preserve these flags across redirects\n                preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n                enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0\n            });\n        } else {\n            let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n            await startNavigation(redirectNavigationType, redirectLocation, {\n                overrideNavigation,\n                // Send fetcher submissions through for shouldRevalidate\n                fetcherSubmission,\n                // Preserve these flags across redirects\n                preventScrollReset: preventScrollReset || pendingPreventScrollReset,\n                enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0\n            });\n        }\n    }\n    async function callDataStrategy(request, matches, scopedContext, fetcherKey) {\n        let results;\n        let dataResults = {};\n        try {\n            results = await callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, false);\n        } catch (e) {\n            matches.filter((m)=>m.shouldLoad).forEach((m)=>{\n                dataResults[m.route.id] = {\n                    type: \"error\" /* error */ ,\n                    error: e\n                };\n            });\n            return dataResults;\n        }\n        if (request.signal.aborted) {\n            return dataResults;\n        }\n        for (let [routeId, result] of Object.entries(results)){\n            if (isRedirectDataStrategyResult(result)) {\n                let response = result.result;\n                dataResults[routeId] = {\n                    type: \"redirect\" /* redirect */ ,\n                    response: normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename)\n                };\n            } else {\n                dataResults[routeId] = await convertDataStrategyResultToDataResult(result);\n            }\n        }\n        return dataResults;\n    }\n    async function callLoadersAndMaybeResolveData(matches, fetchersToLoad, request, scopedContext) {\n        let loaderResultsPromise = callDataStrategy(request, matches, scopedContext, null);\n        let fetcherResultsPromise = Promise.all(fetchersToLoad.map(async (f)=>{\n            if (f.matches && f.match && f.request && f.controller) {\n                let results = await callDataStrategy(f.request, f.matches, scopedContext, f.key);\n                let result = results[f.match.route.id];\n                return {\n                    [f.key]: result\n                };\n            } else {\n                return Promise.resolve({\n                    [f.key]: {\n                        type: \"error\" /* error */ ,\n                        error: getInternalRouterError(404, {\n                            pathname: f.path\n                        })\n                    }\n                });\n            }\n        }));\n        let loaderResults = await loaderResultsPromise;\n        let fetcherResults = (await fetcherResultsPromise).reduce((acc, r)=>Object.assign(acc, r), {});\n        return {\n            loaderResults,\n            fetcherResults\n        };\n    }\n    function interruptActiveLoads() {\n        isRevalidationRequired = true;\n        fetchLoadMatches.forEach((_, key)=>{\n            if (fetchControllers.has(key)) {\n                cancelledFetcherLoads.add(key);\n            }\n            abortFetcher(key);\n        });\n    }\n    function updateFetcherState(key, fetcher, opts = {}) {\n        state.fetchers.set(key, fetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function setFetcherError(key, routeId, error, opts = {}) {\n        let boundaryMatch = findNearestBoundary(state.matches, routeId);\n        deleteFetcher(key);\n        updateState({\n            errors: {\n                [boundaryMatch.route.id]: error\n            },\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function getFetcher(key) {\n        activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n        if (fetchersQueuedForDeletion.has(key)) {\n            fetchersQueuedForDeletion.delete(key);\n        }\n        return state.fetchers.get(key) || IDLE_FETCHER;\n    }\n    function deleteFetcher(key) {\n        let fetcher = state.fetchers.get(key);\n        if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n            abortFetcher(key);\n        }\n        fetchLoadMatches.delete(key);\n        fetchReloadIds.delete(key);\n        fetchRedirectIds.delete(key);\n        fetchersQueuedForDeletion.delete(key);\n        cancelledFetcherLoads.delete(key);\n        state.fetchers.delete(key);\n    }\n    function queueFetcherForDeletion(key) {\n        let count = (activeFetchers.get(key) || 0) - 1;\n        if (count <= 0) {\n            activeFetchers.delete(key);\n            fetchersQueuedForDeletion.add(key);\n        } else {\n            activeFetchers.set(key, count);\n        }\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    function abortFetcher(key) {\n        let controller = fetchControllers.get(key);\n        if (controller) {\n            controller.abort();\n            fetchControllers.delete(key);\n        }\n    }\n    function markFetchersDone(keys) {\n        for (let key of keys){\n            let fetcher = getFetcher(key);\n            let doneFetcher = getDoneFetcher(fetcher.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    function markFetchRedirectsDone() {\n        let doneKeys = [];\n        let updatedFetchers = false;\n        for (let key of fetchRedirectIds){\n            let fetcher = state.fetchers.get(key);\n            invariant(fetcher, `Expected fetcher: ${key}`);\n            if (fetcher.state === \"loading\") {\n                fetchRedirectIds.delete(key);\n                doneKeys.push(key);\n                updatedFetchers = true;\n            }\n        }\n        markFetchersDone(doneKeys);\n        return updatedFetchers;\n    }\n    function abortStaleFetchLoads(landedId) {\n        let yeetedKeys = [];\n        for (let [key, id] of fetchReloadIds){\n            if (id < landedId) {\n                let fetcher = state.fetchers.get(key);\n                invariant(fetcher, `Expected fetcher: ${key}`);\n                if (fetcher.state === \"loading\") {\n                    abortFetcher(key);\n                    fetchReloadIds.delete(key);\n                    yeetedKeys.push(key);\n                }\n            }\n        }\n        markFetchersDone(yeetedKeys);\n        return yeetedKeys.length > 0;\n    }\n    function getBlocker(key, fn) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        if (blockerFunctions.get(key) !== fn) {\n            blockerFunctions.set(key, fn);\n        }\n        return blocker;\n    }\n    function deleteBlocker(key) {\n        state.blockers.delete(key);\n        blockerFunctions.delete(key);\n    }\n    function updateBlocker(key, newBlocker) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`);\n        let blockers = new Map(state.blockers);\n        blockers.set(key, newBlocker);\n        updateState({\n            blockers\n        });\n    }\n    function shouldBlockNavigation({ currentLocation, nextLocation, historyAction }) {\n        if (blockerFunctions.size === 0) {\n            return;\n        }\n        if (blockerFunctions.size > 1) {\n            warning(false, \"A router only supports one blocker at a time\");\n        }\n        let entries = Array.from(blockerFunctions.entries());\n        let [blockerKey, blockerFunction] = entries[entries.length - 1];\n        let blocker = state.blockers.get(blockerKey);\n        if (blocker && blocker.state === \"proceeding\") {\n            return;\n        }\n        if (blockerFunction({\n            currentLocation,\n            nextLocation,\n            historyAction\n        })) {\n            return blockerKey;\n        }\n    }\n    function handleNavigational404(pathname) {\n        let error = getInternalRouterError(404, {\n            pathname\n        });\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let { matches, route } = getShortCircuitMatches(routesToUse);\n        return {\n            notFoundMatches: matches,\n            route,\n            error\n        };\n    }\n    function enableScrollRestoration(positions, getPosition, getKey) {\n        savedScrollPositions2 = positions;\n        getScrollPosition = getPosition;\n        getScrollRestorationKey2 = getKey || null;\n        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n            initialScrollRestored = true;\n            let y = getSavedScrollPosition(state.location, state.matches);\n            if (y != null) {\n                updateState({\n                    restoreScrollPosition: y\n                });\n            }\n        }\n        return ()=>{\n            savedScrollPositions2 = null;\n            getScrollPosition = null;\n            getScrollRestorationKey2 = null;\n        };\n    }\n    function getScrollKey(location, matches) {\n        if (getScrollRestorationKey2) {\n            let key = getScrollRestorationKey2(location, matches.map((m)=>convertRouteMatchToUiMatch(m, state.loaderData)));\n            return key || location.key;\n        }\n        return location.key;\n    }\n    function saveScrollPosition(location, matches) {\n        if (savedScrollPositions2 && getScrollPosition) {\n            let key = getScrollKey(location, matches);\n            savedScrollPositions2[key] = getScrollPosition();\n        }\n    }\n    function getSavedScrollPosition(location, matches) {\n        if (savedScrollPositions2) {\n            let key = getScrollKey(location, matches);\n            let y = savedScrollPositions2[key];\n            if (typeof y === \"number\") {\n                return y;\n            }\n        }\n        return null;\n    }\n    function checkFogOfWar(matches, routesToUse, pathname) {\n        if (init.patchRoutesOnNavigation) {\n            if (!matches) {\n                let fogMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\n                return {\n                    active: true,\n                    matches: fogMatches || []\n                };\n            } else {\n                if (Object.keys(matches[0].params).length > 0) {\n                    let partialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\n                    return {\n                        active: true,\n                        matches: partialMatches\n                    };\n                }\n            }\n        }\n        return {\n            active: false,\n            matches: null\n        };\n    }\n    async function discoverRoutes(matches, pathname, signal, fetcherKey) {\n        if (!init.patchRoutesOnNavigation) {\n            return {\n                type: \"success\",\n                matches\n            };\n        }\n        let partialMatches = matches;\n        while(true){\n            let isNonHMR = inFlightDataRoutes == null;\n            let routesToUse = inFlightDataRoutes || dataRoutes;\n            let localManifest = manifest;\n            try {\n                await init.patchRoutesOnNavigation({\n                    signal,\n                    path: pathname,\n                    matches: partialMatches,\n                    fetcherKey,\n                    patch: (routeId, children)=>{\n                        if (signal.aborted) return;\n                        patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties2);\n                    }\n                });\n            } catch (e) {\n                return {\n                    type: \"error\",\n                    error: e,\n                    partialMatches\n                };\n            } finally{\n                if (isNonHMR && !signal.aborted) {\n                    dataRoutes = [\n                        ...dataRoutes\n                    ];\n                }\n            }\n            if (signal.aborted) {\n                return {\n                    type: \"aborted\"\n                };\n            }\n            let newMatches = matchRoutes(routesToUse, pathname, basename);\n            if (newMatches) {\n                return {\n                    type: \"success\",\n                    matches: newMatches\n                };\n            }\n            let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);\n            if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every((m, i)=>m.route.id === newPartialMatches[i].route.id)) {\n                return {\n                    type: \"success\",\n                    matches: null\n                };\n            }\n            partialMatches = newPartialMatches;\n        }\n    }\n    function _internalSetRoutes(newRoutes) {\n        manifest = {};\n        inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);\n    }\n    function patchRoutes(routeId, children) {\n        let isNonHMR = inFlightDataRoutes == null;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2);\n        if (isNonHMR) {\n            dataRoutes = [\n                ...dataRoutes\n            ];\n            updateState({});\n        }\n    }\n    router = {\n        get basename () {\n            return basename;\n        },\n        get future () {\n            return future;\n        },\n        get state () {\n            return state;\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        get window () {\n            return routerWindow;\n        },\n        initialize,\n        subscribe,\n        enableScrollRestoration,\n        navigate,\n        fetch: fetch2,\n        revalidate,\n        // Passthrough to history-aware createHref used by useHref so we get proper\n        // hash-aware URLs in DOM paths\n        createHref: (to)=>init.history.createHref(to),\n        encodeLocation: (to)=>init.history.encodeLocation(to),\n        getFetcher,\n        deleteFetcher: queueFetcherForDeletion,\n        dispose,\n        getBlocker,\n        deleteBlocker,\n        patchRoutes,\n        _internalFetchControllers: fetchControllers,\n        // TODO: Remove setRoutes, it's temporary to avoid dealing with\n        // updating the tree while validating the update algorithm.\n        _internalSetRoutes\n    };\n    return router;\n}\nfunction createStaticHandler(routes, opts) {\n    invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n    let manifest = {};\n    let basename = (opts ? opts.basename : null) || \"/\";\n    let mapRouteProperties2 = opts?.mapRouteProperties || defaultMapRouteProperties;\n    let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties2, void 0, manifest);\n    async function query(request, { requestContext, filterMatchesToLoad, skipLoaderErrorBubbling, skipRevalidation, dataStrategy, unstable_respond: respond } = {}) {\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();\n        if (!isValidMethod(method) && method !== \"HEAD\") {\n            let error = getInternalRouterError(405, {\n                method\n            });\n            let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);\n            let staticContext = {\n                basename,\n                location,\n                matches: methodNotAllowedMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {}\n            };\n            return respond ? respond(staticContext) : staticContext;\n        } else if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);\n            let staticContext = {\n                basename,\n                location,\n                matches: notFoundMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {}\n            };\n            return respond ? respond(staticContext) : staticContext;\n        }\n        if (respond && matches.some((m)=>m.route.unstable_middleware || typeof m.route.lazy === \"object\" && m.route.lazy.unstable_middleware)) {\n            invariant(requestContext instanceof unstable_RouterContextProvider, \"When using middleware in `staticHandler.query()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`\");\n            try {\n                await loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2);\n                let renderedStaticContext;\n                let response = await runMiddlewarePipeline({\n                    request,\n                    matches,\n                    params: matches[0].params,\n                    // If we're calling middleware then it must be enabled so we can cast\n                    // this to the proper type knowing it's not an `AppLoadContext`\n                    context: requestContext\n                }, true, async ()=>{\n                    let result2 = await queryImpl(request, location, matches, requestContext, dataStrategy || null, skipLoaderErrorBubbling === true, null, filterMatchesToLoad || null, skipRevalidation === true);\n                    if (isResponse(result2)) {\n                        return result2;\n                    }\n                    renderedStaticContext = {\n                        location,\n                        basename,\n                        ...result2\n                    };\n                    let res = await respond(renderedStaticContext);\n                    return res;\n                }, async (error, routeId)=>{\n                    if (isResponse(error)) {\n                        return error;\n                    }\n                    if (renderedStaticContext) {\n                        if (routeId in renderedStaticContext.loaderData) {\n                            renderedStaticContext.loaderData[routeId] = void 0;\n                        }\n                        return respond(getStaticContextFromError(dataRoutes, renderedStaticContext, error, skipLoaderErrorBubbling ? routeId : findNearestBoundary(matches, routeId).route.id));\n                    } else {\n                        let boundaryRouteId = skipLoaderErrorBubbling ? routeId : findNearestBoundary(matches, matches.find((m)=>m.route.id === routeId || m.route.loader)?.route.id || routeId).route.id;\n                        return respond({\n                            matches,\n                            location,\n                            basename,\n                            loaderData: {},\n                            actionData: null,\n                            errors: {\n                                [boundaryRouteId]: error\n                            },\n                            statusCode: isRouteErrorResponse(error) ? error.status : 500,\n                            actionHeaders: {},\n                            loaderHeaders: {}\n                        });\n                    }\n                });\n                invariant(isResponse(response), \"Expected a response in query()\");\n                return response;\n            } catch (e) {\n                if (isResponse(e)) {\n                    return e;\n                }\n                throw e;\n            }\n        }\n        let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, skipLoaderErrorBubbling === true, null, filterMatchesToLoad || null, skipRevalidation === true);\n        if (isResponse(result)) {\n            return result;\n        }\n        return {\n            location,\n            basename,\n            ...result\n        };\n    }\n    async function queryRoute(request, { routeId, requestContext, dataStrategy, unstable_respond: respond } = {}) {\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();\n        if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n            throw getInternalRouterError(405, {\n                method\n            });\n        } else if (!matches) {\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let match = routeId ? matches.find((m)=>m.route.id === routeId) : getTargetMatch(matches, location);\n        if (routeId && !match) {\n            throw getInternalRouterError(403, {\n                pathname: location.pathname,\n                routeId\n            });\n        } else if (!match) {\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        if (respond && matches.some((m)=>m.route.unstable_middleware || typeof m.route.lazy === \"object\" && m.route.lazy.unstable_middleware)) {\n            invariant(requestContext instanceof unstable_RouterContextProvider, \"When using middleware in `staticHandler.queryRoute()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`\");\n            await loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2);\n            let response = await runMiddlewarePipeline({\n                request,\n                matches,\n                params: matches[0].params,\n                // If we're calling middleware then it must be enabled so we can cast\n                // this to the proper type knowing it's not an `AppLoadContext`\n                context: requestContext\n            }, true, async ()=>{\n                let result2 = await queryImpl(request, location, matches, requestContext, dataStrategy || null, false, match, null, false);\n                if (isResponse(result2)) {\n                    return respond(result2);\n                }\n                let error2 = result2.errors ? Object.values(result2.errors)[0] : void 0;\n                if (error2 !== void 0) {\n                    throw error2;\n                }\n                let value = result2.actionData ? Object.values(result2.actionData)[0] : Object.values(result2.loaderData)[0];\n                return typeof value === \"string\" ? new Response(value) : Response.json(value);\n            }, (error2)=>{\n                if (isResponse(error2)) {\n                    return respond(error2);\n                }\n                return new Response(String(error2), {\n                    status: 500,\n                    statusText: \"Unexpected Server Error\"\n                });\n            });\n            return response;\n        }\n        let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, false, match, null, false);\n        if (isResponse(result)) {\n            return result;\n        }\n        let error = result.errors ? Object.values(result.errors)[0] : void 0;\n        if (error !== void 0) {\n            throw error;\n        }\n        if (result.actionData) {\n            return Object.values(result.actionData)[0];\n        }\n        if (result.loaderData) {\n            return Object.values(result.loaderData)[0];\n        }\n        return void 0;\n    }\n    async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, skipRevalidation) {\n        invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n        try {\n            if (isMutationMethod(request.method)) {\n                let result2 = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch != null, filterMatchesToLoad, skipRevalidation);\n                return result2;\n            }\n            let result = await loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad);\n            return isResponse(result) ? result : {\n                ...result,\n                actionData: null,\n                actionHeaders: {}\n            };\n        } catch (e) {\n            if (isDataStrategyResult(e) && isResponse(e.result)) {\n                if (e.type === \"error\" /* error */ ) {\n                    throw e.result;\n                }\n                return e.result;\n            }\n            if (isRedirectResponse(e)) {\n                return e;\n            }\n            throw e;\n        }\n    }\n    async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest, filterMatchesToLoad, skipRevalidation) {\n        let result;\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: actionMatch.route.id\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: \"error\" /* error */ ,\n                error\n            };\n        } else {\n            let dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, actionMatch, [], requestContext);\n            let results = await callDataStrategy(request, dsMatches, isRouteRequest, requestContext, dataStrategy);\n            result = results[actionMatch.route.id];\n            if (request.signal.aborted) {\n                throwStaticHandlerAbortedError(request, isRouteRequest);\n            }\n        }\n        if (isRedirectResult(result)) {\n            throw new Response(null, {\n                status: result.response.status,\n                headers: {\n                    Location: result.response.headers.get(\"Location\")\n                }\n            });\n        }\n        if (isRouteRequest) {\n            if (isErrorResult(result)) {\n                throw result.error;\n            }\n            return {\n                matches: [\n                    actionMatch\n                ],\n                loaderData: {},\n                actionData: {\n                    [actionMatch.route.id]: result.data\n                },\n                errors: null,\n                // Note: statusCode + headers are unused here since queryRoute will\n                // return the raw Response or value\n                statusCode: 200,\n                loaderHeaders: {},\n                actionHeaders: {}\n            };\n        }\n        if (skipRevalidation) {\n            if (isErrorResult(result)) {\n                let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n                return {\n                    statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n                    actionData: null,\n                    actionHeaders: {\n                        ...result.headers ? {\n                            [actionMatch.route.id]: result.headers\n                        } : {}\n                    },\n                    matches,\n                    loaderData: {},\n                    errors: {\n                        [boundaryMatch.route.id]: result.error\n                    },\n                    loaderHeaders: {}\n                };\n            } else {\n                return {\n                    actionData: {\n                        [actionMatch.route.id]: result.data\n                    },\n                    actionHeaders: result.headers ? {\n                        [actionMatch.route.id]: result.headers\n                    } : {},\n                    matches,\n                    loaderData: {},\n                    errors: null,\n                    statusCode: result.statusCode || 200,\n                    loaderHeaders: {}\n                };\n            }\n        }\n        let loaderRequest = new Request(request.url, {\n            headers: request.headers,\n            redirect: request.redirect,\n            signal: request.signal\n        });\n        if (isErrorResult(result)) {\n            let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);\n            let handlerContext2 = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, filterMatchesToLoad, [\n                boundaryMatch.route.id,\n                result\n            ]);\n            return {\n                ...handlerContext2,\n                statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,\n                actionData: null,\n                actionHeaders: {\n                    ...result.headers ? {\n                        [actionMatch.route.id]: result.headers\n                    } : {}\n                }\n            };\n        }\n        let handlerContext = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, filterMatchesToLoad);\n        return {\n            ...handlerContext,\n            actionData: {\n                [actionMatch.route.id]: result.data\n            },\n            // action status codes take precedence over loader status codes\n            ...result.statusCode ? {\n                statusCode: result.statusCode\n            } : {},\n            actionHeaders: result.headers ? {\n                [actionMatch.route.id]: result.headers\n            } : {}\n        };\n    }\n    async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, pendingActionResult) {\n        let isRouteRequest = routeMatch != null;\n        if (isRouteRequest && !routeMatch?.route.loader && !routeMatch?.route.lazy) {\n            throw getInternalRouterError(400, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: routeMatch?.route.id\n            });\n        }\n        let dsMatches;\n        if (routeMatch) {\n            dsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, routeMatch, [], requestContext);\n        } else {\n            let maxIdx = pendingActionResult && isErrorResult(pendingActionResult[1]) ? // Up to but not including the boundary\n            matches.findIndex((m)=>m.route.id === pendingActionResult[0]) - 1 : void 0;\n            dsMatches = matches.map((match, index)=>{\n                if (maxIdx != null && index > maxIdx) {\n                    return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, [], requestContext, false);\n                }\n                return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, [], requestContext, (match.route.loader || match.route.lazy) != null && (!filterMatchesToLoad || filterMatchesToLoad(match)));\n            });\n        }\n        if (!dataStrategy && !dsMatches.some((m)=>m.shouldLoad)) {\n            return {\n                matches,\n                loaderData: {},\n                errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {\n                    [pendingActionResult[0]]: pendingActionResult[1].error\n                } : null,\n                statusCode: 200,\n                loaderHeaders: {}\n            };\n        }\n        let results = await callDataStrategy(request, dsMatches, isRouteRequest, requestContext, dataStrategy);\n        if (request.signal.aborted) {\n            throwStaticHandlerAbortedError(request, isRouteRequest);\n        }\n        let handlerContext = processRouteLoaderData(matches, results, pendingActionResult, true, skipLoaderErrorBubbling);\n        return {\n            ...handlerContext,\n            matches\n        };\n    }\n    async function callDataStrategy(request, matches, isRouteRequest, requestContext, dataStrategy) {\n        let results = await callDataStrategyImpl(dataStrategy || defaultDataStrategy, request, matches, null, requestContext, true);\n        let dataResults = {};\n        await Promise.all(matches.map(async (match)=>{\n            if (!(match.route.id in results)) {\n                return;\n            }\n            let result = results[match.route.id];\n            if (isRedirectDataStrategyResult(result)) {\n                let response = result.result;\n                throw normalizeRelativeRoutingRedirectResponse(response, request, match.route.id, matches, basename);\n            }\n            if (isResponse(result.result) && isRouteRequest) {\n                throw result;\n            }\n            dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);\n        }));\n        return dataResults;\n    }\n    return {\n        dataRoutes,\n        query,\n        queryRoute\n    };\n}\nfunction getStaticContextFromError(routes, handlerContext, error, boundaryId) {\n    let errorBoundaryId = boundaryId || handlerContext._deepestRenderedBoundaryId || routes[0].id;\n    return {\n        ...handlerContext,\n        statusCode: isRouteErrorResponse(error) ? error.status : 500,\n        errors: {\n            [errorBoundaryId]: error\n        }\n    };\n}\nfunction throwStaticHandlerAbortedError(request, isRouteRequest) {\n    if (request.signal.reason !== void 0) {\n        throw request.signal.reason;\n    }\n    let method = isRouteRequest ? \"queryRoute\" : \"query\";\n    throw new Error(`${method}() call aborted without an \\`AbortSignal.reason\\`: ${request.method} ${request.url}`);\n}\nfunction isSubmissionNavigation(opts) {\n    return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== void 0);\n}\nfunction normalizeTo(location, matches, basename, to, fromRouteId, relative) {\n    let contextualMatches;\n    let activeRouteMatch;\n    if (fromRouteId) {\n        contextualMatches = [];\n        for (let match of matches){\n            contextualMatches.push(match);\n            if (match.route.id === fromRouteId) {\n                activeRouteMatch = match;\n                break;\n            }\n        }\n    } else {\n        contextualMatches = matches;\n        activeRouteMatch = matches[matches.length - 1];\n    }\n    let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n    if (to == null) {\n        path.search = location.search;\n        path.hash = location.hash;\n    }\n    if ((to == null || to === \"\" || to === \".\") && activeRouteMatch) {\n        let nakedIndex = hasNakedIndexQuery(path.search);\n        if (activeRouteMatch.route.index && !nakedIndex) {\n            path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n        } else if (!activeRouteMatch.route.index && nakedIndex) {\n            let params = new URLSearchParams(path.search);\n            let indexValues = params.getAll(\"index\");\n            params.delete(\"index\");\n            indexValues.filter((v)=>v).forEach((v)=>params.append(\"index\", v));\n            let qs = params.toString();\n            path.search = qs ? `?${qs}` : \"\";\n        }\n    }\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n            basename,\n            path.pathname\n        ]);\n    }\n    return createPath(path);\n}\nfunction normalizeNavigateOptions(isFetcher, path, opts) {\n    if (!opts || !isSubmissionNavigation(opts)) {\n        return {\n            path\n        };\n    }\n    if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n        return {\n            path,\n            error: getInternalRouterError(405, {\n                method: opts.formMethod\n            })\n        };\n    }\n    let getInvalidBodyError = ()=>({\n            path,\n            error: getInternalRouterError(400, {\n                type: \"invalid-body\"\n            })\n        });\n    let rawFormMethod = opts.formMethod || \"get\";\n    let formMethod = rawFormMethod.toUpperCase();\n    let formAction = stripHashFromPath(path);\n    if (opts.body !== void 0) {\n        if (opts.formEncType === \"text/plain\") {\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce((acc, [name, value])=>`${acc}${name}=${value}\n`, \"\") : String(opts.body);\n            return {\n                path,\n                submission: {\n                    formMethod,\n                    formAction,\n                    formEncType: opts.formEncType,\n                    formData: void 0,\n                    json: void 0,\n                    text\n                }\n            };\n        } else if (opts.formEncType === \"application/json\") {\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            try {\n                let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n                return {\n                    path,\n                    submission: {\n                        formMethod,\n                        formAction,\n                        formEncType: opts.formEncType,\n                        formData: void 0,\n                        json,\n                        text: void 0\n                    }\n                };\n            } catch (e) {\n                return getInvalidBodyError();\n            }\n        }\n    }\n    invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n    let searchParams;\n    let formData;\n    if (opts.formData) {\n        searchParams = convertFormDataToSearchParams(opts.formData);\n        formData = opts.formData;\n    } else if (opts.body instanceof FormData) {\n        searchParams = convertFormDataToSearchParams(opts.body);\n        formData = opts.body;\n    } else if (opts.body instanceof URLSearchParams) {\n        searchParams = opts.body;\n        formData = convertSearchParamsToFormData(searchParams);\n    } else if (opts.body == null) {\n        searchParams = new URLSearchParams();\n        formData = new FormData();\n    } else {\n        try {\n            searchParams = new URLSearchParams(opts.body);\n            formData = convertSearchParamsToFormData(searchParams);\n        } catch (e) {\n            return getInvalidBodyError();\n        }\n    }\n    let submission = {\n        formMethod,\n        formAction,\n        formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n        formData,\n        json: void 0,\n        text: void 0\n    };\n    if (isMutationMethod(submission.formMethod)) {\n        return {\n            path,\n            submission\n        };\n    }\n    let parsedPath = parsePath(path);\n    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n        searchParams.append(\"index\", \"\");\n    }\n    parsedPath.search = `?${searchParams}`;\n    return {\n        path: createPath(parsedPath),\n        submission\n    };\n}\nfunction getMatchesToLoad(request, scopedContext, mapRouteProperties2, manifest, history, state, matches, submission, location, lazyRoutePropertiesToSkip, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, hasPatchRoutesOnNavigation, pendingActionResult) {\n    let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;\n    let currentUrl = history.createURL(state.location);\n    let nextUrl = history.createURL(location);\n    let maxIdx;\n    if (initialHydration && state.errors) {\n        let boundaryId = Object.keys(state.errors)[0];\n        maxIdx = matches.findIndex((m)=>m.route.id === boundaryId);\n    } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {\n        let boundaryId = pendingActionResult[0];\n        maxIdx = matches.findIndex((m)=>m.route.id === boundaryId) - 1;\n    }\n    let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;\n    let shouldSkipRevalidation = actionStatus && actionStatus >= 400;\n    let baseShouldRevalidateArgs = {\n        currentUrl,\n        currentParams: state.matches[0]?.params || {},\n        nextUrl,\n        nextParams: matches[0].params,\n        ...submission,\n        actionResult,\n        actionStatus\n    };\n    let dsMatches = matches.map((match, index)=>{\n        let { route } = match;\n        let forceShouldLoad = null;\n        if (maxIdx != null && index > maxIdx) {\n            forceShouldLoad = false;\n        } else if (route.lazy) {\n            forceShouldLoad = true;\n        } else if (route.loader == null) {\n            forceShouldLoad = false;\n        } else if (initialHydration) {\n            forceShouldLoad = shouldLoadRouteOnHydration(route, state.loaderData, state.errors);\n        } else if (isNewLoader(state.loaderData, state.matches[index], match)) {\n            forceShouldLoad = true;\n        }\n        if (forceShouldLoad !== null) {\n            return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, forceShouldLoad);\n        }\n        let defaultShouldRevalidate = shouldSkipRevalidation ? false : // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n        isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n        currentUrl.search !== nextUrl.search || isNewRouteInstance(state.matches[index], match);\n        let shouldRevalidateArgs = {\n            ...baseShouldRevalidateArgs,\n            defaultShouldRevalidate\n        };\n        let shouldLoad = shouldRevalidateLoader(match, shouldRevalidateArgs);\n        return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, shouldRevalidateArgs);\n    });\n    let revalidatingFetchers = [];\n    fetchLoadMatches.forEach((f, key)=>{\n        if (initialHydration || !matches.some((m)=>m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {\n            return;\n        }\n        let fetcher = state.fetchers.get(key);\n        let isMidInitialLoad = fetcher && fetcher.state !== \"idle\" && fetcher.data === void 0;\n        let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n        if (!fetcherMatches) {\n            if (hasPatchRoutesOnNavigation && isMidInitialLoad) {\n                return;\n            }\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: null,\n                match: null,\n                request: null,\n                controller: null\n            });\n            return;\n        }\n        if (fetchRedirectIds.has(key)) {\n            return;\n        }\n        let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n        let fetchController = new AbortController();\n        let fetchRequest = createClientSideRequest(history, f.path, fetchController.signal);\n        let fetcherDsMatches = null;\n        if (cancelledFetcherLoads.has(key)) {\n            cancelledFetcherLoads.delete(key);\n            fetcherDsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, fetcherMatches, fetcherMatch, lazyRoutePropertiesToSkip, scopedContext);\n        } else if (isMidInitialLoad) {\n            if (isRevalidationRequired) {\n                fetcherDsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, fetcherMatches, fetcherMatch, lazyRoutePropertiesToSkip, scopedContext);\n            }\n        } else {\n            let shouldRevalidateArgs = {\n                ...baseShouldRevalidateArgs,\n                defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired\n            };\n            if (shouldRevalidateLoader(fetcherMatch, shouldRevalidateArgs)) {\n                fetcherDsMatches = getTargetedDataStrategyMatches(mapRouteProperties2, manifest, fetchRequest, fetcherMatches, fetcherMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs);\n            }\n        }\n        if (fetcherDsMatches) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: fetcherDsMatches,\n                match: fetcherMatch,\n                request: fetchRequest,\n                controller: fetchController\n            });\n        }\n    });\n    return {\n        dsMatches,\n        revalidatingFetchers\n    };\n}\nfunction shouldLoadRouteOnHydration(route, loaderData, errors) {\n    if (route.lazy) {\n        return true;\n    }\n    if (!route.loader) {\n        return false;\n    }\n    let hasData = loaderData != null && route.id in loaderData;\n    let hasError = errors != null && errors[route.id] !== void 0;\n    if (!hasData && hasError) {\n        return false;\n    }\n    if (typeof route.loader === \"function\" && route.loader.hydrate === true) {\n        return true;\n    }\n    return !hasData && !hasError;\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n    let isNew = // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n    let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);\n    return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n    let currentPath = currentMatch.route.path;\n    return(// param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]);\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n    if (loaderMatch.route.shouldRevalidate) {\n        let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n        if (typeof routeChoice === \"boolean\") {\n            return routeChoice;\n        }\n    }\n    return arg.defaultShouldRevalidate;\n}\nfunction patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {\n    let childrenToPatch;\n    if (routeId) {\n        let route = manifest[routeId];\n        invariant(route, `No route found to patch children into: routeId = ${routeId}`);\n        if (!route.children) {\n            route.children = [];\n        }\n        childrenToPatch = route.children;\n    } else {\n        childrenToPatch = routesToUse;\n    }\n    let uniqueChildren = children.filter((newRoute)=>!childrenToPatch.some((existingRoute)=>isSameRoute(newRoute, existingRoute)));\n    let newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties2, [\n        routeId || \"_\",\n        \"patch\",\n        String(childrenToPatch?.length || \"0\")\n    ], manifest);\n    childrenToPatch.push(...newRoutes);\n}\nfunction isSameRoute(newRoute, existingRoute) {\n    if (\"id\" in newRoute && \"id\" in existingRoute && newRoute.id === existingRoute.id) {\n        return true;\n    }\n    if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {\n        return false;\n    }\n    if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {\n        return true;\n    }\n    return newRoute.children.every((aChild, i)=>existingRoute.children?.some((bChild)=>isSameRoute(aChild, bChild)));\n}\nvar lazyRoutePropertyCache = /* @__PURE__ */ new WeakMap();\nvar loadLazyRouteProperty = ({ key, route, manifest, mapRouteProperties: mapRouteProperties2 })=>{\n    let routeToUpdate = manifest[route.id];\n    invariant(routeToUpdate, \"No route found in manifest\");\n    if (!routeToUpdate.lazy || typeof routeToUpdate.lazy !== \"object\") {\n        return;\n    }\n    let lazyFn = routeToUpdate.lazy[key];\n    if (!lazyFn) {\n        return;\n    }\n    let cache = lazyRoutePropertyCache.get(routeToUpdate);\n    if (!cache) {\n        cache = {};\n        lazyRoutePropertyCache.set(routeToUpdate, cache);\n    }\n    let cachedPromise = cache[key];\n    if (cachedPromise) {\n        return cachedPromise;\n    }\n    let propertyPromise = (async ()=>{\n        let isUnsupported = isUnsupportedLazyRouteObjectKey(key);\n        let staticRouteValue = routeToUpdate[key];\n        let isStaticallyDefined = staticRouteValue !== void 0 && key !== \"hasErrorBoundary\";\n        if (isUnsupported) {\n            warning(!isUnsupported, \"Route property \" + key + \" is not a supported lazy route property. This property will be ignored.\");\n            cache[key] = Promise.resolve();\n        } else if (isStaticallyDefined) {\n            warning(false, `Route \"${routeToUpdate.id}\" has a static property \"${key}\" defined. The lazy property will be ignored.`);\n        } else {\n            let value = await lazyFn();\n            if (value != null) {\n                Object.assign(routeToUpdate, {\n                    [key]: value\n                });\n                Object.assign(routeToUpdate, mapRouteProperties2(routeToUpdate));\n            }\n        }\n        if (typeof routeToUpdate.lazy === \"object\") {\n            routeToUpdate.lazy[key] = void 0;\n            if (Object.values(routeToUpdate.lazy).every((value)=>value === void 0)) {\n                routeToUpdate.lazy = void 0;\n            }\n        }\n    })();\n    cache[key] = propertyPromise;\n    return propertyPromise;\n};\nvar lazyRouteFunctionCache = /* @__PURE__ */ new WeakMap();\nfunction loadLazyRoute(route, type, manifest, mapRouteProperties2, lazyRoutePropertiesToSkip) {\n    let routeToUpdate = manifest[route.id];\n    invariant(routeToUpdate, \"No route found in manifest\");\n    if (!route.lazy) {\n        return {\n            lazyRoutePromise: void 0,\n            lazyHandlerPromise: void 0\n        };\n    }\n    if (typeof route.lazy === \"function\") {\n        let cachedPromise = lazyRouteFunctionCache.get(routeToUpdate);\n        if (cachedPromise) {\n            return {\n                lazyRoutePromise: cachedPromise,\n                lazyHandlerPromise: cachedPromise\n            };\n        }\n        let lazyRoutePromise2 = (async ()=>{\n            invariant(typeof route.lazy === \"function\", \"No lazy route function found\");\n            let lazyRoute = await route.lazy();\n            let routeUpdates = {};\n            for(let lazyRouteProperty in lazyRoute){\n                let lazyValue = lazyRoute[lazyRouteProperty];\n                if (lazyValue === void 0) {\n                    continue;\n                }\n                let isUnsupported = isUnsupportedLazyRouteFunctionKey(lazyRouteProperty);\n                let staticRouteValue = routeToUpdate[lazyRouteProperty];\n                let isStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based\n                // on the route updates\n                lazyRouteProperty !== \"hasErrorBoundary\";\n                if (isUnsupported) {\n                    warning(!isUnsupported, \"Route property \" + lazyRouteProperty + \" is not a supported property to be returned from a lazy route function. This property will be ignored.\");\n                } else if (isStaticallyDefined) {\n                    warning(!isStaticallyDefined, `Route \"${routeToUpdate.id}\" has a static property \"${lazyRouteProperty}\" defined but its lazy function is also returning a value for this property. The lazy route property \"${lazyRouteProperty}\" will be ignored.`);\n                } else {\n                    routeUpdates[lazyRouteProperty] = lazyValue;\n                }\n            }\n            Object.assign(routeToUpdate, routeUpdates);\n            Object.assign(routeToUpdate, {\n                // To keep things framework agnostic, we use the provided `mapRouteProperties`\n                // function to set the framework-aware properties (`element`/`hasErrorBoundary`)\n                // since the logic will differ between frameworks.\n                ...mapRouteProperties2(routeToUpdate),\n                lazy: void 0\n            });\n        })();\n        lazyRouteFunctionCache.set(routeToUpdate, lazyRoutePromise2);\n        lazyRoutePromise2.catch(()=>{});\n        return {\n            lazyRoutePromise: lazyRoutePromise2,\n            lazyHandlerPromise: lazyRoutePromise2\n        };\n    }\n    let lazyKeys = Object.keys(route.lazy);\n    let lazyPropertyPromises = [];\n    let lazyHandlerPromise = void 0;\n    for (let key of lazyKeys){\n        if (lazyRoutePropertiesToSkip && lazyRoutePropertiesToSkip.includes(key)) {\n            continue;\n        }\n        let promise = loadLazyRouteProperty({\n            key,\n            route,\n            manifest,\n            mapRouteProperties: mapRouteProperties2\n        });\n        if (promise) {\n            lazyPropertyPromises.push(promise);\n            if (key === type) {\n                lazyHandlerPromise = promise;\n            }\n        }\n    }\n    let lazyRoutePromise = lazyPropertyPromises.length > 0 ? Promise.all(lazyPropertyPromises).then(()=>{}) : void 0;\n    lazyRoutePromise?.catch(()=>{});\n    lazyHandlerPromise?.catch(()=>{});\n    return {\n        lazyRoutePromise,\n        lazyHandlerPromise\n    };\n}\nfunction isNonNullable(value) {\n    return value !== void 0;\n}\nfunction loadLazyMiddlewareForMatches(matches, manifest, mapRouteProperties2) {\n    let promises = matches.map(({ route })=>{\n        if (typeof route.lazy !== \"object\" || !route.lazy.unstable_middleware) {\n            return void 0;\n        }\n        return loadLazyRouteProperty({\n            key: \"unstable_middleware\",\n            route,\n            manifest,\n            mapRouteProperties: mapRouteProperties2\n        });\n    }).filter(isNonNullable);\n    return promises.length > 0 ? Promise.all(promises) : void 0;\n}\nasync function defaultDataStrategy(args) {\n    let matchesToLoad = args.matches.filter((m)=>m.shouldLoad);\n    let keyedResults = {};\n    let results = await Promise.all(matchesToLoad.map((m)=>m.resolve()));\n    results.forEach((result, i)=>{\n        keyedResults[matchesToLoad[i].route.id] = result;\n    });\n    return keyedResults;\n}\nasync function defaultDataStrategyWithMiddleware(args) {\n    if (!args.matches.some((m)=>m.route.unstable_middleware)) {\n        return defaultDataStrategy(args);\n    }\n    return runMiddlewarePipeline(args, false, ()=>defaultDataStrategy(args), (error, routeId)=>({\n            [routeId]: {\n                type: \"error\",\n                result: error\n            }\n        }));\n}\nasync function runMiddlewarePipeline(args, propagateResult, handler, errorHandler) {\n    let { matches, request, params, context } = args;\n    let middlewareState = {\n        handlerResult: void 0\n    };\n    try {\n        let tuples = matches.flatMap((m)=>m.route.unstable_middleware ? m.route.unstable_middleware.map((fn)=>[\n                    m.route.id,\n                    fn\n                ]) : []);\n        let result = await callRouteMiddleware({\n            request,\n            params,\n            context\n        }, tuples, propagateResult, middlewareState, handler);\n        return propagateResult ? result : middlewareState.handlerResult;\n    } catch (e) {\n        if (!middlewareState.middlewareError) {\n            throw e;\n        }\n        let result = await errorHandler(middlewareState.middlewareError.error, middlewareState.middlewareError.routeId);\n        if (propagateResult || !middlewareState.handlerResult) {\n            return result;\n        }\n        return Object.assign(middlewareState.handlerResult, result);\n    }\n}\nasync function callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx = 0) {\n    let { request } = args;\n    if (request.signal.aborted) {\n        if (request.signal.reason) {\n            throw request.signal.reason;\n        }\n        throw new Error(`Request aborted without an \\`AbortSignal.reason\\`: ${request.method} ${request.url}`);\n    }\n    let tuple = middlewares[idx];\n    if (!tuple) {\n        middlewareState.handlerResult = await handler();\n        return middlewareState.handlerResult;\n    }\n    let [routeId, middleware] = tuple;\n    let nextCalled = false;\n    let nextResult = void 0;\n    let next = async ()=>{\n        if (nextCalled) {\n            throw new Error(\"You may only call `next()` once per middleware\");\n        }\n        nextCalled = true;\n        let result = await callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx + 1);\n        if (propagateResult) {\n            nextResult = result;\n            return nextResult;\n        }\n    };\n    try {\n        let result = await middleware({\n            request: args.request,\n            params: args.params,\n            context: args.context\n        }, next);\n        if (nextCalled) {\n            if (result === void 0) {\n                return nextResult;\n            } else {\n                return result;\n            }\n        } else {\n            return next();\n        }\n    } catch (error) {\n        if (!middlewareState.middlewareError) {\n            middlewareState.middlewareError = {\n                routeId,\n                error\n            };\n        } else if (middlewareState.middlewareError.error !== error) {\n            middlewareState.middlewareError = {\n                routeId,\n                error\n            };\n        }\n        throw error;\n    }\n}\nfunction getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip) {\n    let lazyMiddlewarePromise = loadLazyRouteProperty({\n        key: \"unstable_middleware\",\n        route: match.route,\n        manifest,\n        mapRouteProperties: mapRouteProperties2\n    });\n    let lazyRoutePromises = loadLazyRoute(match.route, isMutationMethod(request.method) ? \"action\" : \"loader\", manifest, mapRouteProperties2, lazyRoutePropertiesToSkip);\n    return {\n        middleware: lazyMiddlewarePromise,\n        route: lazyRoutePromises.lazyRoutePromise,\n        handler: lazyRoutePromises.lazyHandlerPromise\n    };\n}\nfunction getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, shouldLoad, unstable_shouldRevalidateArgs = null) {\n    let isUsingNewApi = false;\n    let _lazyPromises = getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip);\n    return {\n        ...match,\n        _lazyPromises,\n        shouldLoad,\n        unstable_shouldRevalidateArgs,\n        unstable_shouldCallHandler (defaultShouldRevalidate) {\n            isUsingNewApi = true;\n            if (!unstable_shouldRevalidateArgs) {\n                return shouldLoad;\n            }\n            if (typeof defaultShouldRevalidate === \"boolean\") {\n                return shouldRevalidateLoader(match, {\n                    ...unstable_shouldRevalidateArgs,\n                    defaultShouldRevalidate\n                });\n            }\n            return shouldRevalidateLoader(match, unstable_shouldRevalidateArgs);\n        },\n        resolve (handlerOverride) {\n            if (isUsingNewApi || shouldLoad || handlerOverride && request.method === \"GET\" && (match.route.lazy || match.route.loader)) {\n                return callLoaderOrAction({\n                    request,\n                    match,\n                    lazyHandlerPromise: _lazyPromises?.handler,\n                    lazyRoutePromise: _lazyPromises?.route,\n                    handlerOverride,\n                    scopedContext\n                });\n            }\n            return Promise.resolve({\n                type: \"data\" /* data */ ,\n                result: void 0\n            });\n        }\n    };\n}\nfunction getTargetedDataStrategyMatches(mapRouteProperties2, manifest, request, matches, targetMatch, lazyRoutePropertiesToSkip, scopedContext, shouldRevalidateArgs = null) {\n    return matches.map((match)=>{\n        if (match.route.id !== targetMatch.route.id) {\n            return {\n                ...match,\n                shouldLoad: false,\n                unstable_shouldRevalidateArgs: shouldRevalidateArgs,\n                unstable_shouldCallHandler: ()=>false,\n                _lazyPromises: getDataStrategyMatchLazyPromises(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip),\n                resolve: ()=>Promise.resolve({\n                        type: \"data\",\n                        result: void 0\n                    })\n            };\n        }\n        return getDataStrategyMatch(mapRouteProperties2, manifest, request, match, lazyRoutePropertiesToSkip, scopedContext, true, shouldRevalidateArgs);\n    });\n}\nasync function callDataStrategyImpl(dataStrategyImpl, request, matches, fetcherKey, scopedContext, isStaticHandler) {\n    if (matches.some((m)=>m._lazyPromises?.middleware)) {\n        await Promise.all(matches.map((m)=>m._lazyPromises?.middleware));\n    }\n    let dataStrategyArgs = {\n        request,\n        params: matches[0].params,\n        context: scopedContext,\n        matches\n    };\n    let unstable_runClientMiddleware = isStaticHandler ? ()=>{\n        throw new Error(\"You cannot call `unstable_runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`\");\n    } : (cb)=>{\n        let typedDataStrategyArgs = dataStrategyArgs;\n        return runMiddlewarePipeline(typedDataStrategyArgs, false, ()=>cb({\n                ...typedDataStrategyArgs,\n                fetcherKey,\n                unstable_runClientMiddleware: ()=>{\n                    throw new Error(\"Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler\");\n                }\n            }), (error, routeId)=>({\n                [routeId]: {\n                    type: \"error\",\n                    result: error\n                }\n            }));\n    };\n    let results = await dataStrategyImpl({\n        ...dataStrategyArgs,\n        fetcherKey,\n        unstable_runClientMiddleware\n    });\n    try {\n        await Promise.all(matches.flatMap((m)=>[\n                m._lazyPromises?.handler,\n                m._lazyPromises?.route\n            ]));\n    } catch (e) {}\n    return results;\n}\nasync function callLoaderOrAction({ request, match, lazyHandlerPromise, lazyRoutePromise, handlerOverride, scopedContext }) {\n    let result;\n    let onReject;\n    let isAction = isMutationMethod(request.method);\n    let type = isAction ? \"action\" : \"loader\";\n    let runHandler = (handler)=>{\n        let reject;\n        let abortPromise = new Promise((_, r)=>reject = r);\n        onReject = ()=>reject();\n        request.signal.addEventListener(\"abort\", onReject);\n        let actualHandler = (ctx)=>{\n            if (typeof handler !== \"function\") {\n                return Promise.reject(new Error(`You cannot call the handler for a route which defines a boolean \"${type}\" [routeId: ${match.route.id}]`));\n            }\n            return handler({\n                request,\n                params: match.params,\n                context: scopedContext\n            }, ...ctx !== void 0 ? [\n                ctx\n            ] : []);\n        };\n        let handlerPromise = (async ()=>{\n            try {\n                let val = await (handlerOverride ? handlerOverride((ctx)=>actualHandler(ctx)) : actualHandler());\n                return {\n                    type: \"data\",\n                    result: val\n                };\n            } catch (e) {\n                return {\n                    type: \"error\",\n                    result: e\n                };\n            }\n        })();\n        return Promise.race([\n            handlerPromise,\n            abortPromise\n        ]);\n    };\n    try {\n        let handler = isAction ? match.route.action : match.route.loader;\n        if (lazyHandlerPromise || lazyRoutePromise) {\n            if (handler) {\n                let handlerError;\n                let [value] = await Promise.all([\n                    // If the handler throws, don't let it immediately bubble out,\n                    // since we need to let the lazy() execution finish so we know if this\n                    // route has a boundary that can handle the error\n                    runHandler(handler).catch((e)=>{\n                        handlerError = e;\n                    }),\n                    // Ensure all lazy route promises are resolved before continuing\n                    lazyHandlerPromise,\n                    lazyRoutePromise\n                ]);\n                if (handlerError !== void 0) {\n                    throw handlerError;\n                }\n                result = value;\n            } else {\n                await lazyHandlerPromise;\n                let handler2 = isAction ? match.route.action : match.route.loader;\n                if (handler2) {\n                    [result] = await Promise.all([\n                        runHandler(handler2),\n                        lazyRoutePromise\n                    ]);\n                } else if (type === \"action\") {\n                    let url = new URL(request.url);\n                    let pathname = url.pathname + url.search;\n                    throw getInternalRouterError(405, {\n                        method: request.method,\n                        pathname,\n                        routeId: match.route.id\n                    });\n                } else {\n                    return {\n                        type: \"data\" /* data */ ,\n                        result: void 0\n                    };\n                }\n            }\n        } else if (!handler) {\n            let url = new URL(request.url);\n            let pathname = url.pathname + url.search;\n            throw getInternalRouterError(404, {\n                pathname\n            });\n        } else {\n            result = await runHandler(handler);\n        }\n    } catch (e) {\n        return {\n            type: \"error\" /* error */ ,\n            result: e\n        };\n    } finally{\n        if (onReject) {\n            request.signal.removeEventListener(\"abort\", onReject);\n        }\n    }\n    return result;\n}\nasync function convertDataStrategyResultToDataResult(dataStrategyResult) {\n    let { result, type } = dataStrategyResult;\n    if (isResponse(result)) {\n        let data2;\n        try {\n            let contentType = result.headers.get(\"Content-Type\");\n            if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n                if (result.body == null) {\n                    data2 = null;\n                } else {\n                    data2 = await result.json();\n                }\n            } else {\n                data2 = await result.text();\n            }\n        } catch (e) {\n            return {\n                type: \"error\" /* error */ ,\n                error: e\n            };\n        }\n        if (type === \"error\" /* error */ ) {\n            return {\n                type: \"error\" /* error */ ,\n                error: new ErrorResponseImpl(result.status, result.statusText, data2),\n                statusCode: result.status,\n                headers: result.headers\n            };\n        }\n        return {\n            type: \"data\" /* data */ ,\n            data: data2,\n            statusCode: result.status,\n            headers: result.headers\n        };\n    }\n    if (type === \"error\" /* error */ ) {\n        if (isDataWithResponseInit(result)) {\n            if (result.data instanceof Error) {\n                return {\n                    type: \"error\" /* error */ ,\n                    error: result.data,\n                    statusCode: result.init?.status,\n                    headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n                };\n            }\n            return {\n                type: \"error\" /* error */ ,\n                error: new ErrorResponseImpl(result.init?.status || 500, void 0, result.data),\n                statusCode: isRouteErrorResponse(result) ? result.status : void 0,\n                headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n            };\n        }\n        return {\n            type: \"error\" /* error */ ,\n            error: result,\n            statusCode: isRouteErrorResponse(result) ? result.status : void 0\n        };\n    }\n    if (isDataWithResponseInit(result)) {\n        return {\n            type: \"data\" /* data */ ,\n            data: result.data,\n            statusCode: result.init?.status,\n            headers: result.init?.headers ? new Headers(result.init.headers) : void 0\n        };\n    }\n    return {\n        type: \"data\" /* data */ ,\n        data: result\n    };\n}\nfunction normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {\n    let location = response.headers.get(\"Location\");\n    invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n    if (!ABSOLUTE_URL_REGEX.test(location)) {\n        let trimmedMatches = matches.slice(0, matches.findIndex((m)=>m.route.id === routeId) + 1);\n        location = normalizeTo(new URL(request.url), trimmedMatches, basename, location);\n        response.headers.set(\"Location\", location);\n    }\n    return response;\n}\nfunction normalizeRedirectLocation(location, currentUrl, basename) {\n    if (ABSOLUTE_URL_REGEX.test(location)) {\n        let normalizedLocation = location;\n        let url = normalizedLocation.startsWith(\"//\") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n            return url.pathname + url.search + url.hash;\n        }\n    }\n    return location;\n}\nfunction createClientSideRequest(history, location, signal, submission) {\n    let url = history.createURL(stripHashFromPath(location)).toString();\n    let init = {\n        signal\n    };\n    if (submission && isMutationMethod(submission.formMethod)) {\n        let { formMethod, formEncType } = submission;\n        init.method = formMethod.toUpperCase();\n        if (formEncType === \"application/json\") {\n            init.headers = new Headers({\n                \"Content-Type\": formEncType\n            });\n            init.body = JSON.stringify(submission.json);\n        } else if (formEncType === \"text/plain\") {\n            init.body = submission.text;\n        } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n            init.body = convertFormDataToSearchParams(submission.formData);\n        } else {\n            init.body = submission.formData;\n        }\n    }\n    return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n    let searchParams = new URLSearchParams();\n    for (let [key, value] of formData.entries()){\n        searchParams.append(key, typeof value === \"string\" ? value : value.name);\n    }\n    return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n    let formData = new FormData();\n    for (let [key, value] of searchParams.entries()){\n        formData.append(key, value);\n    }\n    return formData;\n}\nfunction processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {\n    let loaderData = {};\n    let errors = null;\n    let statusCode;\n    let foundError = false;\n    let loaderHeaders = {};\n    let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;\n    matches.forEach((match)=>{\n        if (!(match.route.id in results)) {\n            return;\n        }\n        let id = match.route.id;\n        let result = results[id];\n        invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n        if (isErrorResult(result)) {\n            let error = result.error;\n            if (pendingError !== void 0) {\n                error = pendingError;\n                pendingError = void 0;\n            }\n            errors = errors || {};\n            if (skipLoaderErrorBubbling) {\n                errors[id] = error;\n            } else {\n                let boundaryMatch = findNearestBoundary(matches, id);\n                if (errors[boundaryMatch.route.id] == null) {\n                    errors[boundaryMatch.route.id] = error;\n                }\n            }\n            if (!isStaticHandler) {\n                loaderData[id] = ResetLoaderDataSymbol;\n            }\n            if (!foundError) {\n                foundError = true;\n                statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        } else {\n            loaderData[id] = result.data;\n            if (result.statusCode && result.statusCode !== 200 && !foundError) {\n                statusCode = result.statusCode;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        }\n    });\n    if (pendingError !== void 0 && pendingActionResult) {\n        errors = {\n            [pendingActionResult[0]]: pendingError\n        };\n        if (pendingActionResult[2]) {\n            loaderData[pendingActionResult[2]] = void 0;\n        }\n    }\n    return {\n        loaderData,\n        errors,\n        statusCode: statusCode || 200,\n        loaderHeaders\n    };\n}\nfunction processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {\n    let { loaderData, errors } = processRouteLoaderData(matches, results, pendingActionResult);\n    revalidatingFetchers.filter((f)=>!f.matches || f.matches.some((m)=>m.shouldLoad)).forEach((rf)=>{\n        let { key, match, controller } = rf;\n        let result = fetcherResults[key];\n        invariant(result, \"Did not find corresponding fetcher result\");\n        if (controller && controller.signal.aborted) {\n            return;\n        } else if (isErrorResult(result)) {\n            let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);\n            if (!(errors && errors[boundaryMatch.route.id])) {\n                errors = {\n                    ...errors,\n                    [boundaryMatch.route.id]: result.error\n                };\n            }\n            state.fetchers.delete(key);\n        } else if (isRedirectResult(result)) {\n            invariant(false, \"Unhandled fetcher revalidation redirect\");\n        } else {\n            let doneFetcher = getDoneFetcher(result.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    });\n    return {\n        loaderData,\n        errors\n    };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n    let mergedLoaderData = Object.entries(newLoaderData).filter(([, v])=>v !== ResetLoaderDataSymbol).reduce((merged, [k, v])=>{\n        merged[k] = v;\n        return merged;\n    }, {});\n    for (let match of matches){\n        let id = match.route.id;\n        if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match.route.loader) {\n            mergedLoaderData[id] = loaderData[id];\n        }\n        if (errors && errors.hasOwnProperty(id)) {\n            break;\n        }\n    }\n    return mergedLoaderData;\n}\nfunction getActionDataForCommit(pendingActionResult) {\n    if (!pendingActionResult) {\n        return {};\n    }\n    return isErrorResult(pendingActionResult[1]) ? {\n        // Clear out prior actionData on errors\n        actionData: {}\n    } : {\n        actionData: {\n            [pendingActionResult[0]]: pendingActionResult[1].data\n        }\n    };\n}\nfunction findNearestBoundary(matches, routeId) {\n    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m)=>m.route.id === routeId) + 1) : [\n        ...matches\n    ];\n    return eligibleMatches.reverse().find((m)=>m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n    let route = routes.length === 1 ? routes[0] : routes.find((r)=>r.index || !r.path || r.path === \"/\") || {\n        id: `__shim-error-route__`\n    };\n    return {\n        matches: [\n            {\n                params: {},\n                pathname: \"\",\n                pathnameBase: \"\",\n                route\n            }\n        ],\n        route\n    };\n}\nfunction getInternalRouterError(status, { pathname, routeId, method, type, message } = {}) {\n    let statusText = \"Unknown Server Error\";\n    let errorMessage = \"Unknown @remix-run/router error\";\n    if (status === 400) {\n        statusText = \"Bad Request\";\n        if (method && pathname && routeId) {\n            errorMessage = `You made a ${method} request to \"${pathname}\" but did not provide a \\`loader\\` for route \"${routeId}\", so there is no way to handle the request.`;\n        } else if (type === \"invalid-body\") {\n            errorMessage = \"Unable to encode submission body\";\n        }\n    } else if (status === 403) {\n        statusText = \"Forbidden\";\n        errorMessage = `Route \"${routeId}\" does not match URL \"${pathname}\"`;\n    } else if (status === 404) {\n        statusText = \"Not Found\";\n        errorMessage = `No route matches URL \"${pathname}\"`;\n    } else if (status === 405) {\n        statusText = \"Method Not Allowed\";\n        if (method && pathname && routeId) {\n            errorMessage = `You made a ${method.toUpperCase()} request to \"${pathname}\" but did not provide an \\`action\\` for route \"${routeId}\", so there is no way to handle the request.`;\n        } else if (method) {\n            errorMessage = `Invalid request method \"${method.toUpperCase()}\"`;\n        }\n    }\n    return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\nfunction findRedirect(results) {\n    let entries = Object.entries(results);\n    for(let i = entries.length - 1; i >= 0; i--){\n        let [key, result] = entries[i];\n        if (isRedirectResult(result)) {\n            return {\n                key,\n                result\n            };\n        }\n    }\n}\nfunction stripHashFromPath(path) {\n    let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n    return createPath({\n        ...parsedPath,\n        hash: \"\"\n    });\n}\nfunction isHashChangeOnly(a, b) {\n    if (a.pathname !== b.pathname || a.search !== b.search) {\n        return false;\n    }\n    if (a.hash === \"\") {\n        return b.hash !== \"\";\n    } else if (a.hash === b.hash) {\n        return true;\n    } else if (b.hash !== \"\") {\n        return true;\n    }\n    return false;\n}\nfunction isDataStrategyResult(result) {\n    return result != null && typeof result === \"object\" && \"type\" in result && \"result\" in result && (result.type === \"data\" /* data */  || result.type === \"error\" /* error */ );\n}\nfunction isRedirectDataStrategyResult(result) {\n    return isResponse(result.result) && redirectStatusCodes.has(result.result.status);\n}\nfunction isErrorResult(result) {\n    return result.type === \"error\" /* error */ ;\n}\nfunction isRedirectResult(result) {\n    return (result && result.type) === \"redirect\" /* redirect */ ;\n}\nfunction isDataWithResponseInit(value) {\n    return typeof value === \"object\" && value != null && \"type\" in value && \"data\" in value && \"init\" in value && value.type === \"DataWithResponseInit\";\n}\nfunction isResponse(value) {\n    return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectStatusCode(statusCode) {\n    return redirectStatusCodes.has(statusCode);\n}\nfunction isRedirectResponse(result) {\n    return isResponse(result) && isRedirectStatusCode(result.status) && result.headers.has(\"Location\");\n}\nfunction isValidMethod(method) {\n    return validRequestMethods.has(method.toUpperCase());\n}\nfunction isMutationMethod(method) {\n    return validMutationMethods.has(method.toUpperCase());\n}\nfunction hasNakedIndexQuery(search) {\n    return new URLSearchParams(search).getAll(\"index\").some((v)=>v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n    let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n        return matches[matches.length - 1];\n    }\n    let pathMatches = getPathContributingMatches(matches);\n    return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n    let { formMethod, formAction, formEncType, text, formData, json } = navigation;\n    if (!formMethod || !formAction || !formEncType) {\n        return;\n    }\n    if (text != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: void 0,\n            json: void 0,\n            text\n        };\n    } else if (formData != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData,\n            json: void 0,\n            text: void 0\n        };\n    } else if (json !== void 0) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: void 0,\n            json,\n            text: void 0\n        };\n    }\n}\nfunction getLoadingNavigation(location, submission) {\n    if (submission) {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text\n        };\n        return navigation;\n    } else {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: void 0,\n            formAction: void 0,\n            formEncType: void 0,\n            formData: void 0,\n            json: void 0,\n            text: void 0\n        };\n        return navigation;\n    }\n}\nfunction getSubmittingNavigation(location, submission) {\n    let navigation = {\n        state: \"submitting\",\n        location,\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text\n    };\n    return navigation;\n}\nfunction getLoadingFetcher(submission, data2) {\n    if (submission) {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text,\n            data: data2\n        };\n        return fetcher;\n    } else {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: void 0,\n            formAction: void 0,\n            formEncType: void 0,\n            formData: void 0,\n            json: void 0,\n            text: void 0,\n            data: data2\n        };\n        return fetcher;\n    }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n    let fetcher = {\n        state: \"submitting\",\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text,\n        data: existingFetcher ? existingFetcher.data : void 0\n    };\n    return fetcher;\n}\nfunction getDoneFetcher(data2) {\n    let fetcher = {\n        state: \"idle\",\n        formMethod: void 0,\n        formAction: void 0,\n        formEncType: void 0,\n        formData: void 0,\n        json: void 0,\n        text: void 0,\n        data: data2\n    };\n    return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n    try {\n        let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n        if (sessionPositions) {\n            let json = JSON.parse(sessionPositions);\n            for (let [k, v] of Object.entries(json || {})){\n                if (v && Array.isArray(v)) {\n                    transitions.set(k, new Set(v || []));\n                }\n            }\n        }\n    } catch (e) {}\n}\nfunction persistAppliedTransitions(_window, transitions) {\n    if (transitions.size > 0) {\n        let json = {};\n        for (let [k, v] of transitions){\n            json[k] = [\n                ...v\n            ];\n        }\n        try {\n            _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\n        } catch (error) {\n            warning(false, `Failed to save applied view transitions in sessionStorage (${error}).`);\n        }\n    }\n}\nfunction createDeferred() {\n    let resolve;\n    let reject;\n    let promise = new Promise((res, rej)=>{\n        resolve = async (val)=>{\n            res(val);\n            try {\n                await promise;\n            } catch (e) {}\n        };\n        reject = async (error)=>{\n            rej(error);\n            try {\n                await promise;\n            } catch (e) {}\n        };\n    });\n    return {\n        promise,\n        //@ts-ignore\n        resolve,\n        //@ts-ignore\n        reject\n    };\n}\n// lib/components.tsx\nvar React3 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/context.ts\nvar React = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar DataRouterContext = React.createContext(null);\nDataRouterContext.displayName = \"DataRouter\";\nvar DataRouterStateContext = React.createContext(null);\nDataRouterStateContext.displayName = \"DataRouterState\";\nvar ViewTransitionContext = React.createContext({\n    isTransitioning: false\n});\nViewTransitionContext.displayName = \"ViewTransition\";\nvar FetchersContext = React.createContext(/* @__PURE__ */ new Map());\nFetchersContext.displayName = \"Fetchers\";\nvar AwaitContext = React.createContext(null);\nAwaitContext.displayName = \"Await\";\nvar NavigationContext = React.createContext(null);\nNavigationContext.displayName = \"Navigation\";\nvar LocationContext = React.createContext(null);\nLocationContext.displayName = \"Location\";\nvar RouteContext = React.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n});\nRouteContext.displayName = \"Route\";\nvar RouteErrorContext = React.createContext(null);\nRouteErrorContext.displayName = \"RouteError\";\nvar ENABLE_DEV_WARNINGS = true;\n// lib/hooks.tsx\nvar React2 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction useHref(to, { relative } = {}) {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`);\n    let { basename, navigator } = React2.useContext(NavigationContext);\n    let { hash, pathname, search } = useResolvedPath(to, {\n        relative\n    });\n    let joinedPathname = pathname;\n    if (basename !== \"/\") {\n        joinedPathname = pathname === \"/\" ? basename : joinPaths([\n            basename,\n            pathname\n        ]);\n    }\n    return navigator.createHref({\n        pathname: joinedPathname,\n        search,\n        hash\n    });\n}\nfunction useInRouterContext() {\n    return React2.useContext(LocationContext) != null;\n}\nfunction useLocation() {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`);\n    return React2.useContext(LocationContext).location;\n}\nfunction useNavigationType() {\n    return React2.useContext(LocationContext).navigationType;\n}\nfunction useMatch(pattern) {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`);\n    let { pathname } = useLocation();\n    return React2.useMemo(()=>matchPath(pattern, decodePath(pathname)), [\n        pathname,\n        pattern\n    ]);\n}\nvar navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;\nfunction useIsomorphicLayoutEffect(cb) {\n    let isStatic = React2.useContext(NavigationContext).static;\n    if (!isStatic) {\n        React2.useLayoutEffect(cb);\n    }\n}\nfunction useNavigate() {\n    let { isDataRoute } = React2.useContext(RouteContext);\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`);\n    let dataRouterContext = React2.useContext(DataRouterContext);\n    let { basename, navigator } = React2.useContext(NavigationContext);\n    let { matches } = React2.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));\n    let activeRef = React2.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = React2.useCallback((to, options = {})=>{\n        warning(activeRef.current, navigateEffectWarning);\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            navigator.go(to);\n            return;\n        }\n        let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n        if (dataRouterContext == null && basename !== \"/\") {\n            path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n                basename,\n                path.pathname\n            ]);\n        }\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [\n        basename,\n        navigator,\n        routePathnamesJson,\n        locationPathname,\n        dataRouterContext\n    ]);\n    return navigate;\n}\nvar OutletContext = React2.createContext(null);\nfunction useOutletContext() {\n    return React2.useContext(OutletContext);\n}\nfunction useOutlet(context) {\n    let outlet = React2.useContext(RouteContext).outlet;\n    if (outlet) {\n        return /* @__PURE__ */ React2.createElement(OutletContext.Provider, {\n            value: context\n        }, outlet);\n    }\n    return outlet;\n}\nfunction useParams() {\n    let { matches } = React2.useContext(RouteContext);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n}\nfunction useResolvedPath(to, { relative } = {}) {\n    let { matches } = React2.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));\n    return React2.useMemo(()=>resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [\n        to,\n        routePathnamesJson,\n        locationPathname,\n        relative\n    ]);\n}\nfunction useRoutes(routes, locationArg) {\n    return useRoutesImpl(routes, locationArg);\n}\nfunction useRoutesImpl(routes, locationArg, dataRouterState, future) {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`);\n    let { navigator } = React2.useContext(NavigationContext);\n    let { matches: parentMatches } = React2.useContext(RouteContext);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    if (ENABLE_DEV_WARNINGS) {\n        let parentPath = parentRoute && parentRoute.path || \"\";\n        warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\") || parentPath.endsWith(\"*?\"), `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at \"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the parent route path has no trailing \"*\". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path=\"${parentPath}\"> to <Route path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`);\n    }\n    let locationFromContext = useLocation();\n    let location;\n    if (locationArg) {\n        let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n        invariant(parentPathnameBase === \"/\" || parsedLocationArg.pathname?.startsWith(parentPathnameBase), `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`);\n        location = parsedLocationArg;\n    } else {\n        location = locationFromContext;\n    }\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = pathname;\n    if (parentPathnameBase !== \"/\") {\n        let parentSegments = parentPathnameBase.replace(/^\\//, \"\").split(\"/\");\n        let segments = pathname.replace(/^\\//, \"\").split(\"/\");\n        remainingPathname = \"/\" + segments.slice(parentSegments.length).join(\"/\");\n    }\n    let matches = matchRoutes(routes, {\n        pathname: remainingPathname\n    });\n    if (ENABLE_DEV_WARNINGS) {\n        warning(parentRoute || matches != null, `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `);\n        warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0, `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`);\n    }\n    let renderedMatches = _renderMatches(matches && matches.map((match)=>Object.assign({}, match, {\n            params: Object.assign({}, parentParams, match.params),\n            pathname: joinPaths([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n            ]),\n            pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n            ])\n        })), parentMatches, dataRouterState, future);\n    if (locationArg && renderedMatches) {\n        return /* @__PURE__ */ React2.createElement(LocationContext.Provider, {\n            value: {\n                location: {\n                    pathname: \"/\",\n                    search: \"\",\n                    hash: \"\",\n                    state: null,\n                    key: \"default\",\n                    ...location\n                },\n                navigationType: \"POP\" /* Pop */ \n            }\n        }, renderedMatches);\n    }\n    return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n    let error = useRouteError();\n    let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);\n    let stack = error instanceof Error ? error.stack : null;\n    let lightgrey = \"rgba(200,200,200, 0.5)\";\n    let preStyles = {\n        padding: \"0.5rem\",\n        backgroundColor: lightgrey\n    };\n    let codeStyles = {\n        padding: \"2px 4px\",\n        backgroundColor: lightgrey\n    };\n    let devInfo = null;\n    if (ENABLE_DEV_WARNINGS) {\n        console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n        devInfo = /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /* @__PURE__ */ React2.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /* @__PURE__ */ React2.createElement(\"code\", {\n            style: codeStyles\n        }, \"ErrorBoundary\"), \" or\", \" \", /* @__PURE__ */ React2.createElement(\"code\", {\n            style: codeStyles\n        }, \"errorElement\"), \" prop on your route.\"));\n    }\n    return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\"h2\", null, \"Unexpected Application Error!\"), /* @__PURE__ */ React2.createElement(\"h3\", {\n        style: {\n            fontStyle: \"italic\"\n        }\n    }, message), stack ? /* @__PURE__ */ React2.createElement(\"pre\", {\n        style: preStyles\n    }, stack) : null, devInfo);\n}\nvar defaultErrorElement = /* @__PURE__ */ React2.createElement(DefaultErrorComponent, null);\nvar RenderErrorBoundary = class extends React2.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            location: props.location,\n            revalidation: props.revalidation,\n            error: props.error\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n            return {\n                error: props.error,\n                location: props.location,\n                revalidation: props.revalidation\n            };\n        }\n        return {\n            error: props.error !== void 0 ? props.error : state.error,\n            location: state.location,\n            revalidation: props.revalidation || state.revalidation\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        return this.state.error !== void 0 ? /* @__PURE__ */ React2.createElement(RouteContext.Provider, {\n            value: this.props.routeContext\n        }, /* @__PURE__ */ React2.createElement(RouteErrorContext.Provider, {\n            value: this.state.error,\n            children: this.props.component\n        })) : this.props.children;\n    }\n};\nfunction RenderedRoute({ routeContext, match, children }) {\n    let dataRouterContext = React2.useContext(DataRouterContext);\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /* @__PURE__ */ React2.createElement(RouteContext.Provider, {\n        value: routeContext\n    }, children);\n}\nfunction _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {\n    if (matches == null) {\n        if (!dataRouterState) {\n            return null;\n        }\n        if (dataRouterState.errors) {\n            matches = dataRouterState.matches;\n        } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {\n            matches = dataRouterState.matches;\n        } else {\n            return null;\n        }\n    }\n    let renderedMatches = matches;\n    let errors = dataRouterState?.errors;\n    if (errors != null) {\n        let errorIndex = renderedMatches.findIndex((m)=>m.route.id && errors?.[m.route.id] !== void 0);\n        invariant(errorIndex >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(errors).join(\",\")}`);\n        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n    let renderFallback = false;\n    let fallbackIndex = -1;\n    if (dataRouterState) {\n        for(let i = 0; i < renderedMatches.length; i++){\n            let match = renderedMatches[i];\n            if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {\n                fallbackIndex = i;\n            }\n            if (match.route.id) {\n                let { loaderData, errors: errors2 } = dataRouterState;\n                let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);\n                if (match.route.lazy || needsToRunLoader) {\n                    renderFallback = true;\n                    if (fallbackIndex >= 0) {\n                        renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);\n                    } else {\n                        renderedMatches = [\n                            renderedMatches[0]\n                        ];\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return renderedMatches.reduceRight((outlet, match, index)=>{\n        let error;\n        let shouldRenderHydrateFallback = false;\n        let errorElement = null;\n        let hydrateFallbackElement = null;\n        if (dataRouterState) {\n            error = errors && match.route.id ? errors[match.route.id] : void 0;\n            errorElement = match.route.errorElement || defaultErrorElement;\n            if (renderFallback) {\n                if (fallbackIndex < 0 && index === 0) {\n                    warningOnce(\"route-fallback\", false, \"No `HydrateFallback` element provided to render during initial hydration\");\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = null;\n                } else if (fallbackIndex === index) {\n                    shouldRenderHydrateFallback = true;\n                    hydrateFallbackElement = match.route.hydrateFallbackElement || null;\n                }\n            }\n        }\n        let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));\n        let getChildren = ()=>{\n            let children;\n            if (error) {\n                children = errorElement;\n            } else if (shouldRenderHydrateFallback) {\n                children = hydrateFallbackElement;\n            } else if (match.route.Component) {\n                children = /* @__PURE__ */ React2.createElement(match.route.Component, null);\n            } else if (match.route.element) {\n                children = match.route.element;\n            } else {\n                children = outlet;\n            }\n            return /* @__PURE__ */ React2.createElement(RenderedRoute, {\n                match,\n                routeContext: {\n                    outlet,\n                    matches: matches2,\n                    isDataRoute: dataRouterState != null\n                },\n                children\n            });\n        };\n        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ React2.createElement(RenderErrorBoundary, {\n            location: dataRouterState.location,\n            revalidation: dataRouterState.revalidation,\n            component: errorElement,\n            error,\n            children: getChildren(),\n            routeContext: {\n                outlet: null,\n                matches: matches2,\n                isDataRoute: true\n            }\n        }) : getChildren();\n    }, null);\n}\nfunction getDataRouterConsoleError(hookName) {\n    return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = React2.useContext(DataRouterContext);\n    invariant(ctx, getDataRouterConsoleError(hookName));\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = React2.useContext(DataRouterStateContext);\n    invariant(state, getDataRouterConsoleError(hookName));\n    return state;\n}\nfunction useRouteContext(hookName) {\n    let route = React2.useContext(RouteContext);\n    invariant(route, getDataRouterConsoleError(hookName));\n    return route;\n}\nfunction useCurrentRouteId(hookName) {\n    let route = useRouteContext(hookName);\n    let thisRoute = route.matches[route.matches.length - 1];\n    invariant(thisRoute.route.id, `${hookName} can only be used on routes that contain a unique \"id\"`);\n    return thisRoute.route.id;\n}\nfunction useRouteId() {\n    return useCurrentRouteId(\"useRouteId\" /* UseRouteId */ );\n}\nfunction useNavigation() {\n    let state = useDataRouterState(\"useNavigation\" /* UseNavigation */ );\n    return state.navigation;\n}\nfunction useRevalidator() {\n    let dataRouterContext = useDataRouterContext(\"useRevalidator\" /* UseRevalidator */ );\n    let state = useDataRouterState(\"useRevalidator\" /* UseRevalidator */ );\n    let revalidate = React2.useCallback(async ()=>{\n        await dataRouterContext.router.revalidate();\n    }, [\n        dataRouterContext.router\n    ]);\n    return React2.useMemo(()=>({\n            revalidate,\n            state: state.revalidation\n        }), [\n        revalidate,\n        state.revalidation\n    ]);\n}\nfunction useMatches() {\n    let { matches, loaderData } = useDataRouterState(\"useMatches\" /* UseMatches */ );\n    return React2.useMemo(()=>matches.map((m)=>convertRouteMatchToUiMatch(m, loaderData)), [\n        matches,\n        loaderData\n    ]);\n}\nfunction useLoaderData() {\n    let state = useDataRouterState(\"useLoaderData\" /* UseLoaderData */ );\n    let routeId = useCurrentRouteId(\"useLoaderData\" /* UseLoaderData */ );\n    return state.loaderData[routeId];\n}\nfunction useRouteLoaderData(routeId) {\n    let state = useDataRouterState(\"useRouteLoaderData\" /* UseRouteLoaderData */ );\n    return state.loaderData[routeId];\n}\nfunction useActionData() {\n    let state = useDataRouterState(\"useActionData\" /* UseActionData */ );\n    let routeId = useCurrentRouteId(\"useLoaderData\" /* UseLoaderData */ );\n    return state.actionData ? state.actionData[routeId] : void 0;\n}\nfunction useRouteError() {\n    let error = React2.useContext(RouteErrorContext);\n    let state = useDataRouterState(\"useRouteError\" /* UseRouteError */ );\n    let routeId = useCurrentRouteId(\"useRouteError\" /* UseRouteError */ );\n    if (error !== void 0) {\n        return error;\n    }\n    return state.errors?.[routeId];\n}\nfunction useAsyncValue() {\n    let value = React2.useContext(AwaitContext);\n    return value?._data;\n}\nfunction useAsyncError() {\n    let value = React2.useContext(AwaitContext);\n    return value?._error;\n}\nvar blockerId = 0;\nfunction useBlocker(shouldBlock) {\n    let { router, basename } = useDataRouterContext(\"useBlocker\" /* UseBlocker */ );\n    let state = useDataRouterState(\"useBlocker\" /* UseBlocker */ );\n    let [blockerKey, setBlockerKey] = React2.useState(\"\");\n    let blockerFunction = React2.useCallback((arg)=>{\n        if (typeof shouldBlock !== \"function\") {\n            return !!shouldBlock;\n        }\n        if (basename === \"/\") {\n            return shouldBlock(arg);\n        }\n        let { currentLocation, nextLocation, historyAction } = arg;\n        return shouldBlock({\n            currentLocation: {\n                ...currentLocation,\n                pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n            },\n            nextLocation: {\n                ...nextLocation,\n                pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n            },\n            historyAction\n        });\n    }, [\n        basename,\n        shouldBlock\n    ]);\n    React2.useEffect(()=>{\n        let key = String(++blockerId);\n        setBlockerKey(key);\n        return ()=>router.deleteBlocker(key);\n    }, [\n        router\n    ]);\n    React2.useEffect(()=>{\n        if (blockerKey !== \"\") {\n            router.getBlocker(blockerKey, blockerFunction);\n        }\n    }, [\n        router,\n        blockerKey,\n        blockerFunction\n    ]);\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\nfunction useNavigateStable() {\n    let { router } = useDataRouterContext(\"useNavigate\" /* UseNavigateStable */ );\n    let id = useCurrentRouteId(\"useNavigate\" /* UseNavigateStable */ );\n    let activeRef = React2.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = React2.useCallback(async (to, options = {})=>{\n        warning(activeRef.current, navigateEffectWarning);\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            router.navigate(to);\n        } else {\n            await router.navigate(to, {\n                fromRouteId: id,\n                ...options\n            });\n        }\n    }, [\n        router,\n        id\n    ]);\n    return navigate;\n}\nvar alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n        alreadyWarned[key] = true;\n        warning(false, message);\n    }\n}\n// lib/server-runtime/warnings.ts\nvar alreadyWarned2 = {};\nfunction warnOnce(condition, message) {\n    if (!condition && !alreadyWarned2[message]) {\n        alreadyWarned2[message] = true;\n        console.warn(message);\n    }\n}\n// lib/components.tsx\nfunction mapRouteProperties(route) {\n    let updates = {\n        // Note: this check also occurs in createRoutesFromChildren so update\n        // there if you change this -- please and thank you!\n        hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) {\n        if (ENABLE_DEV_WARNINGS) {\n            if (route.element) {\n                warning(false, \"You should not include both `Component` and `element` on your route - `Component` will be used.\");\n            }\n        }\n        Object.assign(updates, {\n            element: React3.createElement(route.Component),\n            Component: void 0\n        });\n    }\n    if (route.HydrateFallback) {\n        if (ENABLE_DEV_WARNINGS) {\n            if (route.hydrateFallbackElement) {\n                warning(false, \"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.\");\n            }\n        }\n        Object.assign(updates, {\n            hydrateFallbackElement: React3.createElement(route.HydrateFallback),\n            HydrateFallback: void 0\n        });\n    }\n    if (route.ErrorBoundary) {\n        if (ENABLE_DEV_WARNINGS) {\n            if (route.errorElement) {\n                warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.\");\n            }\n        }\n        Object.assign(updates, {\n            errorElement: React3.createElement(route.ErrorBoundary),\n            ErrorBoundary: void 0\n        });\n    }\n    return updates;\n}\nvar hydrationRouteProperties = [\n    \"HydrateFallback\",\n    \"hydrateFallbackElement\"\n];\nfunction createMemoryRouter(routes, opts) {\n    return createRouter({\n        basename: opts?.basename,\n        unstable_getContext: opts?.unstable_getContext,\n        future: opts?.future,\n        history: createMemoryHistory({\n            initialEntries: opts?.initialEntries,\n            initialIndex: opts?.initialIndex\n        }),\n        hydrationData: opts?.hydrationData,\n        routes,\n        hydrationRouteProperties,\n        mapRouteProperties,\n        dataStrategy: opts?.dataStrategy,\n        patchRoutesOnNavigation: opts?.patchRoutesOnNavigation\n    }).initialize();\n}\nvar Deferred = class {\n    constructor(){\n        this.status = \"pending\";\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = (value)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"resolved\";\n                    resolve(value);\n                }\n            };\n            this.reject = (reason)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"rejected\";\n                    reject(reason);\n                }\n            };\n        });\n    }\n};\nfunction RouterProvider({ router, flushSync: reactDomFlushSyncImpl }) {\n    let [state, setStateImpl] = React3.useState(router.state);\n    let [pendingState, setPendingState] = React3.useState();\n    let [vtContext, setVtContext] = React3.useState({\n        isTransitioning: false\n    });\n    let [renderDfd, setRenderDfd] = React3.useState();\n    let [transition, setTransition] = React3.useState();\n    let [interruption, setInterruption] = React3.useState();\n    let fetcherData = React3.useRef(/* @__PURE__ */ new Map());\n    let setState = React3.useCallback((newState, { deletedFetchers, flushSync, viewTransitionOpts })=>{\n        newState.fetchers.forEach((fetcher, key)=>{\n            if (fetcher.data !== void 0) {\n                fetcherData.current.set(key, fetcher.data);\n            }\n        });\n        deletedFetchers.forEach((key)=>fetcherData.current.delete(key));\n        warnOnce(flushSync === false || reactDomFlushSyncImpl != null, 'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from \"react-router/dom\"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.');\n        let isViewTransitionAvailable = router.window != null && router.window.document != null && typeof router.window.document.startViewTransition === \"function\";\n        warnOnce(viewTransitionOpts == null || isViewTransitionAvailable, \"You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available.\");\n        if (!viewTransitionOpts || !isViewTransitionAvailable) {\n            if (reactDomFlushSyncImpl && flushSync) {\n                reactDomFlushSyncImpl(()=>setStateImpl(newState));\n            } else {\n                React3.startTransition(()=>setStateImpl(newState));\n            }\n            return;\n        }\n        if (reactDomFlushSyncImpl && flushSync) {\n            reactDomFlushSyncImpl(()=>{\n                if (transition) {\n                    renderDfd && renderDfd.resolve();\n                    transition.skipTransition();\n                }\n                setVtContext({\n                    isTransitioning: true,\n                    flushSync: true,\n                    currentLocation: viewTransitionOpts.currentLocation,\n                    nextLocation: viewTransitionOpts.nextLocation\n                });\n            });\n            let t = router.window.document.startViewTransition(()=>{\n                reactDomFlushSyncImpl(()=>setStateImpl(newState));\n            });\n            t.finished.finally(()=>{\n                reactDomFlushSyncImpl(()=>{\n                    setRenderDfd(void 0);\n                    setTransition(void 0);\n                    setPendingState(void 0);\n                    setVtContext({\n                        isTransitioning: false\n                    });\n                });\n            });\n            reactDomFlushSyncImpl(()=>setTransition(t));\n            return;\n        }\n        if (transition) {\n            renderDfd && renderDfd.resolve();\n            transition.skipTransition();\n            setInterruption({\n                state: newState,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        } else {\n            setPendingState(newState);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        }\n    }, [\n        router.window,\n        reactDomFlushSyncImpl,\n        transition,\n        renderDfd\n    ]);\n    React3.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    React3.useEffect(()=>{\n        if (vtContext.isTransitioning && !vtContext.flushSync) {\n            setRenderDfd(new Deferred());\n        }\n    }, [\n        vtContext\n    ]);\n    React3.useEffect(()=>{\n        if (renderDfd && pendingState && router.window) {\n            let newState = pendingState;\n            let renderPromise = renderDfd.promise;\n            let transition2 = router.window.document.startViewTransition(async ()=>{\n                React3.startTransition(()=>setStateImpl(newState));\n                await renderPromise;\n            });\n            transition2.finished.finally(()=>{\n                setRenderDfd(void 0);\n                setTransition(void 0);\n                setPendingState(void 0);\n                setVtContext({\n                    isTransitioning: false\n                });\n            });\n            setTransition(transition2);\n        }\n    }, [\n        pendingState,\n        renderDfd,\n        router.window\n    ]);\n    React3.useEffect(()=>{\n        if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n            renderDfd.resolve();\n        }\n    }, [\n        renderDfd,\n        transition,\n        state.location,\n        pendingState\n    ]);\n    React3.useEffect(()=>{\n        if (!vtContext.isTransitioning && interruption) {\n            setPendingState(interruption.state);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: interruption.currentLocation,\n                nextLocation: interruption.nextLocation\n            });\n            setInterruption(void 0);\n        }\n    }, [\n        vtContext.isTransitioning,\n        interruption\n    ]);\n    let navigator = React3.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state2, opts)=>router.navigate(to, {\n                    state: state2,\n                    preventScrollReset: opts?.preventScrollReset\n                }),\n            replace: (to, state2, opts)=>router.navigate(to, {\n                    replace: true,\n                    state: state2,\n                    preventScrollReset: opts?.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = React3.useMemo(()=>({\n            router,\n            navigator,\n            static: false,\n            basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]);\n    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /* @__PURE__ */ React3.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /* @__PURE__ */ React3.createElement(FetchersContext.Provider, {\n        value: fetcherData.current\n    }, /* @__PURE__ */ React3.createElement(ViewTransitionContext.Provider, {\n        value: vtContext\n    }, /* @__PURE__ */ React3.createElement(Router, {\n        basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator\n    }, /* @__PURE__ */ React3.createElement(MemoizedDataRoutes, {\n        routes: router.routes,\n        future: router.future,\n        state\n    })))))), null);\n}\nvar MemoizedDataRoutes = React3.memo(DataRoutes);\nfunction DataRoutes({ routes, future, state }) {\n    return useRoutesImpl(routes, void 0, state, future);\n}\nfunction MemoryRouter({ basename, children, initialEntries, initialIndex }) {\n    let historyRef = React3.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = createMemoryHistory({\n            initialEntries,\n            initialIndex,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React3.useState({\n        action: history.action,\n        location: history.location\n    });\n    let setState = React3.useCallback((newState)=>{\n        React3.startTransition(()=>setStateImpl(newState));\n    }, [\n        setStateImpl\n    ]);\n    React3.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /* @__PURE__ */ React3.createElement(Router, {\n        basename,\n        children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nfunction Navigate({ to, replace: replace2, state, relative }) {\n    invariant(useInRouterContext(), // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`);\n    let { static: isStatic } = React3.useContext(NavigationContext);\n    warning(!isStatic, `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`);\n    let { matches } = React3.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let navigate = useNavigate();\n    let path = resolveTo(to, getResolveToMatches(matches), locationPathname, relative === \"path\");\n    let jsonPath = JSON.stringify(path);\n    React3.useEffect(()=>{\n        navigate(JSON.parse(jsonPath), {\n            replace: replace2,\n            state,\n            relative\n        });\n    }, [\n        navigate,\n        jsonPath,\n        relative,\n        replace2,\n        state\n    ]);\n    return null;\n}\nfunction Outlet(props) {\n    return useOutlet(props.context);\n}\nfunction Route(_props) {\n    invariant(false, `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`);\n}\nfunction Router({ basename: basenameProp = \"/\", children = null, location: locationProp, navigationType = \"POP\" /* Pop */ , navigator, static: staticProp = false }) {\n    invariant(!useInRouterContext(), `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`);\n    let basename = basenameProp.replace(/^\\/*/, \"/\");\n    let navigationContext = React3.useMemo(()=>({\n            basename,\n            navigator,\n            static: staticProp,\n            future: {}\n        }), [\n        basename,\n        navigator,\n        staticProp\n    ]);\n    if (typeof locationProp === \"string\") {\n        locationProp = parsePath(locationProp);\n    }\n    let { pathname = \"/\", search = \"\", hash = \"\", state = null, key = \"default\" } = locationProp;\n    let locationContext = React3.useMemo(()=>{\n        let trailingPathname = stripBasename(pathname, basename);\n        if (trailingPathname == null) {\n            return null;\n        }\n        return {\n            location: {\n                pathname: trailingPathname,\n                search,\n                hash,\n                state,\n                key\n            },\n            navigationType\n        };\n    }, [\n        basename,\n        pathname,\n        search,\n        hash,\n        state,\n        key,\n        navigationType\n    ]);\n    warning(locationContext != null, `<Router basename=\"${basename}\"> is not able to match the URL \"${pathname}${search}${hash}\" because it does not start with the basename, so the <Router> won't render anything.`);\n    if (locationContext == null) {\n        return null;\n    }\n    return /* @__PURE__ */ React3.createElement(NavigationContext.Provider, {\n        value: navigationContext\n    }, /* @__PURE__ */ React3.createElement(LocationContext.Provider, {\n        children,\n        value: locationContext\n    }));\n}\nfunction Routes({ children, location }) {\n    return useRoutes(createRoutesFromChildren(children), location);\n}\nfunction Await({ children, errorElement, resolve }) {\n    return /* @__PURE__ */ React3.createElement(AwaitErrorBoundary, {\n        resolve,\n        errorElement\n    }, /* @__PURE__ */ React3.createElement(ResolveAwait, null, children));\n}\nvar AwaitErrorBoundary = class extends React3.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            error: null\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        let { children, errorElement, resolve } = this.props;\n        let promise = null;\n        let status = 0 /* pending */ ;\n        if (!(resolve instanceof Promise)) {\n            status = 1 /* success */ ;\n            promise = Promise.resolve();\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_data\", {\n                get: ()=>resolve\n            });\n        } else if (this.state.error) {\n            status = 2 /* error */ ;\n            let renderError = this.state.error;\n            promise = Promise.reject().catch(()=>{});\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>renderError\n            });\n        } else if (resolve._tracked) {\n            promise = resolve;\n            status = \"_error\" in promise ? 2 /* error */  : \"_data\" in promise ? 1 /* success */  : 0 /* pending */ ;\n        } else {\n            status = 0 /* pending */ ;\n            Object.defineProperty(resolve, \"_tracked\", {\n                get: ()=>true\n            });\n            promise = resolve.then((data2)=>Object.defineProperty(resolve, \"_data\", {\n                    get: ()=>data2\n                }), (error)=>Object.defineProperty(resolve, \"_error\", {\n                    get: ()=>error\n                }));\n        }\n        if (status === 2 /* error */  && !errorElement) {\n            throw promise._error;\n        }\n        if (status === 2 /* error */ ) {\n            return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: errorElement\n            });\n        }\n        if (status === 1 /* success */ ) {\n            return /* @__PURE__ */ React3.createElement(AwaitContext.Provider, {\n                value: promise,\n                children\n            });\n        }\n        throw promise;\n    }\n};\nfunction ResolveAwait({ children }) {\n    let data2 = useAsyncValue();\n    let toRender = typeof children === \"function\" ? children(data2) : children;\n    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, toRender);\n}\nfunction createRoutesFromChildren(children, parentPath = []) {\n    let routes = [];\n    React3.Children.forEach(children, (element, index)=>{\n        if (!React3.isValidElement(element)) {\n            return;\n        }\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        if (element.type === React3.Fragment) {\n            routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n            return;\n        }\n        invariant(element.type === Route, `[${typeof element.type === \"string\" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`);\n        invariant(!element.props.index || !element.props.children, \"An index route cannot have child routes.\");\n        let route = {\n            id: element.props.id || treePath.join(\"-\"),\n            caseSensitive: element.props.caseSensitive,\n            element: element.props.element,\n            Component: element.props.Component,\n            index: element.props.index,\n            path: element.props.path,\n            loader: element.props.loader,\n            action: element.props.action,\n            hydrateFallbackElement: element.props.hydrateFallbackElement,\n            HydrateFallback: element.props.HydrateFallback,\n            errorElement: element.props.errorElement,\n            ErrorBoundary: element.props.ErrorBoundary,\n            hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,\n            shouldRevalidate: element.props.shouldRevalidate,\n            handle: element.props.handle,\n            lazy: element.props.lazy\n        };\n        if (element.props.children) {\n            route.children = createRoutesFromChildren(element.props.children, treePath);\n        }\n        routes.push(route);\n    });\n    return routes;\n}\nvar createRoutesFromElements = createRoutesFromChildren;\nfunction renderMatches(matches) {\n    return _renderMatches(matches);\n}\n// lib/dom/lib.tsx\nvar React10 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/dom/dom.ts\nvar defaultMethod = \"get\";\nvar defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n    return event.button === 0 && // Ignore everything but left clicks\n    (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event);\n}\nfunction createSearchParams(init = \"\") {\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key)=>{\n        let value = init[key];\n        return memo2.concat(Array.isArray(value) ? value.map((v)=>[\n                key,\n                v\n            ]) : [\n            [\n                key,\n                value\n            ]\n        ]);\n    }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    let searchParams = createSearchParams(locationSearch);\n    if (defaultSearchParams) {\n        defaultSearchParams.forEach((_, key)=>{\n            if (!searchParams.has(key)) {\n                defaultSearchParams.getAll(key).forEach((value)=>{\n                    searchParams.append(key, value);\n                });\n            }\n        });\n    }\n    return searchParams;\n}\nvar _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n    if (_formDataSupportsSubmitter === null) {\n        try {\n            new FormData(document.createElement(\"form\"), // @ts-expect-error if FormData supports the submitter parameter, this will throw\n            0);\n            _formDataSupportsSubmitter = false;\n        } catch (e) {\n            _formDataSupportsSubmitter = true;\n        }\n    }\n    return _formDataSupportsSubmitter;\n}\nvar supportedFormEncTypes = /* @__PURE__ */ new Set([\n    \"application/x-www-form-urlencoded\",\n    \"multipart/form-data\",\n    \"text/plain\"\n]);\nfunction getFormEncType(encType) {\n    if (encType != null && !supportedFormEncTypes.has(encType)) {\n        warning(false, `\"${encType}\" is not a valid \\`encType\\` for \\`<Form>\\`/\\`<fetcher.Form>\\` and will default to \"${defaultEncType}\"`);\n        return null;\n    }\n    return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    let body;\n    if (isFormElement(target)) {\n        let attr = target.getAttribute(\"action\");\n        action = attr ? stripBasename(attr, basename) : null;\n        method = target.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n        formData = new FormData(target);\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n        let form = target.form;\n        if (form == null) {\n            throw new Error(`Cannot submit a <button> or <input type=\"submit\"> without a <form>`);\n        }\n        let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n        action = attr ? stripBasename(attr, basename) : null;\n        method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n        formData = new FormData(form, target);\n        if (!isFormDataSubmitterSupported()) {\n            let { name, type, value } = target;\n            if (type === \"image\") {\n                let prefix = name ? `${name}.` : \"\";\n                formData.append(`${prefix}x`, \"0\");\n                formData.append(`${prefix}y`, \"0\");\n            } else if (name) {\n                formData.append(name, value);\n            }\n        }\n    } else if (isHtmlElement(target)) {\n        throw new Error(`Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">`);\n    } else {\n        method = defaultMethod;\n        action = null;\n        encType = defaultEncType;\n        body = target;\n    }\n    if (formData && encType === \"text/plain\") {\n        body = formData;\n        formData = void 0;\n    }\n    return {\n        action,\n        method: method.toLowerCase(),\n        encType,\n        formData,\n        body\n    };\n}\n// lib/dom/ssr/components.tsx\nvar React9 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/dom/ssr/invariant.ts\nfunction invariant2(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\n// lib/dom/ssr/routeModules.ts\nasync function loadRouteModule(route, routeModulesCache) {\n    if (route.id in routeModulesCache) {\n        return routeModulesCache[route.id];\n    }\n    try {\n        let routeModule = await import(/* @vite-ignore */ /* webpackIgnore: true */ route.module);\n        routeModulesCache[route.id] = routeModule;\n        return routeModule;\n    } catch (error) {\n        console.error(`Error loading route module \\`${route.module}\\`, reloading page...`);\n        console.error(error);\n        if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error\n        void 0) {\n            throw error;\n        }\n        window.location.reload();\n        return new Promise(()=>{});\n    }\n}\n// lib/dom/ssr/links.ts\nfunction getKeyedLinksForMatches(matches, routeModules, manifest) {\n    let descriptors = matches.map((match)=>{\n        let module2 = routeModules[match.route.id];\n        let route = manifest.routes[match.route.id];\n        return [\n            route && route.css ? route.css.map((href2)=>({\n                    rel: \"stylesheet\",\n                    href: href2\n                })) : [],\n            module2?.links?.() || []\n        ];\n    }).flat(2);\n    let preloads = getModuleLinkHrefs(matches, manifest);\n    return dedupeLinkDescriptors(descriptors, preloads);\n}\nfunction getRouteCssDescriptors(route) {\n    if (!route.css) return [];\n    return route.css.map((href2)=>({\n            rel: \"stylesheet\",\n            href: href2\n        }));\n}\nasync function prefetchRouteCss(route) {\n    if (!route.css) return;\n    let descriptors = getRouteCssDescriptors(route);\n    await Promise.all(descriptors.map(prefetchStyleLink));\n}\nasync function prefetchStyleLinks(route, routeModule) {\n    if (!route.css && !routeModule.links || !isPreloadSupported()) return;\n    let descriptors = [];\n    if (route.css) {\n        descriptors.push(...getRouteCssDescriptors(route));\n    }\n    if (routeModule.links) {\n        descriptors.push(...routeModule.links());\n    }\n    if (descriptors.length === 0) return;\n    let styleLinks = [];\n    for (let descriptor of descriptors){\n        if (!isPageLinkDescriptor(descriptor) && descriptor.rel === \"stylesheet\") {\n            styleLinks.push({\n                ...descriptor,\n                rel: \"preload\",\n                as: \"style\"\n            });\n        }\n    }\n    await Promise.all(styleLinks.map(prefetchStyleLink));\n}\nasync function prefetchStyleLink(descriptor) {\n    return new Promise((resolve)=>{\n        if (descriptor.media && !window.matchMedia(descriptor.media).matches || document.querySelector(`link[rel=\"stylesheet\"][href=\"${descriptor.href}\"]`)) {\n            return resolve();\n        }\n        let link = document.createElement(\"link\");\n        Object.assign(link, descriptor);\n        function removeLink() {\n            if (document.head.contains(link)) {\n                document.head.removeChild(link);\n            }\n        }\n        link.onload = ()=>{\n            removeLink();\n            resolve();\n        };\n        link.onerror = ()=>{\n            removeLink();\n            resolve();\n        };\n        document.head.appendChild(link);\n    });\n}\nfunction isPageLinkDescriptor(object) {\n    return object != null && typeof object.page === \"string\";\n}\nfunction isHtmlLinkDescriptor(object) {\n    if (object == null) {\n        return false;\n    }\n    if (object.href == null) {\n        return object.rel === \"preload\" && typeof object.imageSrcSet === \"string\" && typeof object.imageSizes === \"string\";\n    }\n    return typeof object.rel === \"string\" && typeof object.href === \"string\";\n}\nasync function getKeyedPrefetchLinks(matches, manifest, routeModules) {\n    let links = await Promise.all(matches.map(async (match)=>{\n        let route = manifest.routes[match.route.id];\n        if (route) {\n            let mod = await loadRouteModule(route, routeModules);\n            return mod.links ? mod.links() : [];\n        }\n        return [];\n    }));\n    return dedupeLinkDescriptors(links.flat(1).filter(isHtmlLinkDescriptor).filter((link)=>link.rel === \"stylesheet\" || link.rel === \"preload\").map((link)=>link.rel === \"stylesheet\" ? {\n            ...link,\n            rel: \"prefetch\",\n            as: \"style\"\n        } : {\n            ...link,\n            rel: \"prefetch\"\n        }));\n}\nfunction getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {\n    let isNew = (match, index)=>{\n        if (!currentMatches[index]) return true;\n        return match.route.id !== currentMatches[index].route.id;\n    };\n    let matchPathChanged = (match, index)=>{\n        return(// param change, /users/123 -> /users/456\n        currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path\n        // e.g. /files/images/avatar.jpg -> files/finances.xls\n        currentMatches[index].route.path?.endsWith(\"*\") && currentMatches[index].params[\"*\"] !== match.params[\"*\"]);\n    };\n    if (mode === \"assets\") {\n        return nextMatches.filter((match, index)=>isNew(match, index) || matchPathChanged(match, index));\n    }\n    if (mode === \"data\") {\n        return nextMatches.filter((match, index)=>{\n            let manifestRoute = manifest.routes[match.route.id];\n            if (!manifestRoute || !manifestRoute.hasLoader) {\n                return false;\n            }\n            if (isNew(match, index) || matchPathChanged(match, index)) {\n                return true;\n            }\n            if (match.route.shouldRevalidate) {\n                let routeChoice = match.route.shouldRevalidate({\n                    currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),\n                    currentParams: currentMatches[0]?.params || {},\n                    nextUrl: new URL(page, window.origin),\n                    nextParams: match.params,\n                    defaultShouldRevalidate: true\n                });\n                if (typeof routeChoice === \"boolean\") {\n                    return routeChoice;\n                }\n            }\n            return true;\n        });\n    }\n    return [];\n}\nfunction getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {\n    return dedupeHrefs(matches.map((match)=>{\n        let route = manifest.routes[match.route.id];\n        if (!route) return [];\n        let hrefs = [\n            route.module\n        ];\n        if (route.clientActionModule) {\n            hrefs = hrefs.concat(route.clientActionModule);\n        }\n        if (route.clientLoaderModule) {\n            hrefs = hrefs.concat(route.clientLoaderModule);\n        }\n        if (includeHydrateFallback && route.hydrateFallbackModule) {\n            hrefs = hrefs.concat(route.hydrateFallbackModule);\n        }\n        if (route.imports) {\n            hrefs = hrefs.concat(route.imports);\n        }\n        return hrefs;\n    }).flat(1));\n}\nfunction dedupeHrefs(hrefs) {\n    return [\n        ...new Set(hrefs)\n    ];\n}\nfunction sortKeys(obj) {\n    let sorted = {};\n    let keys = Object.keys(obj).sort();\n    for (let key of keys){\n        sorted[key] = obj[key];\n    }\n    return sorted;\n}\nfunction dedupeLinkDescriptors(descriptors, preloads) {\n    let set = /* @__PURE__ */ new Set();\n    let preloadsSet = new Set(preloads);\n    return descriptors.reduce((deduped, descriptor)=>{\n        let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === \"script\" && descriptor.href && preloadsSet.has(descriptor.href);\n        if (alreadyModulePreload) {\n            return deduped;\n        }\n        let key = JSON.stringify(sortKeys(descriptor));\n        if (!set.has(key)) {\n            set.add(key);\n            deduped.push({\n                key,\n                link: descriptor\n            });\n        }\n        return deduped;\n    }, []);\n}\nvar _isPreloadSupported;\nfunction isPreloadSupported() {\n    if (_isPreloadSupported !== void 0) {\n        return _isPreloadSupported;\n    }\n    let el = document.createElement(\"link\");\n    _isPreloadSupported = el.relList.supports(\"preload\");\n    el = null;\n    return _isPreloadSupported;\n}\n// lib/dom/ssr/markup.ts\nvar ESCAPE_LOOKUP = {\n    \"&\": \"\\\\u0026\",\n    \">\": \"\\\\u003e\",\n    \"<\": \"\\\\u003c\",\n    \"\\u2028\": \"\\\\u2028\",\n    \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml(html) {\n    return html.replace(ESCAPE_REGEX, (match)=>ESCAPE_LOOKUP[match]);\n}\nfunction createHtml(html) {\n    return {\n        __html: html\n    };\n}\n// lib/dom/ssr/single-fetch.tsx\nvar React4 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// vendor/turbo-stream-v2/utils.ts\nvar HOLE = -1;\nvar NAN = -2;\nvar NEGATIVE_INFINITY = -3;\nvar NEGATIVE_ZERO = -4;\nvar NULL = -5;\nvar POSITIVE_INFINITY = -6;\nvar UNDEFINED = -7;\nvar TYPE_BIGINT = \"B\";\nvar TYPE_DATE = \"D\";\nvar TYPE_ERROR = \"E\";\nvar TYPE_MAP = \"M\";\nvar TYPE_NULL_OBJECT = \"N\";\nvar TYPE_PROMISE = \"P\";\nvar TYPE_REGEXP = \"R\";\nvar TYPE_SET = \"S\";\nvar TYPE_SYMBOL = \"Y\";\nvar TYPE_URL = \"U\";\nvar TYPE_PREVIOUS_RESOLVED = \"Z\";\nvar Deferred2 = class {\n    constructor(){\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n};\nfunction createLineSplittingTransform() {\n    const decoder = new TextDecoder();\n    let leftover = \"\";\n    return new TransformStream({\n        transform (chunk, controller) {\n            const str = decoder.decode(chunk, {\n                stream: true\n            });\n            const parts = (leftover + str).split(\"\\n\");\n            leftover = parts.pop() || \"\";\n            for (const part of parts){\n                controller.enqueue(part);\n            }\n        },\n        flush (controller) {\n            if (leftover) {\n                controller.enqueue(leftover);\n            }\n        }\n    });\n}\n// vendor/turbo-stream-v2/flatten.ts\nfunction flatten(input) {\n    const { indices } = this;\n    const existing = indices.get(input);\n    if (existing) return [\n        existing\n    ];\n    if (input === void 0) return UNDEFINED;\n    if (input === null) return NULL;\n    if (Number.isNaN(input)) return NAN;\n    if (input === Number.POSITIVE_INFINITY) return POSITIVE_INFINITY;\n    if (input === Number.NEGATIVE_INFINITY) return NEGATIVE_INFINITY;\n    if (input === 0 && 1 / input < 0) return NEGATIVE_ZERO;\n    const index = this.index++;\n    indices.set(input, index);\n    stringify.call(this, input, index);\n    return index;\n}\nfunction stringify(input, index) {\n    const { deferred, plugins, postPlugins } = this;\n    const str = this.stringified;\n    const stack = [\n        [\n            input,\n            index\n        ]\n    ];\n    while(stack.length > 0){\n        const [input2, index2] = stack.pop();\n        const partsForObj = (obj)=>Object.keys(obj).map((k)=>`\"_${flatten.call(this, k)}\":${flatten.call(this, obj[k])}`).join(\",\");\n        let error = null;\n        switch(typeof input2){\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                str[index2] = JSON.stringify(input2);\n                break;\n            case \"bigint\":\n                str[index2] = `[\"${TYPE_BIGINT}\",\"${input2}\"]`;\n                break;\n            case \"symbol\":\n                {\n                    const keyFor = Symbol.keyFor(input2);\n                    if (!keyFor) {\n                        error = new Error(\"Cannot encode symbol unless created with Symbol.for()\");\n                    } else {\n                        str[index2] = `[\"${TYPE_SYMBOL}\",${JSON.stringify(keyFor)}]`;\n                    }\n                    break;\n                }\n            case \"object\":\n                {\n                    if (!input2) {\n                        str[index2] = `${NULL}`;\n                        break;\n                    }\n                    const isArray = Array.isArray(input2);\n                    let pluginHandled = false;\n                    if (!isArray && plugins) {\n                        for (const plugin of plugins){\n                            const pluginResult = plugin(input2);\n                            if (Array.isArray(pluginResult)) {\n                                pluginHandled = true;\n                                const [pluginIdentifier, ...rest] = pluginResult;\n                                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n                                if (rest.length > 0) {\n                                    str[index2] += `,${rest.map((v)=>flatten.call(this, v)).join(\",\")}`;\n                                }\n                                str[index2] += \"]\";\n                                break;\n                            }\n                        }\n                    }\n                    if (!pluginHandled) {\n                        let result = isArray ? \"[\" : \"{\";\n                        if (isArray) {\n                            for(let i = 0; i < input2.length; i++)result += (i ? \",\" : \"\") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);\n                            str[index2] = `${result}]`;\n                        } else if (input2 instanceof Date) {\n                            str[index2] = `[\"${TYPE_DATE}\",${input2.getTime()}]`;\n                        } else if (input2 instanceof URL) {\n                            str[index2] = `[\"${TYPE_URL}\",${JSON.stringify(input2.href)}]`;\n                        } else if (input2 instanceof RegExp) {\n                            str[index2] = `[\"${TYPE_REGEXP}\",${JSON.stringify(input2.source)},${JSON.stringify(input2.flags)}]`;\n                        } else if (input2 instanceof Set) {\n                            if (input2.size > 0) {\n                                str[index2] = `[\"${TYPE_SET}\",${[\n                                    ...input2\n                                ].map((val)=>flatten.call(this, val)).join(\",\")}]`;\n                            } else {\n                                str[index2] = `[\"${TYPE_SET}\"]`;\n                            }\n                        } else if (input2 instanceof Map) {\n                            if (input2.size > 0) {\n                                str[index2] = `[\"${TYPE_MAP}\",${[\n                                    ...input2\n                                ].flatMap(([k, v])=>[\n                                        flatten.call(this, k),\n                                        flatten.call(this, v)\n                                    ]).join(\",\")}]`;\n                            } else {\n                                str[index2] = `[\"${TYPE_MAP}\"]`;\n                            }\n                        } else if (input2 instanceof Promise) {\n                            str[index2] = `[\"${TYPE_PROMISE}\",${index2}]`;\n                            deferred[index2] = input2;\n                        } else if (input2 instanceof Error) {\n                            str[index2] = `[\"${TYPE_ERROR}\",${JSON.stringify(input2.message)}`;\n                            if (input2.name !== \"Error\") {\n                                str[index2] += `,${JSON.stringify(input2.name)}`;\n                            }\n                            str[index2] += \"]\";\n                        } else if (Object.getPrototypeOf(input2) === null) {\n                            str[index2] = `[\"${TYPE_NULL_OBJECT}\",{${partsForObj(input2)}}]`;\n                        } else if (isPlainObject(input2)) {\n                            str[index2] = `{${partsForObj(input2)}}`;\n                        } else {\n                            error = new Error(\"Cannot encode object with prototype\");\n                        }\n                    }\n                    break;\n                }\n            default:\n                {\n                    const isArray = Array.isArray(input2);\n                    let pluginHandled = false;\n                    if (!isArray && plugins) {\n                        for (const plugin of plugins){\n                            const pluginResult = plugin(input2);\n                            if (Array.isArray(pluginResult)) {\n                                pluginHandled = true;\n                                const [pluginIdentifier, ...rest] = pluginResult;\n                                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n                                if (rest.length > 0) {\n                                    str[index2] += `,${rest.map((v)=>flatten.call(this, v)).join(\",\")}`;\n                                }\n                                str[index2] += \"]\";\n                                break;\n                            }\n                        }\n                    }\n                    if (!pluginHandled) {\n                        error = new Error(\"Cannot encode function or unexpected type\");\n                    }\n                }\n        }\n        if (error) {\n            let pluginHandled = false;\n            if (postPlugins) {\n                for (const plugin of postPlugins){\n                    const pluginResult = plugin(input2);\n                    if (Array.isArray(pluginResult)) {\n                        pluginHandled = true;\n                        const [pluginIdentifier, ...rest] = pluginResult;\n                        str[index2] = `[${JSON.stringify(pluginIdentifier)}`;\n                        if (rest.length > 0) {\n                            str[index2] += `,${rest.map((v)=>flatten.call(this, v)).join(\",\")}`;\n                        }\n                        str[index2] += \"]\";\n                        break;\n                    }\n                }\n            }\n            if (!pluginHandled) {\n                throw error;\n            }\n        }\n    }\n}\nvar objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join(\"\\x00\");\nfunction isPlainObject(thing) {\n    const proto = Object.getPrototypeOf(thing);\n    return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join(\"\\x00\") === objectProtoNames;\n}\n// vendor/turbo-stream-v2/unflatten.ts\nvar globalObj =  false ? 0 : typeof globalThis !== \"undefined\" ? globalThis : void 0;\nfunction unflatten(parsed) {\n    const { hydrated, values } = this;\n    if (typeof parsed === \"number\") return hydrate.call(this, parsed);\n    if (!Array.isArray(parsed) || !parsed.length) throw new SyntaxError();\n    const startIndex = values.length;\n    for (const value of parsed){\n        values.push(value);\n    }\n    hydrated.length = values.length;\n    return hydrate.call(this, startIndex);\n}\nfunction hydrate(index) {\n    const { hydrated, values, deferred, plugins } = this;\n    let result;\n    const stack = [\n        [\n            index,\n            (v)=>{\n                result = v;\n            }\n        ]\n    ];\n    let postRun = [];\n    while(stack.length > 0){\n        const [index2, set] = stack.pop();\n        switch(index2){\n            case UNDEFINED:\n                set(void 0);\n                continue;\n            case NULL:\n                set(null);\n                continue;\n            case NAN:\n                set(NaN);\n                continue;\n            case POSITIVE_INFINITY:\n                set(Infinity);\n                continue;\n            case NEGATIVE_INFINITY:\n                set(-Infinity);\n                continue;\n            case NEGATIVE_ZERO:\n                set(-0);\n                continue;\n        }\n        if (hydrated[index2]) {\n            set(hydrated[index2]);\n            continue;\n        }\n        const value = values[index2];\n        if (!value || typeof value !== \"object\") {\n            hydrated[index2] = value;\n            set(value);\n            continue;\n        }\n        if (Array.isArray(value)) {\n            if (typeof value[0] === \"string\") {\n                const [type, b, c] = value;\n                switch(type){\n                    case TYPE_DATE:\n                        set(hydrated[index2] = new Date(b));\n                        continue;\n                    case TYPE_URL:\n                        set(hydrated[index2] = new URL(b));\n                        continue;\n                    case TYPE_BIGINT:\n                        set(hydrated[index2] = BigInt(b));\n                        continue;\n                    case TYPE_REGEXP:\n                        set(hydrated[index2] = new RegExp(b, c));\n                        continue;\n                    case TYPE_SYMBOL:\n                        set(hydrated[index2] = Symbol.for(b));\n                        continue;\n                    case TYPE_SET:\n                        const newSet = /* @__PURE__ */ new Set();\n                        hydrated[index2] = newSet;\n                        for(let i = value.length - 1; i > 0; i--)stack.push([\n                            value[i],\n                            (v)=>{\n                                newSet.add(v);\n                            }\n                        ]);\n                        set(newSet);\n                        continue;\n                    case TYPE_MAP:\n                        const map = /* @__PURE__ */ new Map();\n                        hydrated[index2] = map;\n                        for(let i = value.length - 2; i > 0; i -= 2){\n                            const r = [];\n                            stack.push([\n                                value[i + 1],\n                                (v)=>{\n                                    r[1] = v;\n                                }\n                            ]);\n                            stack.push([\n                                value[i],\n                                (k)=>{\n                                    r[0] = k;\n                                }\n                            ]);\n                            postRun.push(()=>{\n                                map.set(r[0], r[1]);\n                            });\n                        }\n                        set(map);\n                        continue;\n                    case TYPE_NULL_OBJECT:\n                        const obj = /* @__PURE__ */ Object.create(null);\n                        hydrated[index2] = obj;\n                        for (const key of Object.keys(b).reverse()){\n                            const r = [];\n                            stack.push([\n                                b[key],\n                                (v)=>{\n                                    r[1] = v;\n                                }\n                            ]);\n                            stack.push([\n                                Number(key.slice(1)),\n                                (k)=>{\n                                    r[0] = k;\n                                }\n                            ]);\n                            postRun.push(()=>{\n                                obj[r[0]] = r[1];\n                            });\n                        }\n                        set(obj);\n                        continue;\n                    case TYPE_PROMISE:\n                        if (hydrated[b]) {\n                            set(hydrated[index2] = hydrated[b]);\n                        } else {\n                            const d = new Deferred2();\n                            deferred[b] = d;\n                            set(hydrated[index2] = d.promise);\n                        }\n                        continue;\n                    case TYPE_ERROR:\n                        const [, message, errorType] = value;\n                        let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);\n                        hydrated[index2] = error;\n                        set(error);\n                        continue;\n                    case TYPE_PREVIOUS_RESOLVED:\n                        set(hydrated[index2] = hydrated[b]);\n                        continue;\n                    default:\n                        if (Array.isArray(plugins)) {\n                            const r = [];\n                            const vals = value.slice(1);\n                            for(let i = 0; i < vals.length; i++){\n                                const v = vals[i];\n                                stack.push([\n                                    v,\n                                    (v2)=>{\n                                        r[i] = v2;\n                                    }\n                                ]);\n                            }\n                            postRun.push(()=>{\n                                for (const plugin of plugins){\n                                    const result2 = plugin(value[0], ...r);\n                                    if (result2) {\n                                        set(hydrated[index2] = result2.value);\n                                        return;\n                                    }\n                                }\n                                throw new SyntaxError();\n                            });\n                            continue;\n                        }\n                        throw new SyntaxError();\n                }\n            } else {\n                const array = [];\n                hydrated[index2] = array;\n                for(let i = 0; i < value.length; i++){\n                    const n = value[i];\n                    if (n !== HOLE) {\n                        stack.push([\n                            n,\n                            (v)=>{\n                                array[i] = v;\n                            }\n                        ]);\n                    }\n                }\n                set(array);\n                continue;\n            }\n        } else {\n            const object = {};\n            hydrated[index2] = object;\n            for (const key of Object.keys(value).reverse()){\n                const r = [];\n                stack.push([\n                    value[key],\n                    (v)=>{\n                        r[1] = v;\n                    }\n                ]);\n                stack.push([\n                    Number(key.slice(1)),\n                    (k)=>{\n                        r[0] = k;\n                    }\n                ]);\n                postRun.push(()=>{\n                    object[r[0]] = r[1];\n                });\n            }\n            set(object);\n            continue;\n        }\n    }\n    while(postRun.length > 0){\n        postRun.pop()();\n    }\n    return result;\n}\n// vendor/turbo-stream-v2/turbo-stream.ts\nasync function decode(readable, options) {\n    const { plugins } = options ?? {};\n    const done = new Deferred2();\n    const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();\n    const decoder = {\n        values: [],\n        hydrated: [],\n        deferred: {},\n        plugins\n    };\n    const decoded = await decodeInitial.call(decoder, reader);\n    let donePromise = done.promise;\n    if (decoded.done) {\n        done.resolve();\n    } else {\n        donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch((reason)=>{\n            for (const deferred of Object.values(decoder.deferred)){\n                deferred.reject(reason);\n            }\n            done.reject(reason);\n        });\n    }\n    return {\n        done: donePromise.then(()=>reader.closed),\n        value: decoded.value\n    };\n}\nasync function decodeInitial(reader) {\n    const read = await reader.read();\n    if (!read.value) {\n        throw new SyntaxError();\n    }\n    let line;\n    try {\n        line = JSON.parse(read.value);\n    } catch (reason) {\n        throw new SyntaxError();\n    }\n    return {\n        done: read.done,\n        value: unflatten.call(this, line)\n    };\n}\nasync function decodeDeferred(reader) {\n    let read = await reader.read();\n    while(!read.done){\n        if (!read.value) continue;\n        const line = read.value;\n        switch(line[0]){\n            case TYPE_PROMISE:\n                {\n                    const colonIndex = line.indexOf(\":\");\n                    const deferredId = Number(line.slice(1, colonIndex));\n                    const deferred = this.deferred[deferredId];\n                    if (!deferred) {\n                        throw new Error(`Deferred ID ${deferredId} not found in stream`);\n                    }\n                    const lineData = line.slice(colonIndex + 1);\n                    let jsonLine;\n                    try {\n                        jsonLine = JSON.parse(lineData);\n                    } catch (reason) {\n                        throw new SyntaxError();\n                    }\n                    const value = unflatten.call(this, jsonLine);\n                    deferred.resolve(value);\n                    break;\n                }\n            case TYPE_ERROR:\n                {\n                    const colonIndex = line.indexOf(\":\");\n                    const deferredId = Number(line.slice(1, colonIndex));\n                    const deferred = this.deferred[deferredId];\n                    if (!deferred) {\n                        throw new Error(`Deferred ID ${deferredId} not found in stream`);\n                    }\n                    const lineData = line.slice(colonIndex + 1);\n                    let jsonLine;\n                    try {\n                        jsonLine = JSON.parse(lineData);\n                    } catch (reason) {\n                        throw new SyntaxError();\n                    }\n                    const value = unflatten.call(this, jsonLine);\n                    deferred.reject(value);\n                    break;\n                }\n            default:\n                throw new SyntaxError();\n        }\n        read = await reader.read();\n    }\n}\nfunction encode(input, options) {\n    const { plugins, postPlugins, signal } = options ?? {};\n    const encoder2 = {\n        deferred: {},\n        index: 0,\n        indices: /* @__PURE__ */ new Map(),\n        stringified: [],\n        plugins,\n        postPlugins,\n        signal\n    };\n    const textEncoder = new TextEncoder();\n    let lastSentIndex = 0;\n    const readable = new ReadableStream({\n        async start (controller) {\n            const id = flatten.call(encoder2, input);\n            if (Array.isArray(id)) {\n                throw new Error(\"This should never happen\");\n            }\n            if (id < 0) {\n                controller.enqueue(textEncoder.encode(`${id}\n`));\n            } else {\n                controller.enqueue(textEncoder.encode(`[${encoder2.stringified.join(\",\")}]\n`));\n                lastSentIndex = encoder2.stringified.length - 1;\n            }\n            const seenPromises = /* @__PURE__ */ new WeakSet();\n            if (Object.keys(encoder2.deferred).length) {\n                let raceDone;\n                const racePromise = new Promise((resolve, reject)=>{\n                    raceDone = resolve;\n                    if (signal) {\n                        const rejectPromise = ()=>reject(signal.reason || new Error(\"Signal was aborted.\"));\n                        if (signal.aborted) {\n                            rejectPromise();\n                        } else {\n                            signal.addEventListener(\"abort\", (event)=>{\n                                rejectPromise();\n                            });\n                        }\n                    }\n                });\n                while(Object.keys(encoder2.deferred).length > 0){\n                    for (const [deferredId, deferred] of Object.entries(encoder2.deferred)){\n                        if (seenPromises.has(deferred)) continue;\n                        seenPromises.add(// biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n                        encoder2.deferred[Number(deferredId)] = Promise.race([\n                            racePromise,\n                            deferred\n                        ]).then((resolved)=>{\n                            const id2 = flatten.call(encoder2, resolved);\n                            if (Array.isArray(id2)) {\n                                controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`));\n                                encoder2.index++;\n                                lastSentIndex++;\n                            } else if (id2 < 0) {\n                                controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}\n`));\n                            } else {\n                                const values = encoder2.stringified.slice(lastSentIndex + 1).join(\",\");\n                                controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[${values}]\n`));\n                                lastSentIndex = encoder2.stringified.length - 1;\n                            }\n                        }, (reason)=>{\n                            if (!reason || typeof reason !== \"object\" || !(reason instanceof Error)) {\n                                reason = new Error(\"An unknown error occurred\");\n                            }\n                            const id2 = flatten.call(encoder2, reason);\n                            if (Array.isArray(id2)) {\n                                controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[[\"${TYPE_PREVIOUS_RESOLVED}\",${id2[0]}]]\n`));\n                                encoder2.index++;\n                                lastSentIndex++;\n                            } else if (id2 < 0) {\n                                controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}\n`));\n                            } else {\n                                const values = encoder2.stringified.slice(lastSentIndex + 1).join(\",\");\n                                controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[${values}]\n`));\n                                lastSentIndex = encoder2.stringified.length - 1;\n                            }\n                        }).finally(()=>{\n                            delete encoder2.deferred[Number(deferredId)];\n                        }));\n                    }\n                    await Promise.race(Object.values(encoder2.deferred));\n                }\n                raceDone();\n            }\n            await Promise.all(Object.values(encoder2.deferred));\n            controller.close();\n        }\n    });\n    return readable;\n}\n// lib/dom/ssr/data.ts\nasync function createRequestInit(request) {\n    let init = {\n        signal: request.signal\n    };\n    if (request.method !== \"GET\") {\n        init.method = request.method;\n        let contentType = request.headers.get(\"Content-Type\");\n        if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n            init.headers = {\n                \"Content-Type\": contentType\n            };\n            init.body = JSON.stringify(await request.json());\n        } else if (contentType && /\\btext\\/plain\\b/.test(contentType)) {\n            init.headers = {\n                \"Content-Type\": contentType\n            };\n            init.body = await request.text();\n        } else if (contentType && /\\bapplication\\/x-www-form-urlencoded\\b/.test(contentType)) {\n            init.body = new URLSearchParams(await request.text());\n        } else {\n            init.body = await request.formData();\n        }\n    }\n    return init;\n}\n// lib/dom/ssr/single-fetch.tsx\nvar SingleFetchRedirectSymbol = Symbol(\"SingleFetchRedirect\");\nvar SingleFetchNoResultError = class extends Error {\n};\nvar SINGLE_FETCH_REDIRECT_STATUS = 202;\nvar NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([\n    100,\n    101,\n    204,\n    205\n]);\nfunction StreamTransfer({ context, identifier, reader, textDecoder, nonce }) {\n    if (!context.renderMeta || !context.renderMeta.didRenderScripts) {\n        return null;\n    }\n    if (!context.renderMeta.streamCache) {\n        context.renderMeta.streamCache = {};\n    }\n    let { streamCache } = context.renderMeta;\n    let promise = streamCache[identifier];\n    if (!promise) {\n        promise = streamCache[identifier] = reader.read().then((result)=>{\n            streamCache[identifier].result = {\n                done: result.done,\n                value: textDecoder.decode(result.value, {\n                    stream: true\n                })\n            };\n        }).catch((e)=>{\n            streamCache[identifier].error = e;\n        });\n    }\n    if (promise.error) {\n        throw promise.error;\n    }\n    if (promise.result === void 0) {\n        throw promise;\n    }\n    let { done, value } = promise.result;\n    let scriptTag = value ? /* @__PURE__ */ React4.createElement(\"script\", {\n        nonce,\n        dangerouslySetInnerHTML: {\n            __html: `window.__reactRouterContext.streamController.enqueue(${escapeHtml(JSON.stringify(value))});`\n        }\n    }) : null;\n    if (done) {\n        return /* @__PURE__ */ React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */ React4.createElement(\"script\", {\n            nonce,\n            dangerouslySetInnerHTML: {\n                __html: `window.__reactRouterContext.streamController.close();`\n            }\n        }));\n    } else {\n        return /* @__PURE__ */ React4.createElement(React4.Fragment, null, scriptTag, /* @__PURE__ */ React4.createElement(React4.Suspense, null, /* @__PURE__ */ React4.createElement(StreamTransfer, {\n            context,\n            identifier: identifier + 1,\n            reader,\n            textDecoder,\n            nonce\n        })));\n    }\n}\nfunction getTurboStreamSingleFetchDataStrategy(getRouter, manifest, routeModules, ssr, basename) {\n    let dataStrategy = getSingleFetchDataStrategyImpl(getRouter, (match)=>{\n        let manifestRoute = manifest.routes[match.route.id];\n        invariant2(manifestRoute, \"Route not found in manifest\");\n        let routeModule = routeModules[match.route.id];\n        return {\n            hasLoader: manifestRoute.hasLoader,\n            hasClientLoader: manifestRoute.hasClientLoader,\n            hasShouldRevalidate: Boolean(routeModule?.shouldRevalidate)\n        };\n    }, fetchAndDecodeViaTurboStream, ssr, basename);\n    return async (args)=>args.unstable_runClientMiddleware(dataStrategy);\n}\nfunction getSingleFetchDataStrategyImpl(getRouter, getRouteInfo, fetchAndDecode, ssr, basename) {\n    return async (args)=>{\n        let { request, matches, fetcherKey } = args;\n        let router = getRouter();\n        if (request.method !== \"GET\") {\n            return singleFetchActionStrategy(args, fetchAndDecode, basename);\n        }\n        let foundRevalidatingServerLoader = matches.some((m)=>{\n            let { hasLoader, hasClientLoader } = getRouteInfo(m);\n            return m.unstable_shouldCallHandler() && hasLoader && !hasClientLoader;\n        });\n        if (!ssr && !foundRevalidatingServerLoader) {\n            return nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename);\n        }\n        if (fetcherKey) {\n            return singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename);\n        }\n        return singleFetchLoaderNavigationStrategy(args, router, getRouteInfo, fetchAndDecode, ssr, basename);\n    };\n}\nasync function singleFetchActionStrategy(args, fetchAndDecode, basename) {\n    let actionMatch = args.matches.find((m)=>m.unstable_shouldCallHandler());\n    invariant2(actionMatch, \"No action match found\");\n    let actionStatus = void 0;\n    let result = await actionMatch.resolve(async (handler)=>{\n        let result2 = await handler(async ()=>{\n            let { data: data2, status } = await fetchAndDecode(args, basename, [\n                actionMatch.route.id\n            ]);\n            actionStatus = status;\n            return unwrapSingleFetchResult(data2, actionMatch.route.id);\n        });\n        return result2;\n    });\n    if (isResponse(result.result) || isRouteErrorResponse(result.result) || isDataWithResponseInit(result.result)) {\n        return {\n            [actionMatch.route.id]: result\n        };\n    }\n    return {\n        [actionMatch.route.id]: {\n            type: result.type,\n            result: data(result.result, actionStatus)\n        }\n    };\n}\nasync function nonSsrStrategy(args, getRouteInfo, fetchAndDecode, basename) {\n    let matchesToLoad = args.matches.filter((m)=>m.unstable_shouldCallHandler());\n    let results = {};\n    await Promise.all(matchesToLoad.map((m)=>m.resolve(async (handler)=>{\n            try {\n                let { hasClientLoader } = getRouteInfo(m);\n                let routeId = m.route.id;\n                let result = hasClientLoader ? await handler(async ()=>{\n                    let { data: data2 } = await fetchAndDecode(args, basename, [\n                        routeId\n                    ]);\n                    return unwrapSingleFetchResult(data2, routeId);\n                }) : await handler();\n                results[m.route.id] = {\n                    type: \"data\",\n                    result\n                };\n            } catch (e) {\n                results[m.route.id] = {\n                    type: \"error\",\n                    result: e\n                };\n            }\n        })));\n    return results;\n}\nasync function singleFetchLoaderNavigationStrategy(args, router, getRouteInfo, fetchAndDecode, ssr, basename) {\n    let routesParams = /* @__PURE__ */ new Set();\n    let foundOptOutRoute = false;\n    let routeDfds = args.matches.map(()=>createDeferred2());\n    let singleFetchDfd = createDeferred2();\n    let results = {};\n    let resolvePromise = Promise.all(args.matches.map(async (m, i)=>m.resolve(async (handler)=>{\n            routeDfds[i].resolve();\n            let routeId = m.route.id;\n            let { hasLoader, hasClientLoader, hasShouldRevalidate } = getRouteInfo(m);\n            let defaultShouldRevalidate = !m.unstable_shouldRevalidateArgs || m.unstable_shouldRevalidateArgs.actionStatus == null || m.unstable_shouldRevalidateArgs.actionStatus < 400;\n            let shouldCall = m.unstable_shouldCallHandler(defaultShouldRevalidate);\n            if (!shouldCall) {\n                foundOptOutRoute || (foundOptOutRoute = m.unstable_shouldRevalidateArgs != null && // This is a revalidation,\n                hasLoader && // for a route with a server loader,\n                hasShouldRevalidate === true);\n                return;\n            }\n            if (hasClientLoader) {\n                if (hasLoader) {\n                    foundOptOutRoute = true;\n                }\n                try {\n                    let result = await handler(async ()=>{\n                        let { data: data2 } = await fetchAndDecode(args, basename, [\n                            routeId\n                        ]);\n                        return unwrapSingleFetchResult(data2, routeId);\n                    });\n                    results[routeId] = {\n                        type: \"data\",\n                        result\n                    };\n                } catch (e) {\n                    results[routeId] = {\n                        type: \"error\",\n                        result: e\n                    };\n                }\n                return;\n            }\n            if (hasLoader) {\n                routesParams.add(routeId);\n            }\n            try {\n                let result = await handler(async ()=>{\n                    let data2 = await singleFetchDfd.promise;\n                    return unwrapSingleFetchResult(data2, routeId);\n                });\n                results[routeId] = {\n                    type: \"data\",\n                    result\n                };\n            } catch (e) {\n                results[routeId] = {\n                    type: \"error\",\n                    result: e\n                };\n            }\n        })));\n    await Promise.all(routeDfds.map((d)=>d.promise));\n    let isInitialLoad = !router.state.initialized && router.state.navigation.state === \"idle\";\n    if ((isInitialLoad || routesParams.size === 0) && !window.__reactRouterHdrActive) {\n        singleFetchDfd.resolve({\n            routes: {}\n        });\n    } else {\n        let targetRoutes = ssr && foundOptOutRoute && routesParams.size > 0 ? [\n            ...routesParams.keys()\n        ] : void 0;\n        try {\n            let data2 = await fetchAndDecode(args, basename, targetRoutes);\n            singleFetchDfd.resolve(data2.data);\n        } catch (e) {\n            singleFetchDfd.reject(e);\n        }\n    }\n    await resolvePromise;\n    await bubbleMiddlewareErrors(singleFetchDfd.promise, args.matches, routesParams, results);\n    return results;\n}\nasync function bubbleMiddlewareErrors(singleFetchPromise, matches, routesParams, results) {\n    try {\n        let middlewareError;\n        let fetchedData = await singleFetchPromise;\n        if (\"routes\" in fetchedData) {\n            for (let match of matches){\n                if (match.route.id in fetchedData.routes) {\n                    let routeResult = fetchedData.routes[match.route.id];\n                    if (\"error\" in routeResult) {\n                        middlewareError = routeResult.error;\n                        break;\n                    }\n                }\n            }\n        }\n        if (middlewareError !== void 0) {\n            Array.from(routesParams.values()).forEach((routeId)=>{\n                if (results[routeId].result instanceof SingleFetchNoResultError) {\n                    results[routeId].result = middlewareError;\n                }\n            });\n        }\n    } catch (e) {}\n}\nasync function singleFetchLoaderFetcherStrategy(args, fetchAndDecode, basename) {\n    let fetcherMatch = args.matches.find((m)=>m.unstable_shouldCallHandler());\n    invariant2(fetcherMatch, \"No fetcher match found\");\n    let routeId = fetcherMatch.route.id;\n    let result = await fetcherMatch.resolve(async (handler)=>handler(async ()=>{\n            let { data: data2 } = await fetchAndDecode(args, basename, [\n                routeId\n            ]);\n            return unwrapSingleFetchResult(data2, routeId);\n        }));\n    return {\n        [fetcherMatch.route.id]: result\n    };\n}\nfunction stripIndexParam(url) {\n    let indexValues = url.searchParams.getAll(\"index\");\n    url.searchParams.delete(\"index\");\n    let indexValuesToKeep = [];\n    for (let indexValue of indexValues){\n        if (indexValue) {\n            indexValuesToKeep.push(indexValue);\n        }\n    }\n    for (let toKeep of indexValuesToKeep){\n        url.searchParams.append(\"index\", toKeep);\n    }\n    return url;\n}\nfunction singleFetchUrl(reqUrl, basename) {\n    let url = typeof reqUrl === \"string\" ? new URL(reqUrl, // This can be called during the SSR flow via PrefetchPageLinksImpl so\n    // don't assume window is available\n     true ? \"server://singlefetch/\" : 0) : reqUrl;\n    if (url.pathname === \"/\") {\n        url.pathname = \"_root.data\";\n    } else if (basename && stripBasename(url.pathname, basename) === \"/\") {\n        url.pathname = `${basename.replace(/\\/$/, \"\")}/_root.data`;\n    } else {\n        url.pathname = `${url.pathname.replace(/\\/$/, \"\")}.data`;\n    }\n    return url;\n}\nasync function fetchAndDecodeViaTurboStream(args, basename, targetRoutes) {\n    let { request } = args;\n    let url = singleFetchUrl(request.url, basename);\n    if (request.method === \"GET\") {\n        url = stripIndexParam(url);\n        if (targetRoutes) {\n            url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\n        }\n    }\n    let res = await fetch(url, await createRequestInit(request));\n    if (res.status === 404 && !res.headers.has(\"X-Remix-Response\")) {\n        throw new ErrorResponseImpl(404, \"Not Found\", true);\n    }\n    if (res.status === 204 && res.headers.has(\"X-Remix-Redirect\")) {\n        return {\n            status: SINGLE_FETCH_REDIRECT_STATUS,\n            data: {\n                redirect: {\n                    redirect: res.headers.get(\"X-Remix-Redirect\"),\n                    status: Number(res.headers.get(\"X-Remix-Status\") || \"302\"),\n                    revalidate: res.headers.get(\"X-Remix-Revalidate\") === \"true\",\n                    reload: res.headers.get(\"X-Remix-Reload-Document\") === \"true\",\n                    replace: res.headers.get(\"X-Remix-Replace\") === \"true\"\n                }\n            }\n        };\n    }\n    if (NO_BODY_STATUS_CODES.has(res.status)) {\n        let routes = {};\n        if (targetRoutes && request.method !== \"GET\") {\n            routes[targetRoutes[0]] = {\n                data: void 0\n            };\n        }\n        return {\n            status: res.status,\n            data: {\n                routes\n            }\n        };\n    }\n    invariant2(res.body, \"No response body to decode\");\n    try {\n        let decoded = await decodeViaTurboStream(res.body, window);\n        let data2;\n        if (request.method === \"GET\") {\n            let typed = decoded.value;\n            if (SingleFetchRedirectSymbol in typed) {\n                data2 = {\n                    redirect: typed[SingleFetchRedirectSymbol]\n                };\n            } else {\n                data2 = {\n                    routes: typed\n                };\n            }\n        } else {\n            let typed = decoded.value;\n            let routeId = targetRoutes?.[0];\n            invariant2(routeId, \"No routeId found for single fetch call decoding\");\n            if (\"redirect\" in typed) {\n                data2 = {\n                    redirect: typed\n                };\n            } else {\n                data2 = {\n                    routes: {\n                        [routeId]: typed\n                    }\n                };\n            }\n        }\n        return {\n            status: res.status,\n            data: data2\n        };\n    } catch (e) {\n        throw new Error(\"Unable to decode turbo-stream response\");\n    }\n}\nfunction decodeViaTurboStream(body, global2) {\n    return decode(body, {\n        plugins: [\n            (type, ...rest)=>{\n                if (type === \"SanitizedError\") {\n                    let [name, message, stack] = rest;\n                    let Constructor = Error;\n                    if (name && name in global2 && typeof global2[name] === \"function\") {\n                        Constructor = global2[name];\n                    }\n                    let error = new Constructor(message);\n                    error.stack = stack;\n                    return {\n                        value: error\n                    };\n                }\n                if (type === \"ErrorResponse\") {\n                    let [data2, status, statusText] = rest;\n                    return {\n                        value: new ErrorResponseImpl(status, statusText, data2)\n                    };\n                }\n                if (type === \"SingleFetchRedirect\") {\n                    return {\n                        value: {\n                            [SingleFetchRedirectSymbol]: rest[0]\n                        }\n                    };\n                }\n                if (type === \"SingleFetchClassInstance\") {\n                    return {\n                        value: rest[0]\n                    };\n                }\n                if (type === \"SingleFetchFallback\") {\n                    return {\n                        value: void 0\n                    };\n                }\n            }\n        ]\n    });\n}\nfunction unwrapSingleFetchResult(result, routeId) {\n    if (\"redirect\" in result) {\n        let { redirect: location, revalidate, reload, replace: replace2, status } = result.redirect;\n        throw redirect(location, {\n            status,\n            headers: {\n                // Three R's of redirecting (lol Veep)\n                ...revalidate ? {\n                    \"X-Remix-Revalidate\": \"yes\"\n                } : null,\n                ...reload ? {\n                    \"X-Remix-Reload-Document\": \"yes\"\n                } : null,\n                ...replace2 ? {\n                    \"X-Remix-Replace\": \"yes\"\n                } : null\n            }\n        });\n    }\n    let routeResult = result.routes[routeId];\n    if (routeResult == null) {\n        throw new SingleFetchNoResultError(`No result found for routeId \"${routeId}\"`);\n    } else if (\"error\" in routeResult) {\n        throw routeResult.error;\n    } else if (\"data\" in routeResult) {\n        return routeResult.data;\n    } else {\n        throw new Error(`Invalid response found for routeId \"${routeId}\"`);\n    }\n}\nfunction createDeferred2() {\n    let resolve;\n    let reject;\n    let promise = new Promise((res, rej)=>{\n        resolve = async (val)=>{\n            res(val);\n            try {\n                await promise;\n            } catch (e) {}\n        };\n        reject = async (error)=>{\n            rej(error);\n            try {\n                await promise;\n            } catch (e) {}\n        };\n    });\n    return {\n        promise,\n        //@ts-ignore\n        resolve,\n        //@ts-ignore\n        reject\n    };\n}\n// lib/dom/ssr/fog-of-war.ts\nvar React8 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/dom/ssr/routes.tsx\nvar React7 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n// lib/dom/ssr/errorBoundaries.tsx\nvar React5 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar RemixErrorBoundary = class extends React5.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            error: props.error || null,\n            location: props.location\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        if (state.location !== props.location) {\n            return {\n                error: props.error || null,\n                location: props.location\n            };\n        }\n        return {\n            error: props.error || state.error,\n            location: state.location\n        };\n    }\n    render() {\n        if (this.state.error) {\n            return /* @__PURE__ */ React5.createElement(RemixRootDefaultErrorBoundary, {\n                error: this.state.error,\n                isOutsideRemixApp: true\n            });\n        } else {\n            return this.props.children;\n        }\n    }\n};\nfunction RemixRootDefaultErrorBoundary({ error, isOutsideRemixApp }) {\n    console.error(error);\n    let heyDeveloper = /* @__PURE__ */ React5.createElement(\"script\", {\n        dangerouslySetInnerHTML: {\n            __html: `\n        console.log(\n          \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information.\"\n        );\n      `\n        }\n    });\n    if (isRouteErrorResponse(error)) {\n        return /* @__PURE__ */ React5.createElement(BoundaryShell, {\n            title: \"Unhandled Thrown Response!\"\n        }, /* @__PURE__ */ React5.createElement(\"h1\", {\n            style: {\n                fontSize: \"24px\"\n            }\n        }, error.status, \" \", error.statusText), ENABLE_DEV_WARNINGS ? heyDeveloper : null);\n    }\n    let errorInstance;\n    if (error instanceof Error) {\n        errorInstance = error;\n    } else {\n        let errorString = error == null ? \"Unknown Error\" : typeof error === \"object\" && \"toString\" in error ? error.toString() : JSON.stringify(error);\n        errorInstance = new Error(errorString);\n    }\n    return /* @__PURE__ */ React5.createElement(BoundaryShell, {\n        title: \"Application Error!\",\n        isOutsideRemixApp\n    }, /* @__PURE__ */ React5.createElement(\"h1\", {\n        style: {\n            fontSize: \"24px\"\n        }\n    }, \"Application Error\"), /* @__PURE__ */ React5.createElement(\"pre\", {\n        style: {\n            padding: \"2rem\",\n            background: \"hsla(10, 50%, 50%, 0.1)\",\n            color: \"red\",\n            overflow: \"auto\"\n        }\n    }, errorInstance.stack), heyDeveloper);\n}\nfunction BoundaryShell({ title, renderScripts, isOutsideRemixApp, children }) {\n    let { routeModules } = useFrameworkContext();\n    if (routeModules.root?.Layout && !isOutsideRemixApp) {\n        return children;\n    }\n    return /* @__PURE__ */ React5.createElement(\"html\", {\n        lang: \"en\"\n    }, /* @__PURE__ */ React5.createElement(\"head\", null, /* @__PURE__ */ React5.createElement(\"meta\", {\n        charSet: \"utf-8\"\n    }), /* @__PURE__ */ React5.createElement(\"meta\", {\n        name: \"viewport\",\n        content: \"width=device-width,initial-scale=1,viewport-fit=cover\"\n    }), /* @__PURE__ */ React5.createElement(\"title\", null, title)), /* @__PURE__ */ React5.createElement(\"body\", null, /* @__PURE__ */ React5.createElement(\"main\", {\n        style: {\n            fontFamily: \"system-ui, sans-serif\",\n            padding: \"2rem\"\n        }\n    }, children, renderScripts ? /* @__PURE__ */ React5.createElement(Scripts, null) : null)));\n}\n// lib/dom/ssr/fallback.tsx\nvar React6 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction RemixRootDefaultHydrateFallback() {\n    return /* @__PURE__ */ React6.createElement(BoundaryShell, {\n        title: \"Loading...\",\n        renderScripts: true\n    }, ENABLE_DEV_WARNINGS ? /* @__PURE__ */ React6.createElement(\"script\", {\n        dangerouslySetInnerHTML: {\n            __html: `\n              console.log(\n                \"\\u{1F4BF} Hey developer \\u{1F44B}. You can provide a way better UX than this \" +\n                \"when your app is loading JS modules and/or running \\`clientLoader\\` \" +\n                \"functions. Check out https://reactrouter.com/start/framework/route-module#hydratefallback \" +\n                \"for more information.\"\n              );\n            `\n        }\n    }) : null);\n}\n// lib/dom/ssr/routes.tsx\nfunction groupRoutesByParentId(manifest) {\n    let routes = {};\n    Object.values(manifest).forEach((route)=>{\n        if (route) {\n            let parentId = route.parentId || \"\";\n            if (!routes[parentId]) {\n                routes[parentId] = [];\n            }\n            routes[parentId].push(route);\n        }\n    });\n    return routes;\n}\nfunction getRouteComponents(route, routeModule, isSpaMode) {\n    let Component4 = getRouteModuleComponent(routeModule);\n    let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === \"root\") ? routeModule.HydrateFallback : route.id === \"root\" ? RemixRootDefaultHydrateFallback : void 0;\n    let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === \"root\" ? ()=>/* @__PURE__ */ React7.createElement(RemixRootDefaultErrorBoundary, {\n            error: useRouteError()\n        }) : void 0;\n    if (route.id === \"root\" && routeModule.Layout) {\n        return {\n            ...Component4 ? {\n                element: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(Component4, null))\n            } : {\n                Component: Component4\n            },\n            ...ErrorBoundary ? {\n                errorElement: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(ErrorBoundary, null))\n            } : {\n                ErrorBoundary\n            },\n            ...HydrateFallback ? {\n                hydrateFallbackElement: /* @__PURE__ */ React7.createElement(routeModule.Layout, null, /* @__PURE__ */ React7.createElement(HydrateFallback, null))\n            } : {\n                HydrateFallback\n            }\n        };\n    }\n    return {\n        Component: Component4,\n        ErrorBoundary,\n        HydrateFallback\n    };\n}\nfunction createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({\n    Component: ()=>null\n})) {\n    return (routesByParentId[parentId] || []).map((route)=>{\n        let routeModule = routeModules[route.id];\n        invariant2(routeModule, \"No `routeModule` available to create server routes\");\n        let dataRoute = {\n            ...getRouteComponents(route, routeModule, isSpaMode),\n            caseSensitive: route.caseSensitive,\n            id: route.id,\n            index: route.index,\n            path: route.path,\n            handle: routeModule.handle,\n            // For SPA Mode, all routes are lazy except root.  However we tell the\n            // router root is also lazy here too since we don't need a full\n            // implementation - we just need a `lazy` prop to tell the RR rendering\n            // where to stop which is always at the root route in SPA mode\n            lazy: isSpaMode ? ()=>spaModeLazyPromise : void 0,\n            // For partial hydration rendering, we need to indicate when the route\n            // has a loader/clientLoader, but it won't ever be called during the static\n            // render, so just give it a no-op function so we can render down to the\n            // proper fallback\n            loader: route.hasLoader || route.hasClientLoader ? ()=>null : void 0\n        };\n        let children = createServerRoutes(manifest, routeModules, future, isSpaMode, route.id, routesByParentId, spaModeLazyPromise);\n        if (children.length > 0) dataRoute.children = children;\n        return dataRoute;\n    });\n}\nfunction createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, ssr, isSpaMode) {\n    return createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, \"\", groupRoutesByParentId(manifest), needsRevalidation);\n}\nfunction preventInvalidServerHandlerCall(type, route) {\n    if (type === \"loader\" && !route.hasLoader || type === \"action\" && !route.hasAction) {\n        let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n        let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${route.id}\")`;\n        console.error(msg);\n        throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n    }\n}\nfunction noActionDefinedError(type, routeId) {\n    let article = type === \"clientAction\" ? \"a\" : \"an\";\n    let msg = `Route \"${routeId}\" does not have ${article} ${type}, but you are trying to submit to it. To fix this, please add ${article} \\`${type}\\` function to the route`;\n    console.error(msg);\n    throw new ErrorResponseImpl(405, \"Method Not Allowed\", new Error(msg), true);\n}\nfunction createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, parentId = \"\", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {\n    return (routesByParentId[parentId] || []).map((route)=>{\n        let routeModule = routeModulesCache[route.id];\n        function fetchServerHandler(singleFetch) {\n            invariant2(typeof singleFetch === \"function\", \"No single fetch function available for route handler\");\n            return singleFetch();\n        }\n        function fetchServerLoader(singleFetch) {\n            if (!route.hasLoader) return Promise.resolve(null);\n            return fetchServerHandler(singleFetch);\n        }\n        function fetchServerAction(singleFetch) {\n            if (!route.hasAction) {\n                throw noActionDefinedError(\"action\", route.id);\n            }\n            return fetchServerHandler(singleFetch);\n        }\n        function prefetchModule(modulePath) {\n            import(/* @vite-ignore */ /* webpackIgnore: true */ modulePath);\n        }\n        function prefetchRouteModuleChunks(route2) {\n            if (route2.clientActionModule) {\n                prefetchModule(route2.clientActionModule);\n            }\n            if (route2.clientLoaderModule) {\n                prefetchModule(route2.clientLoaderModule);\n            }\n        }\n        async function prefetchStylesAndCallHandler(handler) {\n            let cachedModule = routeModulesCache[route.id];\n            let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();\n            try {\n                return handler();\n            } finally{\n                await linkPrefetchPromise;\n            }\n        }\n        let dataRoute = {\n            id: route.id,\n            index: route.index,\n            path: route.path\n        };\n        if (routeModule) {\n            Object.assign(dataRoute, {\n                ...dataRoute,\n                ...getRouteComponents(route, routeModule, isSpaMode),\n                unstable_middleware: routeModule.unstable_clientMiddleware,\n                handle: routeModule.handle,\n                shouldRevalidate: getShouldRevalidateFunction(dataRoute.path, routeModule, route, ssr, needsRevalidation)\n            });\n            let hasInitialData = initialState && initialState.loaderData && route.id in initialState.loaderData;\n            let initialData = hasInitialData ? initialState?.loaderData?.[route.id] : void 0;\n            let hasInitialError = initialState && initialState.errors && route.id in initialState.errors;\n            let initialError = hasInitialError ? initialState?.errors?.[route.id] : void 0;\n            let isHydrationRequest = needsRevalidation == null && (routeModule.clientLoader?.hydrate === true || !route.hasLoader);\n            dataRoute.loader = async ({ request, params, context }, singleFetch)=>{\n                try {\n                    let result = await prefetchStylesAndCallHandler(async ()=>{\n                        invariant2(routeModule, \"No `routeModule` available for critical-route loader\");\n                        if (!routeModule.clientLoader) {\n                            return fetchServerLoader(singleFetch);\n                        }\n                        return routeModule.clientLoader({\n                            request,\n                            params,\n                            context,\n                            async serverLoader () {\n                                preventInvalidServerHandlerCall(\"loader\", route);\n                                if (isHydrationRequest) {\n                                    if (hasInitialData) {\n                                        return initialData;\n                                    }\n                                    if (hasInitialError) {\n                                        throw initialError;\n                                    }\n                                }\n                                return fetchServerLoader(singleFetch);\n                            }\n                        });\n                    });\n                    return result;\n                } finally{\n                    isHydrationRequest = false;\n                }\n            };\n            dataRoute.loader.hydrate = shouldHydrateRouteLoader(route.id, routeModule.clientLoader, route.hasLoader, isSpaMode);\n            dataRoute.action = ({ request, params, context }, singleFetch)=>{\n                return prefetchStylesAndCallHandler(async ()=>{\n                    invariant2(routeModule, \"No `routeModule` available for critical-route action\");\n                    if (!routeModule.clientAction) {\n                        if (isSpaMode) {\n                            throw noActionDefinedError(\"clientAction\", route.id);\n                        }\n                        return fetchServerAction(singleFetch);\n                    }\n                    return routeModule.clientAction({\n                        request,\n                        params,\n                        context,\n                        async serverAction () {\n                            preventInvalidServerHandlerCall(\"action\", route);\n                            return fetchServerAction(singleFetch);\n                        }\n                    });\n                });\n            };\n        } else {\n            if (!route.hasClientLoader) {\n                dataRoute.loader = (_, singleFetch)=>prefetchStylesAndCallHandler(()=>{\n                        return fetchServerLoader(singleFetch);\n                    });\n            }\n            if (!route.hasClientAction) {\n                dataRoute.action = (_, singleFetch)=>prefetchStylesAndCallHandler(()=>{\n                        if (isSpaMode) {\n                            throw noActionDefinedError(\"clientAction\", route.id);\n                        }\n                        return fetchServerAction(singleFetch);\n                    });\n            }\n            let lazyRoutePromise;\n            async function getLazyRoute() {\n                if (lazyRoutePromise) {\n                    return await lazyRoutePromise;\n                }\n                lazyRoutePromise = (async ()=>{\n                    if (route.clientLoaderModule || route.clientActionModule) {\n                        await new Promise((resolve)=>setTimeout(resolve, 0));\n                    }\n                    let routeModulePromise = loadRouteModuleWithBlockingLinks(route, routeModulesCache);\n                    prefetchRouteModuleChunks(route);\n                    return await routeModulePromise;\n                })();\n                return await lazyRoutePromise;\n            }\n            dataRoute.lazy = {\n                loader: route.hasClientLoader ? async ()=>{\n                    let { clientLoader } = route.clientLoaderModule ? await import(/* @vite-ignore */ /* webpackIgnore: true */ route.clientLoaderModule) : await getLazyRoute();\n                    invariant2(clientLoader, \"No `clientLoader` export found\");\n                    return (args, singleFetch)=>clientLoader({\n                            ...args,\n                            async serverLoader () {\n                                preventInvalidServerHandlerCall(\"loader\", route);\n                                return fetchServerLoader(singleFetch);\n                            }\n                        });\n                } : void 0,\n                action: route.hasClientAction ? async ()=>{\n                    let clientActionPromise = route.clientActionModule ? import(/* @vite-ignore */ /* webpackIgnore: true */ route.clientActionModule) : getLazyRoute();\n                    prefetchRouteModuleChunks(route);\n                    let { clientAction } = await clientActionPromise;\n                    invariant2(clientAction, \"No `clientAction` export found\");\n                    return (args, singleFetch)=>clientAction({\n                            ...args,\n                            async serverAction () {\n                                preventInvalidServerHandlerCall(\"action\", route);\n                                return fetchServerAction(singleFetch);\n                            }\n                        });\n                } : void 0,\n                unstable_middleware: route.hasClientMiddleware ? async ()=>{\n                    let { unstable_clientMiddleware } = route.clientMiddlewareModule ? await import(/* @vite-ignore */ /* webpackIgnore: true */ route.clientMiddlewareModule) : await getLazyRoute();\n                    invariant2(unstable_clientMiddleware, \"No `unstable_clientMiddleware` export found\");\n                    return unstable_clientMiddleware;\n                } : void 0,\n                shouldRevalidate: async ()=>{\n                    let lazyRoute = await getLazyRoute();\n                    return getShouldRevalidateFunction(dataRoute.path, lazyRoute, route, ssr, needsRevalidation);\n                },\n                handle: async ()=>(await getLazyRoute()).handle,\n                // No need to wrap these in layout since the root route is never\n                // loaded via route.lazy()\n                Component: async ()=>(await getLazyRoute()).Component,\n                ErrorBoundary: route.hasErrorBoundary ? async ()=>(await getLazyRoute()).ErrorBoundary : void 0\n            };\n        }\n        let children = createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, route.id, routesByParentId, needsRevalidation);\n        if (children.length > 0) dataRoute.children = children;\n        return dataRoute;\n    });\n}\nfunction getShouldRevalidateFunction(path, route, manifestRoute, ssr, needsRevalidation) {\n    if (needsRevalidation) {\n        return wrapShouldRevalidateForHdr(manifestRoute.id, route.shouldRevalidate, needsRevalidation);\n    }\n    if (!ssr && manifestRoute.hasLoader && !manifestRoute.hasClientLoader) {\n        let myParams = path ? compilePath(path)[1].map((p)=>p.paramName) : [];\n        const didParamsChange = (opts)=>myParams.some((p)=>opts.currentParams[p] !== opts.nextParams[p]);\n        if (route.shouldRevalidate) {\n            let fn = route.shouldRevalidate;\n            return (opts)=>fn({\n                    ...opts,\n                    defaultShouldRevalidate: didParamsChange(opts)\n                });\n        } else {\n            return (opts)=>didParamsChange(opts);\n        }\n    }\n    if (ssr && route.shouldRevalidate) {\n        let fn = route.shouldRevalidate;\n        return (opts)=>fn({\n                ...opts,\n                defaultShouldRevalidate: true\n            });\n    }\n    return route.shouldRevalidate;\n}\nfunction wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {\n    let handledRevalidation = false;\n    return (arg)=>{\n        if (!handledRevalidation) {\n            handledRevalidation = true;\n            return needsRevalidation.has(routeId);\n        }\n        return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;\n    };\n}\nasync function loadRouteModuleWithBlockingLinks(route, routeModules) {\n    let routeModulePromise = loadRouteModule(route, routeModules);\n    let prefetchRouteCssPromise = prefetchRouteCss(route);\n    let routeModule = await routeModulePromise;\n    await Promise.all([\n        prefetchRouteCssPromise,\n        prefetchStyleLinks(route, routeModule)\n    ]);\n    return {\n        Component: getRouteModuleComponent(routeModule),\n        ErrorBoundary: routeModule.ErrorBoundary,\n        unstable_clientMiddleware: routeModule.unstable_clientMiddleware,\n        clientAction: routeModule.clientAction,\n        clientLoader: routeModule.clientLoader,\n        handle: routeModule.handle,\n        links: routeModule.links,\n        meta: routeModule.meta,\n        shouldRevalidate: routeModule.shouldRevalidate\n    };\n}\nfunction getRouteModuleComponent(routeModule) {\n    if (routeModule.default == null) return void 0;\n    let isEmptyObject = typeof routeModule.default === \"object\" && Object.keys(routeModule.default).length === 0;\n    if (!isEmptyObject) {\n        return routeModule.default;\n    }\n}\nfunction shouldHydrateRouteLoader(routeId, clientLoader, hasLoader, isSpaMode) {\n    return isSpaMode && routeId !== \"root\" || clientLoader != null && (clientLoader.hydrate === true || hasLoader !== true);\n}\n// lib/dom/ssr/fog-of-war.ts\nvar nextPaths = /* @__PURE__ */ new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */ new Set();\nvar URL_LIMIT = 7680;\nfunction isFogOfWarEnabled(routeDiscovery, ssr) {\n    return routeDiscovery.mode === \"lazy\" && ssr === true;\n}\nfunction getPartialManifest({ sri, ...manifest }, router) {\n    let routeIds = new Set(router.state.matches.map((m)=>m.route.id));\n    let segments = router.state.location.pathname.split(\"/\").filter(Boolean);\n    let paths = [\n        \"/\"\n    ];\n    segments.pop();\n    while(segments.length > 0){\n        paths.push(`/${segments.join(\"/\")}`);\n        segments.pop();\n    }\n    paths.forEach((path)=>{\n        let matches = matchRoutes(router.routes, path, router.basename);\n        if (matches) {\n            matches.forEach((m)=>routeIds.add(m.route.id));\n        }\n    });\n    let initialRoutes = [\n        ...routeIds\n    ].reduce((acc, id)=>Object.assign(acc, {\n            [id]: manifest.routes[id]\n        }), {});\n    return {\n        ...manifest,\n        routes: initialRoutes,\n        sri: sri ? true : void 0\n    };\n}\nfunction getPatchRoutesOnNavigationFunction(manifest, routeModules, ssr, routeDiscovery, isSpaMode, basename) {\n    if (!isFogOfWarEnabled(routeDiscovery, ssr)) {\n        return void 0;\n    }\n    return async ({ path, patch, signal, fetcherKey })=>{\n        if (discoveredPaths.has(path)) {\n            return;\n        }\n        await fetchAndApplyManifestPatches([\n            path\n        ], fetcherKey ? window.location.href : path, manifest, routeModules, ssr, isSpaMode, basename, routeDiscovery.manifestPath, patch, signal);\n    };\n}\nfunction useFogOFWarDiscovery(router, manifest, routeModules, ssr, routeDiscovery, isSpaMode) {\n    React8.useEffect(()=>{\n        if (!isFogOfWarEnabled(routeDiscovery, ssr) || // @ts-expect-error - TS doesn't know about this yet\n        window.navigator?.connection?.saveData === true) {\n            return;\n        }\n        function registerElement(el) {\n            let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n            if (!path) {\n                return;\n            }\n            let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\n            if (!discoveredPaths.has(pathname)) {\n                nextPaths.add(pathname);\n            }\n        }\n        async function fetchPatches() {\n            document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\n            let lazyPaths = Array.from(nextPaths.keys()).filter((path)=>{\n                if (discoveredPaths.has(path)) {\n                    nextPaths.delete(path);\n                    return false;\n                }\n                return true;\n            });\n            if (lazyPaths.length === 0) {\n                return;\n            }\n            try {\n                await fetchAndApplyManifestPatches(lazyPaths, null, manifest, routeModules, ssr, isSpaMode, router.basename, routeDiscovery.manifestPath, router.patchRoutes);\n            } catch (e) {\n                console.error(\"Failed to fetch manifest patches\", e);\n            }\n        }\n        let debouncedFetchPatches = debounce(fetchPatches, 100);\n        fetchPatches();\n        let observer = new MutationObserver(()=>debouncedFetchPatches());\n        observer.observe(document.documentElement, {\n            subtree: true,\n            childList: true,\n            attributes: true,\n            attributeFilter: [\n                \"data-discover\",\n                \"href\",\n                \"action\"\n            ]\n        });\n        return ()=>observer.disconnect();\n    }, [\n        ssr,\n        isSpaMode,\n        manifest,\n        routeModules,\n        router,\n        routeDiscovery\n    ]);\n}\nfunction getManifestPath(_manifestPath, basename) {\n    let manifestPath = _manifestPath || \"/__manifest\";\n    if (basename == null) {\n        return manifestPath;\n    }\n    return `${basename}${manifestPath}`.replace(/\\/+/g, \"/\");\n}\nvar MANIFEST_VERSION_STORAGE_KEY = \"react-router-manifest-version\";\nasync function fetchAndApplyManifestPatches(paths, errorReloadPath, manifest, routeModules, ssr, isSpaMode, basename, manifestPath, patchRoutes, signal) {\n    let url = new URL(getManifestPath(manifestPath, basename), window.location.origin);\n    paths.sort().forEach((path)=>url.searchParams.append(\"p\", path));\n    url.searchParams.set(\"version\", manifest.version);\n    if (url.toString().length > URL_LIMIT) {\n        nextPaths.clear();\n        return;\n    }\n    let serverPatches;\n    try {\n        let res = await fetch(url, {\n            signal\n        });\n        if (!res.ok) {\n            throw new Error(`${res.status} ${res.statusText}`);\n        } else if (res.status === 204 && res.headers.has(\"X-Remix-Reload-Document\")) {\n            if (!errorReloadPath) {\n                console.warn(\"Detected a manifest version mismatch during eager route discovery. The next navigation/fetch to an undiscovered route will result in a new document navigation to sync up with the latest manifest.\");\n                return;\n            }\n            if (sessionStorage.getItem(MANIFEST_VERSION_STORAGE_KEY) === manifest.version) {\n                console.error(\"Unable to discover routes due to manifest version mismatch.\");\n                return;\n            }\n            sessionStorage.setItem(MANIFEST_VERSION_STORAGE_KEY, manifest.version);\n            window.location.href = errorReloadPath;\n            console.warn(\"Detected manifest version mismatch, reloading...\");\n            await new Promise(()=>{});\n        } else if (res.status >= 400) {\n            throw new Error(await res.text());\n        }\n        sessionStorage.removeItem(MANIFEST_VERSION_STORAGE_KEY);\n        serverPatches = await res.json();\n    } catch (e) {\n        if (signal?.aborted) return;\n        throw e;\n    }\n    let knownRoutes = new Set(Object.keys(manifest.routes));\n    let patches = Object.values(serverPatches).reduce((acc, route)=>{\n        if (route && !knownRoutes.has(route.id)) {\n            acc[route.id] = route;\n        }\n        return acc;\n    }, {});\n    Object.assign(manifest.routes, patches);\n    paths.forEach((p)=>addToFifoQueue(p, discoveredPaths));\n    let parentIds = /* @__PURE__ */ new Set();\n    Object.values(patches).forEach((patch)=>{\n        if (patch && (!patch.parentId || !patches[patch.parentId])) {\n            parentIds.add(patch.parentId);\n        }\n    });\n    parentIds.forEach((parentId)=>patchRoutes(parentId || null, createClientRoutes(patches, routeModules, null, ssr, isSpaMode, parentId)));\n}\nfunction addToFifoQueue(path, queue) {\n    if (queue.size >= discoveredPathsMaxSize) {\n        let first = queue.values().next().value;\n        queue.delete(first);\n    }\n    queue.add(path);\n}\nfunction debounce(callback, wait) {\n    let timeoutId;\n    return (...args)=>{\n        window.clearTimeout(timeoutId);\n        timeoutId = window.setTimeout(()=>callback(...args), wait);\n    };\n}\n// lib/dom/ssr/components.tsx\nfunction useDataRouterContext2() {\n    let context = React9.useContext(DataRouterContext);\n    invariant2(context, \"You must render this element inside a <DataRouterContext.Provider> element\");\n    return context;\n}\nfunction useDataRouterStateContext() {\n    let context = React9.useContext(DataRouterStateContext);\n    invariant2(context, \"You must render this element inside a <DataRouterStateContext.Provider> element\");\n    return context;\n}\nvar FrameworkContext = React9.createContext(void 0);\nFrameworkContext.displayName = \"FrameworkContext\";\nfunction useFrameworkContext() {\n    let context = React9.useContext(FrameworkContext);\n    invariant2(context, \"You must render this element inside a <HydratedRouter> element\");\n    return context;\n}\nfunction usePrefetchBehavior(prefetch, theirElementProps) {\n    let frameworkContext = React9.useContext(FrameworkContext);\n    let [maybePrefetch, setMaybePrefetch] = React9.useState(false);\n    let [shouldPrefetch, setShouldPrefetch] = React9.useState(false);\n    let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;\n    let ref = React9.useRef(null);\n    React9.useEffect(()=>{\n        if (prefetch === \"render\") {\n            setShouldPrefetch(true);\n        }\n        if (prefetch === \"viewport\") {\n            let callback = (entries)=>{\n                entries.forEach((entry)=>{\n                    setShouldPrefetch(entry.isIntersecting);\n                });\n            };\n            let observer = new IntersectionObserver(callback, {\n                threshold: 0.5\n            });\n            if (ref.current) observer.observe(ref.current);\n            return ()=>{\n                observer.disconnect();\n            };\n        }\n    }, [\n        prefetch\n    ]);\n    React9.useEffect(()=>{\n        if (maybePrefetch) {\n            let id = setTimeout(()=>{\n                setShouldPrefetch(true);\n            }, 100);\n            return ()=>{\n                clearTimeout(id);\n            };\n        }\n    }, [\n        maybePrefetch\n    ]);\n    let setIntent = ()=>{\n        setMaybePrefetch(true);\n    };\n    let cancelIntent = ()=>{\n        setMaybePrefetch(false);\n        setShouldPrefetch(false);\n    };\n    if (!frameworkContext) {\n        return [\n            false,\n            ref,\n            {}\n        ];\n    }\n    if (prefetch !== \"intent\") {\n        return [\n            shouldPrefetch,\n            ref,\n            {}\n        ];\n    }\n    return [\n        shouldPrefetch,\n        ref,\n        {\n            onFocus: composeEventHandlers(onFocus, setIntent),\n            onBlur: composeEventHandlers(onBlur, cancelIntent),\n            onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),\n            onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),\n            onTouchStart: composeEventHandlers(onTouchStart, setIntent)\n        }\n    ];\n}\nfunction composeEventHandlers(theirHandler, ourHandler) {\n    return (event)=>{\n        theirHandler && theirHandler(event);\n        if (!event.defaultPrevented) {\n            ourHandler(event);\n        }\n    };\n}\nfunction getActiveMatches(matches, errors, isSpaMode) {\n    if (isSpaMode && !isHydrated) {\n        return [\n            matches[0]\n        ];\n    }\n    if (errors) {\n        let errorIdx = matches.findIndex((m)=>errors[m.route.id] !== void 0);\n        return matches.slice(0, errorIdx + 1);\n    }\n    return matches;\n}\nfunction Links() {\n    let { isSpaMode, manifest, routeModules, criticalCss } = useFrameworkContext();\n    let { errors, matches: routerMatches } = useDataRouterStateContext();\n    let matches = getActiveMatches(routerMatches, errors, isSpaMode);\n    let keyedLinks = React9.useMemo(()=>getKeyedLinksForMatches(matches, routeModules, manifest), [\n        matches,\n        routeModules,\n        manifest\n    ]);\n    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, typeof criticalCss === \"string\" ? /* @__PURE__ */ React9.createElement(\"style\", {\n        dangerouslySetInnerHTML: {\n            __html: criticalCss\n        }\n    }) : null, typeof criticalCss === \"object\" ? /* @__PURE__ */ React9.createElement(\"link\", {\n        rel: \"stylesheet\",\n        href: criticalCss.href\n    }) : null, keyedLinks.map(({ key, link })=>isPageLinkDescriptor(link) ? /* @__PURE__ */ React9.createElement(PrefetchPageLinks, {\n            key,\n            ...link\n        }) : /* @__PURE__ */ React9.createElement(\"link\", {\n            key,\n            ...link\n        })));\n}\nfunction PrefetchPageLinks({ page, ...dataLinkProps }) {\n    let { router } = useDataRouterContext2();\n    let matches = React9.useMemo(()=>matchRoutes(router.routes, page, router.basename), [\n        router.routes,\n        page,\n        router.basename\n    ]);\n    if (!matches) {\n        return null;\n    }\n    return /* @__PURE__ */ React9.createElement(PrefetchPageLinksImpl, {\n        page,\n        matches,\n        ...dataLinkProps\n    });\n}\nfunction useKeyedPrefetchLinks(matches) {\n    let { manifest, routeModules } = useFrameworkContext();\n    let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React9.useState([]);\n    React9.useEffect(()=>{\n        let interrupted = false;\n        void getKeyedPrefetchLinks(matches, manifest, routeModules).then((links)=>{\n            if (!interrupted) {\n                setKeyedPrefetchLinks(links);\n            }\n        });\n        return ()=>{\n            interrupted = true;\n        };\n    }, [\n        matches,\n        manifest,\n        routeModules\n    ]);\n    return keyedPrefetchLinks;\n}\nfunction PrefetchPageLinksImpl({ page, matches: nextMatches, ...linkProps }) {\n    let location = useLocation();\n    let { manifest, routeModules } = useFrameworkContext();\n    let { basename } = useDataRouterContext2();\n    let { loaderData, matches } = useDataRouterStateContext();\n    let newMatchesForData = React9.useMemo(()=>getNewMatchesForLinks(page, nextMatches, matches, manifest, location, \"data\"), [\n        page,\n        nextMatches,\n        matches,\n        manifest,\n        location\n    ]);\n    let newMatchesForAssets = React9.useMemo(()=>getNewMatchesForLinks(page, nextMatches, matches, manifest, location, \"assets\"), [\n        page,\n        nextMatches,\n        matches,\n        manifest,\n        location\n    ]);\n    let dataHrefs = React9.useMemo(()=>{\n        if (page === location.pathname + location.search + location.hash) {\n            return [];\n        }\n        let routesParams = /* @__PURE__ */ new Set();\n        let foundOptOutRoute = false;\n        nextMatches.forEach((m)=>{\n            let manifestRoute = manifest.routes[m.route.id];\n            if (!manifestRoute || !manifestRoute.hasLoader) {\n                return;\n            }\n            if (!newMatchesForData.some((m2)=>m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {\n                foundOptOutRoute = true;\n            } else if (manifestRoute.hasClientLoader) {\n                foundOptOutRoute = true;\n            } else {\n                routesParams.add(m.route.id);\n            }\n        });\n        if (routesParams.size === 0) {\n            return [];\n        }\n        let url = singleFetchUrl(page, basename);\n        if (foundOptOutRoute && routesParams.size > 0) {\n            url.searchParams.set(\"_routes\", nextMatches.filter((m)=>routesParams.has(m.route.id)).map((m)=>m.route.id).join(\",\"));\n        }\n        return [\n            url.pathname + url.search\n        ];\n    }, [\n        basename,\n        loaderData,\n        location,\n        manifest,\n        newMatchesForData,\n        nextMatches,\n        page,\n        routeModules\n    ]);\n    let moduleHrefs = React9.useMemo(()=>getModuleLinkHrefs(newMatchesForAssets, manifest), [\n        newMatchesForAssets,\n        manifest\n    ]);\n    let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);\n    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, dataHrefs.map((href2)=>/* @__PURE__ */ React9.createElement(\"link\", {\n            key: href2,\n            rel: \"prefetch\",\n            as: \"fetch\",\n            href: href2,\n            ...linkProps\n        })), moduleHrefs.map((href2)=>/* @__PURE__ */ React9.createElement(\"link\", {\n            key: href2,\n            rel: \"modulepreload\",\n            href: href2,\n            ...linkProps\n        })), keyedPrefetchLinks.map(({ key, link })=>// these don't spread `linkProps` because they are full link descriptors\n        // already with their own props\n        /* @__PURE__ */ React9.createElement(\"link\", {\n            key,\n            ...link\n        })));\n}\nfunction Meta() {\n    let { isSpaMode, routeModules } = useFrameworkContext();\n    let { errors, matches: routerMatches, loaderData } = useDataRouterStateContext();\n    let location = useLocation();\n    let _matches = getActiveMatches(routerMatches, errors, isSpaMode);\n    let error = null;\n    if (errors) {\n        error = errors[_matches[_matches.length - 1].route.id];\n    }\n    let meta = [];\n    let leafMeta = null;\n    let matches = [];\n    for(let i = 0; i < _matches.length; i++){\n        let _match = _matches[i];\n        let routeId = _match.route.id;\n        let data2 = loaderData[routeId];\n        let params = _match.params;\n        let routeModule = routeModules[routeId];\n        let routeMeta = [];\n        let match = {\n            id: routeId,\n            data: data2,\n            meta: [],\n            params: _match.params,\n            pathname: _match.pathname,\n            handle: _match.route.handle,\n            error\n        };\n        matches[i] = match;\n        if (routeModule?.meta) {\n            routeMeta = typeof routeModule.meta === \"function\" ? routeModule.meta({\n                data: data2,\n                params,\n                location,\n                matches,\n                error\n            }) : Array.isArray(routeModule.meta) ? [\n                ...routeModule.meta\n            ] : routeModule.meta;\n        } else if (leafMeta) {\n            routeMeta = [\n                ...leafMeta\n            ];\n        }\n        routeMeta = routeMeta || [];\n        if (!Array.isArray(routeMeta)) {\n            throw new Error(\"The route at \" + _match.route.path + \" returns an invalid value. All route meta functions must return an array of meta objects.\\n\\nTo reference the meta function API, see https://remix.run/route/meta\");\n        }\n        match.meta = routeMeta;\n        matches[i] = match;\n        meta = [\n            ...routeMeta\n        ];\n        leafMeta = meta;\n    }\n    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, meta.flat().map((metaProps)=>{\n        if (!metaProps) {\n            return null;\n        }\n        if (\"tagName\" in metaProps) {\n            let { tagName, ...rest } = metaProps;\n            if (!isValidMetaTag(tagName)) {\n                console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`);\n                return null;\n            }\n            let Comp = tagName;\n            return /* @__PURE__ */ React9.createElement(Comp, {\n                key: JSON.stringify(rest),\n                ...rest\n            });\n        }\n        if (\"title\" in metaProps) {\n            return /* @__PURE__ */ React9.createElement(\"title\", {\n                key: \"title\"\n            }, String(metaProps.title));\n        }\n        if (\"charset\" in metaProps) {\n            metaProps.charSet ?? (metaProps.charSet = metaProps.charset);\n            delete metaProps.charset;\n        }\n        if (\"charSet\" in metaProps && metaProps.charSet != null) {\n            return typeof metaProps.charSet === \"string\" ? /* @__PURE__ */ React9.createElement(\"meta\", {\n                key: \"charSet\",\n                charSet: metaProps.charSet\n            }) : null;\n        }\n        if (\"script:ld+json\" in metaProps) {\n            try {\n                let json = JSON.stringify(metaProps[\"script:ld+json\"]);\n                return /* @__PURE__ */ React9.createElement(\"script\", {\n                    key: `script:ld+json:${json}`,\n                    type: \"application/ld+json\",\n                    dangerouslySetInnerHTML: {\n                        __html: json\n                    }\n                });\n            } catch (err) {\n                return null;\n            }\n        }\n        return /* @__PURE__ */ React9.createElement(\"meta\", {\n            key: JSON.stringify(metaProps),\n            ...metaProps\n        });\n    }));\n}\nfunction isValidMetaTag(tagName) {\n    return typeof tagName === \"string\" && /^(meta|link)$/.test(tagName);\n}\nvar isHydrated = false;\nfunction Scripts(props) {\n    let { manifest, serverHandoffString, isSpaMode, renderMeta, routeDiscovery, ssr } = useFrameworkContext();\n    let { router, static: isStatic, staticContext } = useDataRouterContext2();\n    let { matches: routerMatches } = useDataRouterStateContext();\n    let enableFogOfWar = isFogOfWarEnabled(routeDiscovery, ssr);\n    if (renderMeta) {\n        renderMeta.didRenderScripts = true;\n    }\n    let matches = getActiveMatches(routerMatches, null, isSpaMode);\n    React9.useEffect(()=>{\n        isHydrated = true;\n    }, []);\n    let initialScripts = React9.useMemo(()=>{\n        let streamScript = \"window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());\";\n        let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : \" \";\n        let routeModulesScript = !isStatic ? \" \" : `${manifest.hmr?.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : \"\"}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : \"\"};\n${matches.map((match, routeIndex)=>{\n            let routeVarName = `route${routeIndex}`;\n            let manifestEntry = manifest.routes[match.route.id];\n            invariant2(manifestEntry, `Route ${match.route.id} not found in manifest`);\n            let { clientActionModule, clientLoaderModule, clientMiddlewareModule, hydrateFallbackModule, module: module2 } = manifestEntry;\n            let chunks = [\n                ...clientActionModule ? [\n                    {\n                        module: clientActionModule,\n                        varName: `${routeVarName}_clientAction`\n                    }\n                ] : [],\n                ...clientLoaderModule ? [\n                    {\n                        module: clientLoaderModule,\n                        varName: `${routeVarName}_clientLoader`\n                    }\n                ] : [],\n                ...clientMiddlewareModule ? [\n                    {\n                        module: clientMiddlewareModule,\n                        varName: `${routeVarName}_clientMiddleware`\n                    }\n                ] : [],\n                ...hydrateFallbackModule ? [\n                    {\n                        module: hydrateFallbackModule,\n                        varName: `${routeVarName}_HydrateFallback`\n                    }\n                ] : [],\n                {\n                    module: module2,\n                    varName: `${routeVarName}_main`\n                }\n            ];\n            if (chunks.length === 1) {\n                return `import * as ${routeVarName} from ${JSON.stringify(module2)};`;\n            }\n            let chunkImportsSnippet = chunks.map((chunk)=>`import * as ${chunk.varName} from \"${chunk.module}\";`).join(\"\\n\");\n            let mergedChunksSnippet = `const ${routeVarName} = {${chunks.map((chunk)=>`...${chunk.varName}`).join(\",\")}};`;\n            return [\n                chunkImportsSnippet,\n                mergedChunksSnippet\n            ].join(\"\\n\");\n        }).join(\"\\n\")}\n  ${enableFogOfWar ? // Inline a minimal manifest with the SSR matches\n        `window.__reactRouterManifest = ${JSON.stringify(getPartialManifest(manifest, router), null, 2)};` : \"\"}\n  window.__reactRouterRouteModules = {${matches.map((match, index)=>`${JSON.stringify(match.route.id)}:route${index}`).join(\",\")}};\n\nimport(${JSON.stringify(manifest.entry.module)});`;\n        return /* @__PURE__ */ React9.createElement(React9.Fragment, null, /* @__PURE__ */ React9.createElement(\"script\", {\n            ...props,\n            suppressHydrationWarning: true,\n            dangerouslySetInnerHTML: createHtml(contextScript),\n            type: void 0\n        }), /* @__PURE__ */ React9.createElement(\"script\", {\n            ...props,\n            suppressHydrationWarning: true,\n            dangerouslySetInnerHTML: createHtml(routeModulesScript),\n            type: \"module\",\n            async: true\n        }));\n    }, []);\n    let preloads = isHydrated ? [] : dedupe(manifest.entry.imports.concat(getModuleLinkHrefs(matches, manifest, {\n        includeHydrateFallback: true\n    })));\n    let sri = typeof manifest.sri === \"object\" ? manifest.sri : {};\n    return isHydrated ? null : /* @__PURE__ */ React9.createElement(React9.Fragment, null, typeof manifest.sri === \"object\" ? /* @__PURE__ */ React9.createElement(\"script\", {\n        \"rr-importmap\": \"\",\n        type: \"importmap\",\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: {\n            __html: JSON.stringify({\n                integrity: sri\n            })\n        }\n    }) : null, !enableFogOfWar ? /* @__PURE__ */ React9.createElement(\"link\", {\n        rel: \"modulepreload\",\n        href: manifest.url,\n        crossOrigin: props.crossOrigin,\n        integrity: sri[manifest.url],\n        suppressHydrationWarning: true\n    }) : null, /* @__PURE__ */ React9.createElement(\"link\", {\n        rel: \"modulepreload\",\n        href: manifest.entry.module,\n        crossOrigin: props.crossOrigin,\n        integrity: sri[manifest.entry.module],\n        suppressHydrationWarning: true\n    }), preloads.map((path)=>/* @__PURE__ */ React9.createElement(\"link\", {\n            key: path,\n            rel: \"modulepreload\",\n            href: path,\n            crossOrigin: props.crossOrigin,\n            integrity: sri[path],\n            suppressHydrationWarning: true\n        })), initialScripts);\n}\nfunction dedupe(array) {\n    return [\n        ...new Set(array)\n    ];\n}\nfunction mergeRefs(...refs) {\n    return (value)=>{\n        refs.forEach((ref)=>{\n            if (typeof ref === \"function\") {\n                ref(value);\n            } else if (ref != null) {\n                ref.current = value;\n            }\n        });\n    };\n}\n// lib/dom/lib.tsx\nvar isBrowser =  false && 0;\ntry {\n    if (isBrowser) {\n        window.__reactRouterVersion = \"7.6.1\";\n    }\n} catch (e) {}\nfunction createBrowserRouter(routes, opts) {\n    return createRouter({\n        basename: opts?.basename,\n        unstable_getContext: opts?.unstable_getContext,\n        future: opts?.future,\n        history: createBrowserHistory({\n            window: opts?.window\n        }),\n        hydrationData: opts?.hydrationData || parseHydrationData(),\n        routes,\n        mapRouteProperties,\n        hydrationRouteProperties,\n        dataStrategy: opts?.dataStrategy,\n        patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,\n        window: opts?.window\n    }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n    return createRouter({\n        basename: opts?.basename,\n        unstable_getContext: opts?.unstable_getContext,\n        future: opts?.future,\n        history: createHashHistory({\n            window: opts?.window\n        }),\n        hydrationData: opts?.hydrationData || parseHydrationData(),\n        routes,\n        mapRouteProperties,\n        hydrationRouteProperties,\n        dataStrategy: opts?.dataStrategy,\n        patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,\n        window: opts?.window\n    }).initialize();\n}\nfunction parseHydrationData() {\n    let state = window?.__staticRouterHydrationData;\n    if (state && state.errors) {\n        state = {\n            ...state,\n            errors: deserializeErrors(state.errors)\n        };\n    }\n    return state;\n}\nfunction deserializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n        } else if (val && val.__type === \"Error\") {\n            if (val.__subType) {\n                let ErrorConstructor = window[val.__subType];\n                if (typeof ErrorConstructor === \"function\") {\n                    try {\n                        let error = new ErrorConstructor(val.message);\n                        error.stack = \"\";\n                        serialized[key] = error;\n                    } catch (e) {}\n                }\n            }\n            if (serialized[key] == null) {\n                let error = new Error(val.message);\n                error.stack = \"\";\n                serialized[key] = error;\n            }\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\nfunction BrowserRouter({ basename, children, window: window2 }) {\n    let historyRef = React10.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = createBrowserHistory({\n            window: window2,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React10.useState({\n        action: history.action,\n        location: history.location\n    });\n    let setState = React10.useCallback((newState)=>{\n        React10.startTransition(()=>setStateImpl(newState));\n    }, [\n        setStateImpl\n    ]);\n    React10.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /* @__PURE__ */ React10.createElement(Router, {\n        basename,\n        children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nfunction HashRouter({ basename, children, window: window2 }) {\n    let historyRef = React10.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = createHashHistory({\n            window: window2,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = React10.useState({\n        action: history.action,\n        location: history.location\n    });\n    let setState = React10.useCallback((newState)=>{\n        React10.startTransition(()=>setStateImpl(newState));\n    }, [\n        setStateImpl\n    ]);\n    React10.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /* @__PURE__ */ React10.createElement(Router, {\n        basename,\n        children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nfunction HistoryRouter({ basename, children, history }) {\n    let [state, setStateImpl] = React10.useState({\n        action: history.action,\n        location: history.location\n    });\n    let setState = React10.useCallback((newState)=>{\n        React10.startTransition(()=>setStateImpl(newState));\n    }, [\n        setStateImpl\n    ]);\n    React10.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /* @__PURE__ */ React10.createElement(Router, {\n        basename,\n        children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nHistoryRouter.displayName = \"unstable_HistoryRouter\";\nvar ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar Link = React10.forwardRef(function LinkWithRef({ onClick, discover = \"render\", prefetch = \"none\", relative, reloadDocument, replace: replace2, state, target, to, preventScrollReset, viewTransition, ...rest }, forwardedRef) {\n    let { basename } = React10.useContext(NavigationContext);\n    let isAbsolute = typeof to === \"string\" && ABSOLUTE_URL_REGEX2.test(to);\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && isAbsolute) {\n        absoluteHref = to;\n        if (isBrowser) {\n            try {\n                let currentUrl = new URL(window.location.href);\n                let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n                let path = stripBasename(targetUrl.pathname, basename);\n                if (targetUrl.origin === currentUrl.origin && path != null) {\n                    to = path + targetUrl.search + targetUrl.hash;\n                } else {\n                    isExternal = true;\n                }\n            } catch (e) {\n                warning(false, `<Link to=\"${to}\"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`);\n            }\n        }\n    }\n    let href2 = useHref(to, {\n        relative\n    });\n    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(prefetch, rest);\n    let internalOnClick = useLinkClickHandler(to, {\n        replace: replace2,\n        state,\n        target,\n        preventScrollReset,\n        relative,\n        viewTransition\n    });\n    function handleClick(event) {\n        if (onClick) onClick(event);\n        if (!event.defaultPrevented) {\n            internalOnClick(event);\n        }\n    }\n    let link = // eslint-disable-next-line jsx-a11y/anchor-has-content\n    /* @__PURE__ */ React10.createElement(\"a\", {\n        ...rest,\n        ...prefetchHandlers,\n        href: absoluteHref || href2,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: mergeRefs(forwardedRef, prefetchRef),\n        target,\n        \"data-discover\": !isAbsolute && discover === \"render\" ? \"true\" : void 0\n    });\n    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React10.createElement(React10.Fragment, null, link, /* @__PURE__ */ React10.createElement(PrefetchPageLinks, {\n        page: href2\n    })) : link;\n});\nLink.displayName = \"Link\";\nvar NavLink = React10.forwardRef(function NavLinkWithRef({ \"aria-current\": ariaCurrentProp = \"page\", caseSensitive = false, className: classNameProp = \"\", end = false, style: styleProp, to, viewTransition, children, ...rest }, ref) {\n    let path = useResolvedPath(to, {\n        relative: rest.relative\n    });\n    let location = useLocation();\n    let routerState = React10.useContext(DataRouterStateContext);\n    let { navigator, basename } = React10.useContext(NavigationContext);\n    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useViewTransitionState(path) && viewTransition === true;\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n        locationPathname = locationPathname.toLowerCase();\n        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n        toPathname = toPathname.toLowerCase();\n    }\n    if (nextLocationPathname && basename) {\n        nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;\n    }\n    const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let renderProps = {\n        isActive,\n        isPending,\n        isTransitioning\n    };\n    let ariaCurrent = isActive ? ariaCurrentProp : void 0;\n    let className;\n    if (typeof classNameProp === \"function\") {\n        className = classNameProp(renderProps);\n    } else {\n        className = [\n            classNameProp,\n            isActive ? \"active\" : null,\n            isPending ? \"pending\" : null,\n            isTransitioning ? \"transitioning\" : null\n        ].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /* @__PURE__ */ React10.createElement(Link, {\n        ...rest,\n        \"aria-current\": ariaCurrent,\n        className,\n        ref,\n        style,\n        to,\n        viewTransition\n    }, typeof children === \"function\" ? children(renderProps) : children);\n});\nNavLink.displayName = \"NavLink\";\nvar Form = React10.forwardRef(({ discover = \"render\", fetcherKey, navigate, reloadDocument, replace: replace2, state, method = defaultMethod, action, onSubmit, relative, preventScrollReset, viewTransition, ...props }, forwardedRef)=>{\n    let submit = useSubmit();\n    let formAction = useFormAction(action, {\n        relative\n    });\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let isAbsolute = typeof action === \"string\" && ABSOLUTE_URL_REGEX2.test(action);\n    let submitHandler = (event)=>{\n        onSubmit && onSubmit(event);\n        if (event.defaultPrevented) return;\n        event.preventDefault();\n        let submitter = event.nativeEvent.submitter;\n        let submitMethod = submitter?.getAttribute(\"formmethod\") || method;\n        submit(submitter || event.currentTarget, {\n            fetcherKey,\n            method: submitMethod,\n            navigate,\n            replace: replace2,\n            state,\n            relative,\n            preventScrollReset,\n            viewTransition\n        });\n    };\n    return /* @__PURE__ */ React10.createElement(\"form\", {\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler,\n        ...props,\n        \"data-discover\": !isAbsolute && discover === \"render\" ? \"true\" : void 0\n    });\n});\nForm.displayName = \"Form\";\nfunction ScrollRestoration({ getKey, storageKey, ...props }) {\n    let remixContext = React10.useContext(FrameworkContext);\n    let { basename } = React10.useContext(NavigationContext);\n    let location = useLocation();\n    let matches = useMatches();\n    useScrollRestoration({\n        getKey,\n        storageKey\n    });\n    let ssrKey = React10.useMemo(()=>{\n        if (!remixContext || !getKey) return null;\n        let userKey = getScrollRestorationKey(location, matches, basename, getKey);\n        return userKey !== location.key ? userKey : null;\n    }, // Nah, we only need this the first time for the SSR render\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []);\n    if (!remixContext || remixContext.isSpaMode) {\n        return null;\n    }\n    let restoreScroll = ((storageKey2, restoreKey)=>{\n        if (!window.history.state || !window.history.state.key) {\n            let key = Math.random().toString(32).slice(2);\n            window.history.replaceState({\n                key\n            }, \"\");\n        }\n        try {\n            let positions = JSON.parse(sessionStorage.getItem(storageKey2) || \"{}\");\n            let storedY = positions[restoreKey || window.history.state.key];\n            if (typeof storedY === \"number\") {\n                window.scrollTo(0, storedY);\n            }\n        } catch (error) {\n            console.error(error);\n            sessionStorage.removeItem(storageKey2);\n        }\n    }).toString();\n    return /* @__PURE__ */ React10.createElement(\"script\", {\n        ...props,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: {\n            __html: `(${restoreScroll})(${JSON.stringify(storageKey || SCROLL_RESTORATION_STORAGE_KEY)}, ${JSON.stringify(ssrKey)})`\n        }\n    });\n}\nScrollRestoration.displayName = \"ScrollRestoration\";\nfunction getDataRouterConsoleError2(hookName) {\n    return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;\n}\nfunction useDataRouterContext3(hookName) {\n    let ctx = React10.useContext(DataRouterContext);\n    invariant(ctx, getDataRouterConsoleError2(hookName));\n    return ctx;\n}\nfunction useDataRouterState2(hookName) {\n    let state = React10.useContext(DataRouterStateContext);\n    invariant(state, getDataRouterConsoleError2(hookName));\n    return state;\n}\nfunction useLinkClickHandler(to, { target, replace: replaceProp, state, preventScrollReset, relative, viewTransition } = {}) {\n    let navigate = useNavigate();\n    let location = useLocation();\n    let path = useResolvedPath(to, {\n        relative\n    });\n    return React10.useCallback((event)=>{\n        if (shouldProcessLinkClick(event, target)) {\n            event.preventDefault();\n            let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);\n            navigate(to, {\n                replace: replace2,\n                state,\n                preventScrollReset,\n                relative,\n                viewTransition\n            });\n        }\n    }, [\n        location,\n        navigate,\n        path,\n        replaceProp,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        relative,\n        viewTransition\n    ]);\n}\nfunction useSearchParams(defaultInit) {\n    warning(typeof URLSearchParams !== \"undefined\", `You cannot use the \\`useSearchParams\\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`);\n    let defaultSearchParamsRef = React10.useRef(createSearchParams(defaultInit));\n    let hasSetSearchParamsRef = React10.useRef(false);\n    let location = useLocation();\n    let searchParams = React10.useMemo(()=>// Only merge in the defaults if we haven't yet called setSearchParams.\n        // Once we call that we want those to take precedence, otherwise you can't\n        // remove a param with setSearchParams({}) if it has an initial value\n        getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [\n        location.search\n    ]);\n    let navigate = useNavigate();\n    let setSearchParams = React10.useCallback((nextInit, navigateOptions)=>{\n        const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n        hasSetSearchParamsRef.current = true;\n        navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [\n        navigate,\n        searchParams\n    ]);\n    return [\n        searchParams,\n        setSearchParams\n    ];\n}\nvar fetcherId = 0;\nvar getUniqueFetcherId = ()=>`__${String(++fetcherId)}__`;\nfunction useSubmit() {\n    let { router } = useDataRouterContext3(\"useSubmit\" /* UseSubmit */ );\n    let { basename } = React10.useContext(NavigationContext);\n    let currentRouteId = useRouteId();\n    return React10.useCallback(async (target, options = {})=>{\n        let { action, method, encType, formData, body } = getFormSubmissionInfo(target, basename);\n        if (options.navigate === false) {\n            let key = options.fetcherKey || getUniqueFetcherId();\n            await router.fetch(key, currentRouteId, options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                flushSync: options.flushSync\n            });\n        } else {\n            await router.navigate(options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                replace: options.replace,\n                state: options.state,\n                fromRouteId: currentRouteId,\n                flushSync: options.flushSync,\n                viewTransition: options.viewTransition\n            });\n        }\n    }, [\n        router,\n        basename,\n        currentRouteId\n    ]);\n}\nfunction useFormAction(action, { relative } = {}) {\n    let { basename } = React10.useContext(NavigationContext);\n    let routeContext = React10.useContext(RouteContext);\n    invariant(routeContext, \"useFormAction must be used inside a RouteContext\");\n    let [match] = routeContext.matches.slice(-1);\n    let path = {\n        ...useResolvedPath(action ? action : \".\", {\n            relative\n        })\n    };\n    let location = useLocation();\n    if (action == null) {\n        path.search = location.search;\n        let params = new URLSearchParams(path.search);\n        let indexValues = params.getAll(\"index\");\n        let hasNakedIndexParam = indexValues.some((v)=>v === \"\");\n        if (hasNakedIndexParam) {\n            params.delete(\"index\");\n            indexValues.filter((v)=>v).forEach((v)=>params.append(\"index\", v));\n            let qs = params.toString();\n            path.search = qs ? `?${qs}` : \"\";\n        }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n            basename,\n            path.pathname\n        ]);\n    }\n    return createPath(path);\n}\nfunction useFetcher({ key } = {}) {\n    let { router } = useDataRouterContext3(\"useFetcher\" /* UseFetcher */ );\n    let state = useDataRouterState2(\"useFetcher\" /* UseFetcher */ );\n    let fetcherData = React10.useContext(FetchersContext);\n    let route = React10.useContext(RouteContext);\n    let routeId = route.matches[route.matches.length - 1]?.route.id;\n    invariant(fetcherData, `useFetcher must be used inside a FetchersContext`);\n    invariant(route, `useFetcher must be used inside a RouteContext`);\n    invariant(routeId != null, `useFetcher can only be used on routes that contain a unique \"id\"`);\n    let defaultKey = React10.useId();\n    let [fetcherKey, setFetcherKey] = React10.useState(key || defaultKey);\n    if (key && key !== fetcherKey) {\n        setFetcherKey(key);\n    }\n    React10.useEffect(()=>{\n        router.getFetcher(fetcherKey);\n        return ()=>router.deleteFetcher(fetcherKey);\n    }, [\n        router,\n        fetcherKey\n    ]);\n    let load = React10.useCallback(async (href2, opts)=>{\n        invariant(routeId, \"No routeId available for fetcher.load()\");\n        await router.fetch(fetcherKey, routeId, href2, opts);\n    }, [\n        fetcherKey,\n        routeId,\n        router\n    ]);\n    let submitImpl = useSubmit();\n    let submit = React10.useCallback(async (target, opts)=>{\n        await submitImpl(target, {\n            ...opts,\n            navigate: false,\n            fetcherKey\n        });\n    }, [\n        fetcherKey,\n        submitImpl\n    ]);\n    let FetcherForm = React10.useMemo(()=>{\n        let FetcherForm2 = React10.forwardRef((props, ref)=>{\n            return /* @__PURE__ */ React10.createElement(Form, {\n                ...props,\n                navigate: false,\n                fetcherKey,\n                ref\n            });\n        });\n        FetcherForm2.displayName = \"fetcher.Form\";\n        return FetcherForm2;\n    }, [\n        fetcherKey\n    ]);\n    let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n    let data2 = fetcherData.get(fetcherKey);\n    let fetcherWithComponents = React10.useMemo(()=>({\n            Form: FetcherForm,\n            submit,\n            load,\n            ...fetcher,\n            data: data2\n        }), [\n        FetcherForm,\n        submit,\n        load,\n        fetcher,\n        data2\n    ]);\n    return fetcherWithComponents;\n}\nfunction useFetchers() {\n    let state = useDataRouterState2(\"useFetchers\" /* UseFetchers */ );\n    return Array.from(state.fetchers.entries()).map(([key, fetcher])=>({\n            ...fetcher,\n            key\n        }));\n}\nvar SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nvar savedScrollPositions = {};\nfunction getScrollRestorationKey(location, matches, basename, getKey) {\n    let key = null;\n    if (getKey) {\n        if (basename !== \"/\") {\n            key = getKey({\n                ...location,\n                pathname: stripBasename(location.pathname, basename) || location.pathname\n            }, matches);\n        } else {\n            key = getKey(location, matches);\n        }\n    }\n    if (key == null) {\n        key = location.key;\n    }\n    return key;\n}\nfunction useScrollRestoration({ getKey, storageKey } = {}) {\n    let { router } = useDataRouterContext3(\"useScrollRestoration\" /* UseScrollRestoration */ );\n    let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(\"useScrollRestoration\" /* UseScrollRestoration */ );\n    let { basename } = React10.useContext(NavigationContext);\n    let location = useLocation();\n    let matches = useMatches();\n    let navigation = useNavigation();\n    React10.useEffect(()=>{\n        window.history.scrollRestoration = \"manual\";\n        return ()=>{\n            window.history.scrollRestoration = \"auto\";\n        };\n    }, []);\n    usePageHide(React10.useCallback(()=>{\n        if (navigation.state === \"idle\") {\n            let key = getScrollRestorationKey(location, matches, basename, getKey);\n            savedScrollPositions[key] = window.scrollY;\n        }\n        try {\n            sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n        } catch (error) {\n            warning(false, `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`);\n        }\n        window.history.scrollRestoration = \"auto\";\n    }, [\n        navigation.state,\n        getKey,\n        basename,\n        location,\n        matches,\n        storageKey\n    ]));\n    if (typeof document !== \"undefined\") {\n        React10.useLayoutEffect(()=>{\n            try {\n                let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n                if (sessionPositions) {\n                    savedScrollPositions = JSON.parse(sessionPositions);\n                }\n            } catch (e) {}\n        }, [\n            storageKey\n        ]);\n        React10.useLayoutEffect(()=>{\n            let disableScrollRestoration = router?.enableScrollRestoration(savedScrollPositions, ()=>window.scrollY, getKey ? (location2, matches2)=>getScrollRestorationKey(location2, matches2, basename, getKey) : void 0);\n            return ()=>disableScrollRestoration && disableScrollRestoration();\n        }, [\n            router,\n            basename,\n            getKey\n        ]);\n        React10.useLayoutEffect(()=>{\n            if (restoreScrollPosition === false) {\n                return;\n            }\n            if (typeof restoreScrollPosition === \"number\") {\n                window.scrollTo(0, restoreScrollPosition);\n                return;\n            }\n            if (location.hash) {\n                let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n                if (el) {\n                    el.scrollIntoView();\n                    return;\n                }\n            }\n            if (preventScrollReset === true) {\n                return;\n            }\n            window.scrollTo(0, 0);\n        }, [\n            location,\n            restoreScrollPosition,\n            preventScrollReset\n        ]);\n    }\n}\nfunction useBeforeUnload(callback, options) {\n    let { capture } = options || {};\n    React10.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : void 0;\n        window.addEventListener(\"beforeunload\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\nfunction usePageHide(callback, options) {\n    let { capture } = options || {};\n    React10.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : void 0;\n        window.addEventListener(\"pagehide\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"pagehide\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\nfunction usePrompt({ when, message }) {\n    let blocker = useBlocker(when);\n    React10.useEffect(()=>{\n        if (blocker.state === \"blocked\") {\n            let proceed = window.confirm(message);\n            if (proceed) {\n                setTimeout(blocker.proceed, 0);\n            } else {\n                blocker.reset();\n            }\n        }\n    }, [\n        blocker,\n        message\n    ]);\n    React10.useEffect(()=>{\n        if (blocker.state === \"blocked\" && !when) {\n            blocker.reset();\n        }\n    }, [\n        blocker,\n        when\n    ]);\n}\nfunction useViewTransitionState(to, opts = {}) {\n    let vtContext = React10.useContext(ViewTransitionContext);\n    invariant(vtContext != null, \"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?\");\n    let { basename } = useDataRouterContext3(\"useViewTransitionState\" /* useViewTransitionState */ );\n    let path = useResolvedPath(to, {\n        relative: opts.relative\n    });\n    if (!vtContext.isTransitioning) {\n        return false;\n    }\n    let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n    let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n    return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\n// lib/dom/server.tsx\nvar React11 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction StaticRouter({ basename, children, location: locationProp = \"/\" }) {\n    if (typeof locationProp === \"string\") {\n        locationProp = parsePath(locationProp);\n    }\n    let action = \"POP\" /* Pop */ ;\n    let location = {\n        pathname: locationProp.pathname || \"/\",\n        search: locationProp.search || \"\",\n        hash: locationProp.hash || \"\",\n        state: locationProp.state != null ? locationProp.state : null,\n        key: locationProp.key || \"default\"\n    };\n    let staticNavigator = getStatelessNavigator();\n    return /* @__PURE__ */ React11.createElement(Router, {\n        basename,\n        children,\n        location,\n        navigationType: action,\n        navigator: staticNavigator,\n        static: true\n    });\n}\nfunction StaticRouterProvider({ context, router, hydrate: hydrate2 = true, nonce }) {\n    invariant(router && context, \"You must provide `router` and `context` to <StaticRouterProvider>\");\n    let dataRouterContext = {\n        router,\n        navigator: getStatelessNavigator(),\n        static: true,\n        staticContext: context,\n        basename: context.basename || \"/\"\n    };\n    let fetchersContext = /* @__PURE__ */ new Map();\n    let hydrateScript = \"\";\n    if (hydrate2 !== false) {\n        let data2 = {\n            loaderData: context.loaderData,\n            actionData: context.actionData,\n            errors: serializeErrors(context.errors)\n        };\n        let json = htmlEscape(JSON.stringify(JSON.stringify(data2)));\n        hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;\n    }\n    let { state } = dataRouterContext.router;\n    return /* @__PURE__ */ React11.createElement(React11.Fragment, null, /* @__PURE__ */ React11.createElement(DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /* @__PURE__ */ React11.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /* @__PURE__ */ React11.createElement(FetchersContext.Provider, {\n        value: fetchersContext\n    }, /* @__PURE__ */ React11.createElement(ViewTransitionContext.Provider, {\n        value: {\n            isTransitioning: false\n        }\n    }, /* @__PURE__ */ React11.createElement(Router, {\n        basename: dataRouterContext.basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: dataRouterContext.navigator,\n        static: dataRouterContext.static\n    }, /* @__PURE__ */ React11.createElement(DataRoutes2, {\n        routes: router.routes,\n        future: router.future,\n        state\n    })))))), hydrateScript ? /* @__PURE__ */ React11.createElement(\"script\", {\n        suppressHydrationWarning: true,\n        nonce,\n        dangerouslySetInnerHTML: {\n            __html: hydrateScript\n        }\n    }) : null);\n}\nfunction DataRoutes2({ routes, future, state }) {\n    return useRoutesImpl(routes, void 0, state, future);\n}\nfunction serializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        if (isRouteErrorResponse(val)) {\n            serialized[key] = {\n                ...val,\n                __type: \"RouteErrorResponse\"\n            };\n        } else if (val instanceof Error) {\n            serialized[key] = {\n                message: val.message,\n                __type: \"Error\",\n                // If this is a subclass (i.e., ReferenceError), send up the type so we\n                // can re-create the same type during hydration.\n                ...val.name !== \"Error\" ? {\n                    __subType: val.name\n                } : {}\n            };\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\nfunction getStatelessNavigator() {\n    return {\n        createHref,\n        encodeLocation,\n        push (to) {\n            throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${JSON.stringify(to)})\\` somewhere in your app.`);\n        },\n        replace (to) {\n            throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${JSON.stringify(to)}, { replace: true })\\` somewhere in your app.`);\n        },\n        go (delta) {\n            throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \\`navigate(${delta})\\` somewhere in your app.`);\n        },\n        back () {\n            throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);\n        },\n        forward () {\n            throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);\n        }\n    };\n}\nfunction createStaticHandler2(routes, opts) {\n    return createStaticHandler(routes, {\n        ...opts,\n        mapRouteProperties\n    });\n}\nfunction createStaticRouter(routes, context, opts = {}) {\n    let manifest = {};\n    let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, void 0, manifest);\n    let matches = context.matches.map((match)=>{\n        let route = manifest[match.route.id] || match.route;\n        return {\n            ...match,\n            route\n        };\n    });\n    let msg = (method)=>`You cannot use router.${method}() on the server because it is a stateless environment`;\n    return {\n        get basename () {\n            return context.basename;\n        },\n        get future () {\n            return {\n                unstable_middleware: false,\n                ...opts?.future\n            };\n        },\n        get state () {\n            return {\n                historyAction: \"POP\" /* Pop */ ,\n                location: context.location,\n                matches,\n                loaderData: context.loaderData,\n                actionData: context.actionData,\n                errors: context.errors,\n                initialized: true,\n                navigation: IDLE_NAVIGATION,\n                restoreScrollPosition: null,\n                preventScrollReset: false,\n                revalidation: \"idle\",\n                fetchers: /* @__PURE__ */ new Map(),\n                blockers: /* @__PURE__ */ new Map()\n            };\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        get window () {\n            return void 0;\n        },\n        initialize () {\n            throw msg(\"initialize\");\n        },\n        subscribe () {\n            throw msg(\"subscribe\");\n        },\n        enableScrollRestoration () {\n            throw msg(\"enableScrollRestoration\");\n        },\n        navigate () {\n            throw msg(\"navigate\");\n        },\n        fetch () {\n            throw msg(\"fetch\");\n        },\n        revalidate () {\n            throw msg(\"revalidate\");\n        },\n        createHref,\n        encodeLocation,\n        getFetcher () {\n            return IDLE_FETCHER;\n        },\n        deleteFetcher () {\n            throw msg(\"deleteFetcher\");\n        },\n        dispose () {\n            throw msg(\"dispose\");\n        },\n        getBlocker () {\n            return IDLE_BLOCKER;\n        },\n        deleteBlocker () {\n            throw msg(\"deleteBlocker\");\n        },\n        patchRoutes () {\n            throw msg(\"patchRoutes\");\n        },\n        _internalFetchControllers: /* @__PURE__ */ new Map(),\n        _internalSetRoutes () {\n            throw msg(\"_internalSetRoutes\");\n        }\n    };\n}\nfunction createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n}\nfunction encodeLocation(to) {\n    let href2 = typeof to === \"string\" ? to : createPath(to);\n    href2 = href2.replace(/ $/, \"%20\");\n    let encoded = ABSOLUTE_URL_REGEX3.test(href2) ? new URL(href2) : new URL(href2, \"http://localhost\");\n    return {\n        pathname: encoded.pathname,\n        search: encoded.search,\n        hash: encoded.hash\n    };\n}\nvar ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nvar ESCAPE_LOOKUP2 = {\n    \"&\": \"\\\\u0026\",\n    \">\": \"\\\\u003e\",\n    \"<\": \"\\\\u003c\",\n    \"\\u2028\": \"\\\\u2028\",\n    \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX2 = /[&><\\u2028\\u2029]/g;\nfunction htmlEscape(str) {\n    return str.replace(ESCAPE_REGEX2, (match)=>ESCAPE_LOOKUP2[match]);\n}\n// lib/dom/ssr/server.tsx\nvar React12 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction ServerRouter({ context, url, nonce }) {\n    if (typeof url === \"string\") {\n        url = new URL(url);\n    }\n    let { manifest, routeModules, criticalCss, serverHandoffString } = context;\n    let routes = createServerRoutes(manifest.routes, routeModules, context.future, context.isSpaMode);\n    context.staticHandlerContext.loaderData = {\n        ...context.staticHandlerContext.loaderData\n    };\n    for (let match of context.staticHandlerContext.matches){\n        let routeId = match.route.id;\n        let route = routeModules[routeId];\n        let manifestRoute = context.manifest.routes[routeId];\n        if (route && manifestRoute && shouldHydrateRouteLoader(routeId, route.clientLoader, manifestRoute.hasLoader, context.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n            delete context.staticHandlerContext.loaderData[routeId];\n        }\n    }\n    let router = createStaticRouter(routes, context.staticHandlerContext);\n    return /* @__PURE__ */ React12.createElement(React12.Fragment, null, /* @__PURE__ */ React12.createElement(FrameworkContext.Provider, {\n        value: {\n            manifest,\n            routeModules,\n            criticalCss,\n            serverHandoffString,\n            future: context.future,\n            ssr: context.ssr,\n            isSpaMode: context.isSpaMode,\n            routeDiscovery: context.routeDiscovery,\n            serializeError: context.serializeError,\n            renderMeta: context.renderMeta\n        }\n    }, /* @__PURE__ */ React12.createElement(RemixErrorBoundary, {\n        location: router.state.location\n    }, /* @__PURE__ */ React12.createElement(StaticRouterProvider, {\n        router,\n        context: context.staticHandlerContext,\n        hydrate: false\n    }))), context.serverHandoffStream ? /* @__PURE__ */ React12.createElement(React12.Suspense, null, /* @__PURE__ */ React12.createElement(StreamTransfer, {\n        context,\n        identifier: 0,\n        reader: context.serverHandoffStream.getReader(),\n        textDecoder: new TextDecoder(),\n        nonce\n    })) : null);\n}\n// lib/dom/ssr/routes-test-stub.tsx\nvar React13 = __toESM(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction createRoutesStub(routes, unstable_getContext) {\n    return function RoutesTestStub({ initialEntries, initialIndex, hydrationData, future }) {\n        let routerRef = React13.useRef();\n        let remixContextRef = React13.useRef();\n        if (routerRef.current == null) {\n            remixContextRef.current = {\n                future: {\n                    unstable_subResourceIntegrity: future?.unstable_subResourceIntegrity === true,\n                    unstable_middleware: future?.unstable_middleware === true\n                },\n                manifest: {\n                    routes: {},\n                    entry: {\n                        imports: [],\n                        module: \"\"\n                    },\n                    url: \"\",\n                    version: \"\"\n                },\n                routeModules: {},\n                ssr: false,\n                isSpaMode: false,\n                routeDiscovery: {\n                    mode: \"lazy\",\n                    manifestPath: \"/__manifest\"\n                }\n            };\n            let patched = processRoutes(// @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`\n            // types compared to `AgnosticRouteObject`\n            convertRoutesToDataRoutes(routes, (r)=>r), remixContextRef.current.manifest, remixContextRef.current.routeModules);\n            routerRef.current = createMemoryRouter(patched, {\n                unstable_getContext,\n                initialEntries,\n                initialIndex,\n                hydrationData\n            });\n        }\n        return /* @__PURE__ */ React13.createElement(FrameworkContext.Provider, {\n            value: remixContextRef.current\n        }, /* @__PURE__ */ React13.createElement(RouterProvider, {\n            router: routerRef.current\n        }));\n    };\n}\nfunction withComponentProps(Component4) {\n    return function Wrapped() {\n        return React13.createElement(Component4, {\n            params: useParams(),\n            loaderData: useLoaderData(),\n            actionData: useActionData(),\n            matches: useMatches()\n        });\n    };\n}\nfunction withHydrateFallbackProps(HydrateFallback) {\n    return function Wrapped() {\n        const props = {\n            params: useParams(),\n            loaderData: useLoaderData(),\n            actionData: useActionData()\n        };\n        return React13.createElement(HydrateFallback, props);\n    };\n}\nfunction withErrorBoundaryProps(ErrorBoundary) {\n    return function Wrapped() {\n        const props = {\n            params: useParams(),\n            loaderData: useLoaderData(),\n            actionData: useActionData(),\n            error: useRouteError()\n        };\n        return React13.createElement(ErrorBoundary, props);\n    };\n}\nfunction processRoutes(routes, manifest, routeModules, parentId) {\n    return routes.map((route)=>{\n        if (!route.id) {\n            throw new Error(\"Expected a route.id in @remix-run/testing processRoutes() function\");\n        }\n        let newRoute = {\n            id: route.id,\n            path: route.path,\n            index: route.index,\n            Component: route.Component ? withComponentProps(route.Component) : void 0,\n            HydrateFallback: route.HydrateFallback ? withHydrateFallbackProps(route.HydrateFallback) : void 0,\n            ErrorBoundary: route.ErrorBoundary ? withErrorBoundaryProps(route.ErrorBoundary) : void 0,\n            action: route.action,\n            loader: route.loader,\n            handle: route.handle,\n            shouldRevalidate: route.shouldRevalidate\n        };\n        let entryRoute = {\n            id: route.id,\n            path: route.path,\n            index: route.index,\n            parentId,\n            hasAction: route.action != null,\n            hasLoader: route.loader != null,\n            // When testing routes, you should be stubbing loader/action/middleware,\n            // not trying to re-implement the full loader/clientLoader/SSR/hydration\n            // flow. That is better tested via E2E tests.\n            hasClientAction: false,\n            hasClientLoader: false,\n            hasClientMiddleware: false,\n            hasErrorBoundary: route.ErrorBoundary != null,\n            // any need for these?\n            module: \"build/stub-path-to-module.js\",\n            clientActionModule: void 0,\n            clientLoaderModule: void 0,\n            clientMiddlewareModule: void 0,\n            hydrateFallbackModule: void 0\n        };\n        manifest.routes[newRoute.id] = entryRoute;\n        routeModules[route.id] = {\n            default: newRoute.Component || Outlet,\n            ErrorBoundary: newRoute.ErrorBoundary || void 0,\n            handle: route.handle,\n            links: route.links,\n            meta: route.meta,\n            shouldRevalidate: route.shouldRevalidate\n        };\n        if (route.children) {\n            newRoute.children = processRoutes(route.children, manifest, routeModules, newRoute.id);\n        }\n        return newRoute;\n    });\n}\n// lib/server-runtime/cookies.ts\nvar import_cookie = __webpack_require__(/*! cookie */ \"(ssr)/./node_modules/cookie/dist/index.js\");\n// lib/server-runtime/crypto.ts\nvar encoder = /* @__PURE__ */ new TextEncoder();\nvar sign = async (value, secret)=>{\n    let data2 = encoder.encode(value);\n    let key = await createKey2(secret, [\n        \"sign\"\n    ]);\n    let signature = await crypto.subtle.sign(\"HMAC\", key, data2);\n    let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, \"\");\n    return value + \".\" + hash;\n};\nvar unsign = async (cookie, secret)=>{\n    let index = cookie.lastIndexOf(\".\");\n    let value = cookie.slice(0, index);\n    let hash = cookie.slice(index + 1);\n    let data2 = encoder.encode(value);\n    let key = await createKey2(secret, [\n        \"verify\"\n    ]);\n    let signature = byteStringToUint8Array(atob(hash));\n    let valid = await crypto.subtle.verify(\"HMAC\", key, signature, data2);\n    return valid ? value : false;\n};\nvar createKey2 = async (secret, usages)=>crypto.subtle.importKey(\"raw\", encoder.encode(secret), {\n        name: \"HMAC\",\n        hash: \"SHA-256\"\n    }, false, usages);\nfunction byteStringToUint8Array(byteString) {\n    let array = new Uint8Array(byteString.length);\n    for(let i = 0; i < byteString.length; i++){\n        array[i] = byteString.charCodeAt(i);\n    }\n    return array;\n}\n// lib/server-runtime/cookies.ts\nvar createCookie = (name, cookieOptions = {})=>{\n    let { secrets = [], ...options } = {\n        path: \"/\",\n        sameSite: \"lax\",\n        ...cookieOptions\n    };\n    warnOnceAboutExpiresCookie(name, options.expires);\n    return {\n        get name () {\n            return name;\n        },\n        get isSigned () {\n            return secrets.length > 0;\n        },\n        get expires () {\n            return typeof options.maxAge !== \"undefined\" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;\n        },\n        async parse (cookieHeader, parseOptions) {\n            if (!cookieHeader) return null;\n            let cookies = (0, import_cookie.parse)(cookieHeader, {\n                ...options,\n                ...parseOptions\n            });\n            if (name in cookies) {\n                let value = cookies[name];\n                if (typeof value === \"string\" && value !== \"\") {\n                    let decoded = await decodeCookieValue(value, secrets);\n                    return decoded;\n                } else {\n                    return \"\";\n                }\n            } else {\n                return null;\n            }\n        },\n        async serialize (value, serializeOptions) {\n            return (0, import_cookie.serialize)(name, value === \"\" ? \"\" : await encodeCookieValue(value, secrets), {\n                ...options,\n                ...serializeOptions\n            });\n        }\n    };\n};\nvar isCookie = (object)=>{\n    return object != null && typeof object.name === \"string\" && typeof object.isSigned === \"boolean\" && typeof object.parse === \"function\" && typeof object.serialize === \"function\";\n};\nasync function encodeCookieValue(value, secrets) {\n    let encoded = encodeData(value);\n    if (secrets.length > 0) {\n        encoded = await sign(encoded, secrets[0]);\n    }\n    return encoded;\n}\nasync function decodeCookieValue(value, secrets) {\n    if (secrets.length > 0) {\n        for (let secret of secrets){\n            let unsignedValue = await unsign(value, secret);\n            if (unsignedValue !== false) {\n                return decodeData(unsignedValue);\n            }\n        }\n        return null;\n    }\n    return decodeData(value);\n}\nfunction encodeData(value) {\n    return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));\n}\nfunction decodeData(value) {\n    try {\n        return JSON.parse(decodeURIComponent(myEscape(atob(value))));\n    } catch (error) {\n        return {};\n    }\n}\nfunction myEscape(value) {\n    let str = value.toString();\n    let result = \"\";\n    let index = 0;\n    let chr, code;\n    while(index < str.length){\n        chr = str.charAt(index++);\n        if (/[\\w*+\\-./@]/.exec(chr)) {\n            result += chr;\n        } else {\n            code = chr.charCodeAt(0);\n            if (code < 256) {\n                result += \"%\" + hex(code, 2);\n            } else {\n                result += \"%u\" + hex(code, 4).toUpperCase();\n            }\n        }\n    }\n    return result;\n}\nfunction hex(code, length) {\n    let result = code.toString(16);\n    while(result.length < length)result = \"0\" + result;\n    return result;\n}\nfunction myUnescape(value) {\n    let str = value.toString();\n    let result = \"\";\n    let index = 0;\n    let chr, part;\n    while(index < str.length){\n        chr = str.charAt(index++);\n        if (chr === \"%\") {\n            if (str.charAt(index) === \"u\") {\n                part = str.slice(index + 1, index + 5);\n                if (/^[\\da-f]{4}$/i.exec(part)) {\n                    result += String.fromCharCode(parseInt(part, 16));\n                    index += 5;\n                    continue;\n                }\n            } else {\n                part = str.slice(index, index + 2);\n                if (/^[\\da-f]{2}$/i.exec(part)) {\n                    result += String.fromCharCode(parseInt(part, 16));\n                    index += 2;\n                    continue;\n                }\n            }\n        }\n        result += chr;\n    }\n    return result;\n}\nfunction warnOnceAboutExpiresCookie(name, expires) {\n    warnOnce(!expires, `The \"${name}\" cookie has an \"expires\" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \\`commitSession(session, { expires })\\` if using a session storage object, or \\`cookie.serialize(\"value\", { expires })\\` if you're using the cookie directly.`);\n}\n// lib/server-runtime/entry.ts\nfunction createEntryRouteModules(manifest) {\n    return Object.keys(manifest).reduce((memo2, routeId)=>{\n        let route = manifest[routeId];\n        if (route) {\n            memo2[routeId] = route.module;\n        }\n        return memo2;\n    }, {});\n}\n// lib/server-runtime/mode.ts\nvar ServerMode = /* @__PURE__ */ ((ServerMode2)=>{\n    ServerMode2[\"Development\"] = \"development\";\n    ServerMode2[\"Production\"] = \"production\";\n    ServerMode2[\"Test\"] = \"test\";\n    return ServerMode2;\n})(ServerMode || {});\nfunction isServerMode(value) {\n    return value === \"development\" /* Development */  || value === \"production\" /* Production */  || value === \"test\" /* Test */ ;\n}\n// lib/server-runtime/errors.ts\nfunction sanitizeError(error, serverMode) {\n    if (error instanceof Error && serverMode !== \"development\" /* Development */ ) {\n        let sanitized = new Error(\"Unexpected Server Error\");\n        sanitized.stack = void 0;\n        return sanitized;\n    }\n    return error;\n}\nfunction sanitizeErrors(errors, serverMode) {\n    return Object.entries(errors).reduce((acc, [routeId, error])=>{\n        return Object.assign(acc, {\n            [routeId]: sanitizeError(error, serverMode)\n        });\n    }, {});\n}\nfunction serializeError(error, serverMode) {\n    let sanitized = sanitizeError(error, serverMode);\n    return {\n        message: sanitized.message,\n        stack: sanitized.stack\n    };\n}\nfunction serializeErrors2(errors, serverMode) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        if (isRouteErrorResponse(val)) {\n            serialized[key] = {\n                ...val,\n                __type: \"RouteErrorResponse\"\n            };\n        } else if (val instanceof Error) {\n            let sanitized = sanitizeError(val, serverMode);\n            serialized[key] = {\n                message: sanitized.message,\n                stack: sanitized.stack,\n                __type: \"Error\",\n                // If this is a subclass (i.e., ReferenceError), send up the type so we\n                // can re-create the same type during hydration.  This will only apply\n                // in dev mode since all production errors are sanitized to normal\n                // Error instances\n                ...sanitized.name !== \"Error\" ? {\n                    __subType: sanitized.name\n                } : {}\n            };\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\n// lib/server-runtime/routeMatching.ts\nfunction matchServerRoutes(routes, pathname, basename) {\n    let matches = matchRoutes(routes, pathname, basename);\n    if (!matches) return null;\n    return matches.map((match)=>({\n            params: match.params,\n            pathname: match.pathname,\n            route: match.route\n        }));\n}\n// lib/server-runtime/data.ts\nasync function callRouteHandler(handler, args) {\n    let result = await handler({\n        request: stripRoutesParam(stripIndexParam2(args.request)),\n        params: args.params,\n        context: args.context\n    });\n    if (isDataWithResponseInit(result) && result.init && result.init.status && isRedirectStatusCode(result.init.status)) {\n        throw new Response(null, result.init);\n    }\n    return result;\n}\nfunction stripIndexParam2(request) {\n    let url = new URL(request.url);\n    let indexValues = url.searchParams.getAll(\"index\");\n    url.searchParams.delete(\"index\");\n    let indexValuesToKeep = [];\n    for (let indexValue of indexValues){\n        if (indexValue) {\n            indexValuesToKeep.push(indexValue);\n        }\n    }\n    for (let toKeep of indexValuesToKeep){\n        url.searchParams.append(\"index\", toKeep);\n    }\n    let init = {\n        method: request.method,\n        body: request.body,\n        headers: request.headers,\n        signal: request.signal\n    };\n    if (init.body) {\n        init.duplex = \"half\";\n    }\n    return new Request(url.href, init);\n}\nfunction stripRoutesParam(request) {\n    let url = new URL(request.url);\n    url.searchParams.delete(\"_routes\");\n    let init = {\n        method: request.method,\n        body: request.body,\n        headers: request.headers,\n        signal: request.signal\n    };\n    if (init.body) {\n        init.duplex = \"half\";\n    }\n    return new Request(url.href, init);\n}\n// lib/server-runtime/invariant.ts\nfunction invariant3(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        console.error(\"The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose\");\n        throw new Error(message);\n    }\n}\n// lib/server-runtime/dev.ts\nvar globalDevServerHooksKey = \"__reactRouterDevServerHooks\";\nfunction setDevServerHooks(devServerHooks) {\n    globalThis[globalDevServerHooksKey] = devServerHooks;\n}\nfunction getDevServerHooks() {\n    return globalThis[globalDevServerHooksKey];\n}\nfunction getBuildTimeHeader(request, headerName) {\n    if (typeof process !== \"undefined\") {\n        try {\n            if (process.env?.IS_RR_BUILD_REQUEST === \"yes\") {\n                return request.headers.get(headerName);\n            }\n        } catch (e) {}\n    }\n    return null;\n}\n// lib/server-runtime/routes.ts\nfunction groupRoutesByParentId2(manifest) {\n    let routes = {};\n    Object.values(manifest).forEach((route)=>{\n        if (route) {\n            let parentId = route.parentId || \"\";\n            if (!routes[parentId]) {\n                routes[parentId] = [];\n            }\n            routes[parentId].push(route);\n        }\n    });\n    return routes;\n}\nfunction createRoutes(manifest, parentId = \"\", routesByParentId = groupRoutesByParentId2(manifest)) {\n    return (routesByParentId[parentId] || []).map((route)=>({\n            ...route,\n            children: createRoutes(manifest, route.id, routesByParentId)\n        }));\n}\nfunction createStaticHandlerDataRoutes(manifest, future, parentId = \"\", routesByParentId = groupRoutesByParentId2(manifest)) {\n    return (routesByParentId[parentId] || []).map((route)=>{\n        let commonRoute = {\n            // Always include root due to default boundaries\n            hasErrorBoundary: route.id === \"root\" || route.module.ErrorBoundary != null,\n            id: route.id,\n            path: route.path,\n            unstable_middleware: route.module.unstable_middleware,\n            // Need to use RR's version in the param typed here to permit the optional\n            // context even though we know it'll always be provided in remix\n            loader: route.module.loader ? async (args)=>{\n                let preRenderedData = getBuildTimeHeader(args.request, \"X-React-Router-Prerender-Data\");\n                if (preRenderedData != null) {\n                    let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;\n                    invariant3(encoded, \"Missing prerendered data for route\");\n                    let uint8array = new TextEncoder().encode(encoded);\n                    let stream = new ReadableStream({\n                        start (controller) {\n                            controller.enqueue(uint8array);\n                            controller.close();\n                        }\n                    });\n                    let decoded = await decodeViaTurboStream(stream, global);\n                    let data2 = decoded.value;\n                    if (data2 && SingleFetchRedirectSymbol in data2) {\n                        let result = data2[SingleFetchRedirectSymbol];\n                        let init = {\n                            status: result.status\n                        };\n                        if (result.reload) {\n                            throw redirectDocument(result.redirect, init);\n                        } else if (result.replace) {\n                            throw replace(result.redirect, init);\n                        } else {\n                            throw redirect(result.redirect, init);\n                        }\n                    } else {\n                        invariant3(data2 && route.id in data2, \"Unable to decode prerendered data\");\n                        let result = data2[route.id];\n                        invariant3(\"data\" in result, \"Unable to process prerendered data\");\n                        return result.data;\n                    }\n                }\n                let val = await callRouteHandler(route.module.loader, args);\n                return val;\n            } : void 0,\n            action: route.module.action ? (args)=>callRouteHandler(route.module.action, args) : void 0,\n            handle: route.module.handle\n        };\n        return route.index ? {\n            index: true,\n            ...commonRoute\n        } : {\n            caseSensitive: route.caseSensitive,\n            children: createStaticHandlerDataRoutes(manifest, future, route.id, routesByParentId),\n            ...commonRoute\n        };\n    });\n}\n// lib/server-runtime/markup.ts\nvar ESCAPE_LOOKUP3 = {\n    \"&\": \"\\\\u0026\",\n    \">\": \"\\\\u003e\",\n    \"<\": \"\\\\u003c\",\n    \"\\u2028\": \"\\\\u2028\",\n    \"\\u2029\": \"\\\\u2029\"\n};\nvar ESCAPE_REGEX3 = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml2(html) {\n    return html.replace(ESCAPE_REGEX3, (match)=>ESCAPE_LOOKUP3[match]);\n}\n// lib/server-runtime/serverHandoff.ts\nfunction createServerHandoffString(serverHandoff) {\n    return escapeHtml2(JSON.stringify(serverHandoff));\n}\n// lib/server-runtime/headers.ts\nvar import_set_cookie_parser = __webpack_require__(/*! set-cookie-parser */ \"(ssr)/./node_modules/set-cookie-parser/lib/set-cookie.js\");\nfunction getDocumentHeaders(build, context) {\n    let boundaryIdx = context.errors ? context.matches.findIndex((m)=>context.errors[m.route.id]) : -1;\n    let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;\n    let errorHeaders;\n    if (boundaryIdx >= 0) {\n        let { actionHeaders, actionData, loaderHeaders, loaderData } = context;\n        context.matches.slice(boundaryIdx).some((match)=>{\n            let id = match.route.id;\n            if (actionHeaders[id] && (!actionData || !actionData.hasOwnProperty(id))) {\n                errorHeaders = actionHeaders[id];\n            } else if (loaderHeaders[id] && !loaderData.hasOwnProperty(id)) {\n                errorHeaders = loaderHeaders[id];\n            }\n            return errorHeaders != null;\n        });\n    }\n    return matches.reduce((parentHeaders, match, idx)=>{\n        let { id } = match.route;\n        let route = build.routes[id];\n        invariant3(route, `Route with id \"${id}\" not found in build`);\n        let routeModule = route.module;\n        let loaderHeaders = context.loaderHeaders[id] || new Headers();\n        let actionHeaders = context.actionHeaders[id] || new Headers();\n        let includeErrorHeaders = errorHeaders != null && idx === matches.length - 1;\n        let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;\n        if (routeModule.headers == null) {\n            let headers2 = new Headers(parentHeaders);\n            if (includeErrorCookies) {\n                prependCookies(errorHeaders, headers2);\n            }\n            prependCookies(actionHeaders, headers2);\n            prependCookies(loaderHeaders, headers2);\n            return headers2;\n        }\n        let headers = new Headers(routeModule.headers ? typeof routeModule.headers === \"function\" ? routeModule.headers({\n            loaderHeaders,\n            parentHeaders,\n            actionHeaders,\n            errorHeaders: includeErrorHeaders ? errorHeaders : void 0\n        }) : routeModule.headers : void 0);\n        if (includeErrorCookies) {\n            prependCookies(errorHeaders, headers);\n        }\n        prependCookies(actionHeaders, headers);\n        prependCookies(loaderHeaders, headers);\n        prependCookies(parentHeaders, headers);\n        return headers;\n    }, new Headers());\n}\nfunction prependCookies(parentHeaders, childHeaders) {\n    let parentSetCookieString = parentHeaders.get(\"Set-Cookie\");\n    if (parentSetCookieString) {\n        let cookies = (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString);\n        let childCookies = new Set(childHeaders.getSetCookie());\n        cookies.forEach((cookie)=>{\n            if (!childCookies.has(cookie)) {\n                childHeaders.append(\"Set-Cookie\", cookie);\n            }\n        });\n    }\n}\n// lib/server-runtime/single-fetch.ts\nvar SERVER_NO_BODY_STATUS_CODES = /* @__PURE__ */ new Set([\n    ...NO_BODY_STATUS_CODES,\n    304\n]);\nasync function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n    try {\n        let respond2 = function(context) {\n            let headers = getDocumentHeaders(build, context);\n            if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n                return generateSingleFetchResponse(request, build, serverMode, {\n                    result: getSingleFetchRedirect(context.statusCode, headers, build.basename),\n                    headers,\n                    status: SINGLE_FETCH_REDIRECT_STATUS\n                });\n            }\n            if (context.errors) {\n                Object.values(context.errors).forEach((err)=>{\n                    if (!isRouteErrorResponse(err) || err.error) {\n                        handleError(err);\n                    }\n                });\n                context.errors = sanitizeErrors(context.errors, serverMode);\n            }\n            let singleFetchResult;\n            if (context.errors) {\n                singleFetchResult = {\n                    error: Object.values(context.errors)[0]\n                };\n            } else {\n                singleFetchResult = {\n                    data: Object.values(context.actionData || {})[0]\n                };\n            }\n            return generateSingleFetchResponse(request, build, serverMode, {\n                result: singleFetchResult,\n                headers,\n                status: context.statusCode\n            });\n        };\n        var respond = respond2;\n        let handlerRequest = new Request(handlerUrl, {\n            method: request.method,\n            body: request.body,\n            headers: request.headers,\n            signal: request.signal,\n            ...request.body ? {\n                duplex: \"half\"\n            } : void 0\n        });\n        let result = await staticHandler.query(handlerRequest, {\n            requestContext: loadContext,\n            skipLoaderErrorBubbling: true,\n            skipRevalidation: true,\n            unstable_respond: respond2\n        });\n        if (!isResponse(result)) {\n            result = respond2(result);\n        }\n        if (isRedirectResponse(result)) {\n            return generateSingleFetchResponse(request, build, serverMode, {\n                result: getSingleFetchRedirect(result.status, result.headers, build.basename),\n                headers: result.headers,\n                status: SINGLE_FETCH_REDIRECT_STATUS\n            });\n        }\n        return result;\n    } catch (error) {\n        handleError(error);\n        return generateSingleFetchResponse(request, build, serverMode, {\n            result: {\n                error\n            },\n            headers: new Headers(),\n            status: 500\n        });\n    }\n}\nasync function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {\n    try {\n        let respond2 = function(context) {\n            let headers = getDocumentHeaders(build, context);\n            if (isRedirectStatusCode(context.statusCode) && headers.has(\"Location\")) {\n                return generateSingleFetchResponse(request, build, serverMode, {\n                    result: {\n                        [SingleFetchRedirectSymbol]: getSingleFetchRedirect(context.statusCode, headers, build.basename)\n                    },\n                    headers,\n                    status: SINGLE_FETCH_REDIRECT_STATUS\n                });\n            }\n            if (context.errors) {\n                Object.values(context.errors).forEach((err)=>{\n                    if (!isRouteErrorResponse(err) || err.error) {\n                        handleError(err);\n                    }\n                });\n                context.errors = sanitizeErrors(context.errors, serverMode);\n            }\n            let results = {};\n            let loadedMatches = new Set(context.matches.filter((m)=>loadRouteIds ? loadRouteIds.has(m.route.id) : m.route.loader != null).map((m)=>m.route.id));\n            if (context.errors) {\n                for (let [id, error] of Object.entries(context.errors)){\n                    results[id] = {\n                        error\n                    };\n                }\n            }\n            for (let [id, data2] of Object.entries(context.loaderData)){\n                if (!(id in results) && loadedMatches.has(id)) {\n                    results[id] = {\n                        data: data2\n                    };\n                }\n            }\n            return generateSingleFetchResponse(request, build, serverMode, {\n                result: results,\n                headers,\n                status: context.statusCode\n            });\n        };\n        var respond = respond2;\n        let handlerRequest = new Request(handlerUrl, {\n            headers: request.headers,\n            signal: request.signal\n        });\n        let routesParam = new URL(request.url).searchParams.get(\"_routes\");\n        let loadRouteIds = routesParam ? new Set(routesParam.split(\",\")) : null;\n        let result = await staticHandler.query(handlerRequest, {\n            requestContext: loadContext,\n            filterMatchesToLoad: (m)=>!loadRouteIds || loadRouteIds.has(m.route.id),\n            skipLoaderErrorBubbling: true,\n            unstable_respond: respond2\n        });\n        if (!isResponse(result)) {\n            result = respond2(result);\n        }\n        if (isRedirectResponse(result)) {\n            return generateSingleFetchResponse(request, build, serverMode, {\n                result: {\n                    [SingleFetchRedirectSymbol]: getSingleFetchRedirect(result.status, result.headers, build.basename)\n                },\n                headers: result.headers,\n                status: SINGLE_FETCH_REDIRECT_STATUS\n            });\n        }\n        return result;\n    } catch (error) {\n        handleError(error);\n        return generateSingleFetchResponse(request, build, serverMode, {\n            result: {\n                root: {\n                    error\n                }\n            },\n            headers: new Headers(),\n            status: 500\n        });\n    }\n}\nfunction generateSingleFetchResponse(request, build, serverMode, { result, headers, status }) {\n    let resultHeaders = new Headers(headers);\n    resultHeaders.set(\"X-Remix-Response\", \"yes\");\n    if (SERVER_NO_BODY_STATUS_CODES.has(status)) {\n        return new Response(null, {\n            status,\n            headers: resultHeaders\n        });\n    }\n    resultHeaders.set(\"Content-Type\", \"text/x-script\");\n    return new Response(encodeViaTurboStream(result, request.signal, build.entry.module.streamTimeout, serverMode), {\n        status: status || 200,\n        headers: resultHeaders\n    });\n}\nfunction getSingleFetchRedirect(status, headers, basename) {\n    let redirect2 = headers.get(\"Location\");\n    if (basename) {\n        redirect2 = stripBasename(redirect2, basename) || redirect2;\n    }\n    return {\n        redirect: redirect2,\n        status,\n        revalidate: // Technically X-Remix-Revalidate isn't needed here - that was an implementation\n        // detail of ?_data requests as our way to tell the front end to revalidate when\n        // we didn't have a response body to include that information in.\n        // With single fetch, we tell the front end via this revalidate boolean field.\n        // However, we're respecting it for now because it may be something folks have\n        // used in their own responses\n        // TODO(v3): Consider removing or making this official public API\n        headers.has(\"X-Remix-Revalidate\") || headers.has(\"Set-Cookie\"),\n        reload: headers.has(\"X-Remix-Reload-Document\"),\n        replace: headers.has(\"X-Remix-Replace\")\n    };\n}\nfunction encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {\n    let controller = new AbortController();\n    let timeoutId = setTimeout(()=>controller.abort(new Error(\"Server Timeout\")), typeof streamTimeout === \"number\" ? streamTimeout : 4950);\n    requestSignal.addEventListener(\"abort\", ()=>clearTimeout(timeoutId));\n    return encode(data2, {\n        signal: controller.signal,\n        plugins: [\n            (value)=>{\n                if (value instanceof Error) {\n                    let { name, message, stack } = serverMode === \"production\" /* Production */  ? sanitizeError(value, serverMode) : value;\n                    return [\n                        \"SanitizedError\",\n                        name,\n                        message,\n                        stack\n                    ];\n                }\n                if (value instanceof ErrorResponseImpl) {\n                    let { data: data3, status, statusText } = value;\n                    return [\n                        \"ErrorResponse\",\n                        data3,\n                        status,\n                        statusText\n                    ];\n                }\n                if (value && typeof value === \"object\" && SingleFetchRedirectSymbol in value) {\n                    return [\n                        \"SingleFetchRedirect\",\n                        value[SingleFetchRedirectSymbol]\n                    ];\n                }\n            }\n        ],\n        postPlugins: [\n            (value)=>{\n                if (!value) return;\n                if (typeof value !== \"object\") return;\n                return [\n                    \"SingleFetchClassInstance\",\n                    Object.fromEntries(Object.entries(value))\n                ];\n            },\n            ()=>[\n                    \"SingleFetchFallback\"\n                ]\n        ]\n    });\n}\n// lib/server-runtime/server.ts\nfunction derive(build, mode) {\n    let routes = createRoutes(build.routes);\n    let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);\n    let serverMode = isServerMode(mode) ? mode : \"production\" /* Production */ ;\n    let staticHandler = createStaticHandler(dataRoutes, {\n        basename: build.basename\n    });\n    let errorHandler = build.entry.module.handleError || ((error, { request })=>{\n        if (serverMode !== \"test\" /* Test */  && !request.signal.aborted) {\n            console.error(// @ts-expect-error This is \"private\" from users but intended for internal use\n            isRouteErrorResponse(error) && error.error ? error.error : error);\n        }\n    });\n    return {\n        routes,\n        dataRoutes,\n        serverMode,\n        staticHandler,\n        errorHandler\n    };\n}\nvar createRequestHandler = (build, mode)=>{\n    let _build;\n    let routes;\n    let serverMode;\n    let staticHandler;\n    let errorHandler;\n    return async function requestHandler(request, initialContext) {\n        _build = typeof build === \"function\" ? await build() : build;\n        if (typeof build === \"function\") {\n            let derived = derive(_build, mode);\n            routes = derived.routes;\n            serverMode = derived.serverMode;\n            staticHandler = derived.staticHandler;\n            errorHandler = derived.errorHandler;\n        } else if (!routes || !serverMode || !staticHandler || !errorHandler) {\n            let derived = derive(_build, mode);\n            routes = derived.routes;\n            serverMode = derived.serverMode;\n            staticHandler = derived.staticHandler;\n            errorHandler = derived.errorHandler;\n        }\n        let params = {};\n        let loadContext;\n        let handleError = (error)=>{\n            if (mode === \"development\" /* Development */ ) {\n                getDevServerHooks()?.processRequestError?.(error);\n            }\n            errorHandler(error, {\n                context: loadContext,\n                params,\n                request\n            });\n        };\n        if (_build.future.unstable_middleware) {\n            if (initialContext == null) {\n                loadContext = new unstable_RouterContextProvider();\n            } else {\n                try {\n                    loadContext = new unstable_RouterContextProvider(initialContext);\n                } catch (e) {\n                    let error = new Error(`Unable to create initial \\`unstable_RouterContextProvider\\` instance. Please confirm you are returning an instance of \\`Map<unstable_routerContext, unknown>\\` from your \\`getLoadContext\\` function.\n\nError: ${e instanceof Error ? e.toString() : e}`);\n                    handleError(error);\n                    return returnLastResortErrorResponse(error, serverMode);\n                }\n            }\n        } else {\n            loadContext = initialContext || {};\n        }\n        let url = new URL(request.url);\n        let normalizedBasename = _build.basename || \"/\";\n        let normalizedPath = url.pathname;\n        if (stripBasename(normalizedPath, normalizedBasename) === \"/_root.data\") {\n            normalizedPath = normalizedBasename;\n        } else if (normalizedPath.endsWith(\".data\")) {\n            normalizedPath = normalizedPath.replace(/\\.data$/, \"\");\n        }\n        if (stripBasename(normalizedPath, normalizedBasename) !== \"/\" && normalizedPath.endsWith(\"/\")) {\n            normalizedPath = normalizedPath.slice(0, -1);\n        }\n        let isSpaMode = getBuildTimeHeader(request, \"X-React-Router-SPA-Mode\") === \"yes\";\n        if (!_build.ssr) {\n            if (_build.prerender.length === 0) {\n                isSpaMode = true;\n            } else if (!_build.prerender.includes(normalizedPath) && !_build.prerender.includes(normalizedPath + \"/\")) {\n                if (url.pathname.endsWith(\".data\")) {\n                    errorHandler(new ErrorResponseImpl(404, \"Not Found\", `Refusing to SSR the path \\`${normalizedPath}\\` because \\`ssr:false\\` is set and the path is not included in the \\`prerender\\` config, so in production the path will be a 404.`), {\n                        context: loadContext,\n                        params,\n                        request\n                    });\n                    return new Response(\"Not Found\", {\n                        status: 404,\n                        statusText: \"Not Found\"\n                    });\n                } else {\n                    isSpaMode = true;\n                }\n            }\n        }\n        let manifestUrl = getManifestPath(_build.routeDiscovery.manifestPath, normalizedBasename);\n        if (url.pathname === manifestUrl) {\n            try {\n                let res = await handleManifestRequest(_build, routes, url);\n                return res;\n            } catch (e) {\n                handleError(e);\n                return new Response(\"Unknown Server Error\", {\n                    status: 500\n                });\n            }\n        }\n        let matches = matchServerRoutes(routes, normalizedPath, _build.basename);\n        if (matches && matches.length > 0) {\n            Object.assign(params, matches[0].params);\n        }\n        let response;\n        if (url.pathname.endsWith(\".data\")) {\n            let handlerUrl = new URL(request.url);\n            handlerUrl.pathname = normalizedPath;\n            let singleFetchMatches = matchServerRoutes(routes, handlerUrl.pathname, _build.basename);\n            response = await handleSingleFetchRequest(serverMode, _build, staticHandler, request, handlerUrl, loadContext, handleError);\n            if (_build.entry.module.handleDataRequest) {\n                response = await _build.entry.module.handleDataRequest(response, {\n                    context: loadContext,\n                    params: singleFetchMatches ? singleFetchMatches[0].params : {},\n                    request\n                });\n                if (isRedirectResponse(response)) {\n                    let result = getSingleFetchRedirect(response.status, response.headers, _build.basename);\n                    if (request.method === \"GET\") {\n                        result = {\n                            [SingleFetchRedirectSymbol]: result\n                        };\n                    }\n                    let headers = new Headers(response.headers);\n                    headers.set(\"Content-Type\", \"text/x-script\");\n                    return new Response(encodeViaTurboStream(result, request.signal, _build.entry.module.streamTimeout, serverMode), {\n                        status: SINGLE_FETCH_REDIRECT_STATUS,\n                        headers\n                    });\n                }\n            }\n        } else if (!isSpaMode && matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {\n            response = await handleResourceRequest(serverMode, _build, staticHandler, matches.slice(-1)[0].route.id, request, loadContext, handleError);\n        } else {\n            let { pathname } = url;\n            let criticalCss = void 0;\n            if (_build.unstable_getCriticalCss) {\n                criticalCss = await _build.unstable_getCriticalCss({\n                    pathname\n                });\n            } else if (mode === \"development\" /* Development */  && getDevServerHooks()?.getCriticalCss) {\n                criticalCss = await getDevServerHooks()?.getCriticalCss?.(pathname);\n            }\n            response = await handleDocumentRequest(serverMode, _build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss);\n        }\n        if (request.method === \"HEAD\") {\n            return new Response(null, {\n                headers: response.headers,\n                status: response.status,\n                statusText: response.statusText\n            });\n        }\n        return response;\n    };\n};\nasync function handleManifestRequest(build, routes, url) {\n    if (build.assets.version !== url.searchParams.get(\"version\")) {\n        return new Response(null, {\n            status: 204,\n            headers: {\n                \"X-Remix-Reload-Document\": \"true\"\n            }\n        });\n    }\n    let patches = {};\n    if (url.searchParams.has(\"p\")) {\n        let paths = /* @__PURE__ */ new Set();\n        url.searchParams.getAll(\"p\").forEach((path)=>{\n            if (!path.startsWith(\"/\")) {\n                path = `/${path}`;\n            }\n            let segments = path.split(\"/\").slice(1);\n            segments.forEach((_, i)=>{\n                let partialPath = segments.slice(0, i + 1).join(\"/\");\n                paths.add(`/${partialPath}`);\n            });\n        });\n        for (let path of paths){\n            let matches = matchServerRoutes(routes, path, build.basename);\n            if (matches) {\n                for (let match of matches){\n                    let routeId = match.route.id;\n                    let route = build.assets.routes[routeId];\n                    if (route) {\n                        patches[routeId] = route;\n                    }\n                }\n            }\n        }\n        return Response.json(patches, {\n            headers: {\n                \"Cache-Control\": \"public, max-age=31536000, immutable\"\n            }\n        });\n    }\n    return new Response(\"Invalid Request\", {\n        status: 400\n    });\n}\nasync function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {\n    let response = request.method !== \"GET\" ? await singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) : await singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError);\n    return response;\n}\nasync function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, isSpaMode, criticalCss) {\n    try {\n        let response = await staticHandler.query(request, {\n            requestContext: loadContext,\n            unstable_respond: build.future.unstable_middleware ? (ctx)=>renderHtml(ctx, isSpaMode) : void 0\n        });\n        return isResponse(response) ? response : renderHtml(response, isSpaMode);\n    } catch (error) {\n        handleError(error);\n        return new Response(null, {\n            status: 500\n        });\n    }\n    async function renderHtml(context, isSpaMode2) {\n        if (isResponse(context)) {\n            return context;\n        }\n        let headers = getDocumentHeaders(build, context);\n        if (SERVER_NO_BODY_STATUS_CODES.has(context.statusCode)) {\n            return new Response(null, {\n                status: context.statusCode,\n                headers\n            });\n        }\n        if (context.errors) {\n            Object.values(context.errors).forEach((err)=>{\n                if (!isRouteErrorResponse(err) || err.error) {\n                    handleError(err);\n                }\n            });\n            context.errors = sanitizeErrors(context.errors, serverMode);\n        }\n        let state = {\n            loaderData: context.loaderData,\n            actionData: context.actionData,\n            errors: serializeErrors2(context.errors, serverMode)\n        };\n        let baseServerHandoff = {\n            basename: build.basename,\n            future: build.future,\n            routeDiscovery: build.routeDiscovery,\n            ssr: build.ssr,\n            isSpaMode: isSpaMode2\n        };\n        let entryContext = {\n            manifest: build.assets,\n            routeModules: createEntryRouteModules(build.routes),\n            staticHandlerContext: context,\n            criticalCss,\n            serverHandoffString: createServerHandoffString({\n                ...baseServerHandoff,\n                criticalCss\n            }),\n            serverHandoffStream: encodeViaTurboStream(state, request.signal, build.entry.module.streamTimeout, serverMode),\n            renderMeta: {},\n            future: build.future,\n            ssr: build.ssr,\n            routeDiscovery: build.routeDiscovery,\n            isSpaMode: isSpaMode2,\n            serializeError: (err)=>serializeError(err, serverMode)\n        };\n        let handleDocumentRequestFunction = build.entry.module.default;\n        try {\n            return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext, loadContext);\n        } catch (error) {\n            handleError(error);\n            let errorForSecondRender = error;\n            if (isResponse(error)) {\n                try {\n                    let data2 = await unwrapResponse(error);\n                    errorForSecondRender = new ErrorResponseImpl(error.status, error.statusText, data2);\n                } catch (e) {}\n            }\n            context = getStaticContextFromError(staticHandler.dataRoutes, context, errorForSecondRender);\n            if (context.errors) {\n                context.errors = sanitizeErrors(context.errors, serverMode);\n            }\n            let state2 = {\n                loaderData: context.loaderData,\n                actionData: context.actionData,\n                errors: serializeErrors2(context.errors, serverMode)\n            };\n            entryContext = {\n                ...entryContext,\n                staticHandlerContext: context,\n                serverHandoffString: createServerHandoffString(baseServerHandoff),\n                serverHandoffStream: encodeViaTurboStream(state2, request.signal, build.entry.module.streamTimeout, serverMode),\n                renderMeta: {}\n            };\n            try {\n                return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext, loadContext);\n            } catch (error2) {\n                handleError(error2);\n                return returnLastResortErrorResponse(error2, serverMode);\n            }\n        }\n    }\n}\nasync function handleResourceRequest(serverMode, build, staticHandler, routeId, request, loadContext, handleError) {\n    try {\n        let response = await staticHandler.queryRoute(request, {\n            routeId,\n            requestContext: loadContext,\n            unstable_respond: build.future.unstable_middleware ? (ctx)=>ctx : void 0\n        });\n        if (isResponse(response)) {\n            return response;\n        }\n        if (typeof response === \"string\") {\n            return new Response(response);\n        }\n        return Response.json(response);\n    } catch (error) {\n        if (isResponse(error)) {\n            error.headers.set(\"X-Remix-Catch\", \"yes\");\n            return error;\n        }\n        if (isRouteErrorResponse(error)) {\n            if (error) {\n                handleError(error);\n            }\n            return errorResponseToJson(error, serverMode);\n        }\n        if (error instanceof Error && error.message === \"Expected a response from queryRoute\") {\n            let newError = new Error(\"Expected a Response to be returned from resource route handler\");\n            handleError(newError);\n            return returnLastResortErrorResponse(newError, serverMode);\n        }\n        handleError(error);\n        return returnLastResortErrorResponse(error, serverMode);\n    }\n}\nfunction errorResponseToJson(errorResponse, serverMode) {\n    return Response.json(serializeError(// @ts-expect-error This is \"private\" from users but intended for internal use\n    errorResponse.error || new Error(\"Unexpected Server Error\"), serverMode), {\n        status: errorResponse.status,\n        statusText: errorResponse.statusText,\n        headers: {\n            \"X-Remix-Error\": \"yes\"\n        }\n    });\n}\nfunction returnLastResortErrorResponse(error, serverMode) {\n    let message = \"Unexpected Server Error\";\n    if (serverMode !== \"production\" /* Production */ ) {\n        message += `\n\n${String(error)}`;\n    }\n    return new Response(message, {\n        status: 500,\n        headers: {\n            \"Content-Type\": \"text/plain\"\n        }\n    });\n}\nfunction unwrapResponse(response) {\n    let contentType = response.headers.get(\"Content-Type\");\n    return contentType && /\\bapplication\\/json\\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();\n}\n// lib/server-runtime/sessions.ts\nfunction flash(name) {\n    return `__flash_${name}__`;\n}\nvar createSession = (initialData = {}, id = \"\")=>{\n    let map = new Map(Object.entries(initialData));\n    return {\n        get id () {\n            return id;\n        },\n        get data () {\n            return Object.fromEntries(map);\n        },\n        has (name) {\n            return map.has(name) || map.has(flash(name));\n        },\n        get (name) {\n            if (map.has(name)) return map.get(name);\n            let flashName = flash(name);\n            if (map.has(flashName)) {\n                let value = map.get(flashName);\n                map.delete(flashName);\n                return value;\n            }\n            return void 0;\n        },\n        set (name, value) {\n            map.set(name, value);\n        },\n        flash (name, value) {\n            map.set(flash(name), value);\n        },\n        unset (name) {\n            map.delete(name);\n        }\n    };\n};\nvar isSession = (object)=>{\n    return object != null && typeof object.id === \"string\" && typeof object.data !== \"undefined\" && typeof object.has === \"function\" && typeof object.get === \"function\" && typeof object.set === \"function\" && typeof object.flash === \"function\" && typeof object.unset === \"function\";\n};\nfunction createSessionStorage({ cookie: cookieArg, createData, readData, updateData, deleteData }) {\n    let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n    warnOnceAboutSigningSessionCookie(cookie);\n    return {\n        async getSession (cookieHeader, options) {\n            let id = cookieHeader && await cookie.parse(cookieHeader, options);\n            let data2 = id && await readData(id);\n            return createSession(data2 || {}, id || \"\");\n        },\n        async commitSession (session, options) {\n            let { id, data: data2 } = session;\n            let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;\n            if (id) {\n                await updateData(id, data2, expires);\n            } else {\n                id = await createData(data2, expires);\n            }\n            return cookie.serialize(id, options);\n        },\n        async destroySession (session, options) {\n            await deleteData(session.id);\n            return cookie.serialize(\"\", {\n                ...options,\n                maxAge: void 0,\n                expires: /* @__PURE__ */ new Date(0)\n            });\n        }\n    };\n}\nfunction warnOnceAboutSigningSessionCookie(cookie) {\n    warnOnce(cookie.isSigned, `The \"${cookie.name}\" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://reactrouter.com/explanation/sessions-and-cookies#signing-cookies for more information.`);\n}\n// lib/server-runtime/sessions/cookieStorage.ts\nfunction createCookieSessionStorage({ cookie: cookieArg } = {}) {\n    let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || \"__session\", cookieArg);\n    warnOnceAboutSigningSessionCookie(cookie);\n    return {\n        async getSession (cookieHeader, options) {\n            return createSession(cookieHeader && await cookie.parse(cookieHeader, options) || {});\n        },\n        async commitSession (session, options) {\n            let serializedCookie = await cookie.serialize(session.data, options);\n            if (serializedCookie.length > 4096) {\n                throw new Error(\"Cookie length will exceed browser maximum. Length: \" + serializedCookie.length);\n            }\n            return serializedCookie;\n        },\n        async destroySession (_session, options) {\n            return cookie.serialize(\"\", {\n                ...options,\n                maxAge: void 0,\n                expires: /* @__PURE__ */ new Date(0)\n            });\n        }\n    };\n}\n// lib/server-runtime/sessions/memoryStorage.ts\nfunction createMemorySessionStorage({ cookie } = {}) {\n    let map = /* @__PURE__ */ new Map();\n    return createSessionStorage({\n        cookie,\n        async createData (data2, expires) {\n            let id = Math.random().toString(36).substring(2, 10);\n            map.set(id, {\n                data: data2,\n                expires\n            });\n            return id;\n        },\n        async readData (id) {\n            if (map.has(id)) {\n                let { data: data2, expires } = map.get(id);\n                if (!expires || expires > /* @__PURE__ */ new Date()) {\n                    return data2;\n                }\n                if (expires) map.delete(id);\n            }\n            return null;\n        },\n        async updateData (id, data2, expires) {\n            map.set(id, {\n                data: data2,\n                expires\n            });\n        },\n        async deleteData (id) {\n            map.delete(id);\n        }\n    });\n}\n// lib/href.ts\nfunction href(path, ...args) {\n    let params = args[0];\n    return path.split(\"/\").map((segment)=>{\n        if (segment === \"*\") {\n            return params ? params[\"*\"] : void 0;\n        }\n        const match = segment.match(/^:([\\w-]+)(\\?)?/);\n        if (!match) return segment;\n        const param = match[1];\n        const value = params ? params[param] : void 0;\n        const isRequired = match[2] === void 0;\n        if (isRequired && value === void 0) {\n            throw Error(`Path '${path}' requires param '${param}' but it was not provided`);\n        }\n        return value;\n    }).filter((segment)=>segment !== void 0).join(\"/\");\n}\n// lib/dom/ssr/errors.ts\nfunction deserializeErrors2(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n        } else if (val && val.__type === \"Error\") {\n            if (val.__subType) {\n                let ErrorConstructor = window[val.__subType];\n                if (typeof ErrorConstructor === \"function\") {\n                    try {\n                        let error = new ErrorConstructor(val.message);\n                        error.stack = val.stack;\n                        serialized[key] = error;\n                    } catch (e) {}\n                }\n            }\n            if (serialized[key] == null) {\n                let error = new Error(val.message);\n                error.stack = val.stack;\n                serialized[key] = error;\n            }\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\n// lib/dom/ssr/hydration.tsx\nfunction getHydrationData(state, routes, getRouteInfo, location, basename, isSpaMode) {\n    let hydrationData = {\n        ...state,\n        loaderData: {\n            ...state.loaderData\n        }\n    };\n    let initialMatches = matchRoutes(routes, location, basename);\n    if (initialMatches) {\n        for (let match of initialMatches){\n            let routeId = match.route.id;\n            let routeInfo = getRouteInfo(routeId);\n            if (shouldHydrateRouteLoader(routeId, routeInfo.clientLoader, routeInfo.hasLoader, isSpaMode) && (routeInfo.hasHydrateFallback || !routeInfo.hasLoader)) {\n                delete hydrationData.loaderData[routeId];\n            } else if (!routeInfo.hasLoader) {\n                hydrationData.loaderData[routeId] = null;\n            }\n        }\n    }\n    return hydrationData;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvZGV2ZWxvcG1lbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OztDQVNDLEdBQ1k7QUFDYixJQUFJQSxXQUFXQyxPQUFPQyxNQUFNO0FBQzVCLElBQUlDLFlBQVlGLE9BQU9HLGNBQWM7QUFDckMsSUFBSUMsbUJBQW1CSixPQUFPSyx3QkFBd0I7QUFDdEQsSUFBSUMsb0JBQW9CTixPQUFPTyxtQkFBbUI7QUFDbEQsSUFBSUMsZUFBZVIsT0FBT1MsY0FBYztBQUN4QyxJQUFJQyxlQUFlVixPQUFPVyxTQUFTLENBQUNDLGNBQWM7QUFDbEQsSUFBSUMsY0FBYyxDQUFDQztJQUNqQixNQUFNQyxVQUFVRDtBQUNsQjtBQUNBLElBQUlFLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxRQUFRRCxJQUNmaEIsVUFBVWUsUUFBUUUsTUFBTTtRQUFFQyxLQUFLRixHQUFHLENBQUNDLEtBQUs7UUFBRUUsWUFBWTtJQUFLO0FBQy9EO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPckIsa0JBQWtCa0IsTUFDaEMsSUFBSSxDQUFDZCxhQUFha0IsSUFBSSxDQUFDTCxJQUFJSSxRQUFRQSxRQUFRRixRQUN6Q3ZCLFVBQVVxQixJQUFJSSxLQUFLO1lBQUVQLEtBQUssSUFBTUksSUFBSSxDQUFDRyxJQUFJO1lBQUVOLFlBQVksQ0FBRUssQ0FBQUEsT0FBT3RCLGlCQUFpQm9CLE1BQU1HLElBQUcsS0FBTUQsS0FBS0wsVUFBVTtRQUFDO0lBQ3RIO0lBQ0EsT0FBT0U7QUFDVDtBQUNBLElBQUlNLFVBQVUsQ0FBQ0MsS0FBS0MsWUFBWWQsU0FBWUEsQ0FBQUEsU0FBU2EsT0FBTyxPQUFPL0IsU0FBU1MsYUFBYXNCLFFBQVEsQ0FBQyxHQUFH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QUFLLElBQUk5SixTQUFTOEosZUFBZ0I7WUFDaEMsSUFBSXlILFVBQVV2UixNQUFNM0IsS0FBSyxDQUFDUSxFQUFFO1lBQzVCLElBQUl3OUMsWUFBWS9mLGFBQWEvcUI7WUFDN0IsSUFBSTllLHlCQUNGOGUsU0FDQThxQyxVQUFVdmEsWUFBWSxFQUN0QnVhLFVBQVVucEIsU0FBUyxFQUNuQjNDLGNBQ0k4ckIsQ0FBQUEsVUFBVUMsa0JBQWtCLElBQUksQ0FBQ0QsVUFBVW5wQixTQUFTLEdBQUc7Z0JBQzNELE9BQU9ycEIsY0FBYzVKLFVBQVUsQ0FBQ3NSLFFBQVE7WUFDMUMsT0FBTyxJQUFJLENBQUM4cUMsVUFBVW5wQixTQUFTLEVBQUU7Z0JBQy9CcnBCLGNBQWM1SixVQUFVLENBQUNzUixRQUFRLEdBQUc7WUFDdEM7UUFDRjtJQUNGO0lBQ0EsT0FBTzFIO0FBQ1Q7QUFDQSw2REFBNkQ7QUFDN0QsS0FBTTNTLENBQUFBLENBcUhOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNici1wcmlvcml6YWNhby8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZGlzdC9kZXZlbG9wbWVudC9pbmRleC5qcz8zYzc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcmVhY3Qtcm91dGVyIHY3LjYuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX190eXBlRXJyb3IgPSAobXNnKSA9PiB7XG4gIHRocm93IFR5cGVFcnJvcihtc2cpO1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IG1lbWJlci5oYXMob2JqKSB8fCBfX3R5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopKTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiBtZW1iZXIuaGFzKG9iaikgPyBfX3R5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIikgOiBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcblxuLy8gaW5kZXgudHNcbnZhciByZWFjdF9yb3V0ZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmVhY3Rfcm91dGVyX2V4cG9ydHMsIHtcbiAgQXdhaXQ6ICgpID0+IEF3YWl0LFxuICBCcm93c2VyUm91dGVyOiAoKSA9PiBCcm93c2VyUm91dGVyLFxuICBGb3JtOiAoKSA9PiBGb3JtLFxuICBIYXNoUm91dGVyOiAoKSA9PiBIYXNoUm91dGVyLFxuICBJRExFX0JMT0NLRVI6ICgpID0+IElETEVfQkxPQ0tFUixcbiAgSURMRV9GRVRDSEVSOiAoKSA9PiBJRExFX0ZFVENIRVIsXG4gIElETEVfTkFWSUdBVElPTjogKCkgPT4gSURMRV9OQVZJR0FUSU9OLFxuICBMaW5rOiAoKSA9PiBMaW5rLFxuICBMaW5rczogKCkgPT4gTGlua3MsXG4gIE1lbW9yeVJvdXRlcjogKCkgPT4gTWVtb3J5Um91dGVyLFxuICBNZXRhOiAoKSA9PiBNZXRhLFxuICBOYXZMaW5rOiAoKSA9PiBOYXZMaW5rLFxuICBOYXZpZ2F0ZTogKCkgPT4gTmF2aWdhdGUsXG4gIE5hdmlnYXRpb25UeXBlOiAoKSA9PiBBY3Rpb24sXG4gIE91dGxldDogKCkgPT4gT3V0bGV0LFxuICBQcmVmZXRjaFBhZ2VMaW5rczogKCkgPT4gUHJlZmV0Y2hQYWdlTGlua3MsXG4gIFJvdXRlOiAoKSA9PiBSb3V0ZSxcbiAgUm91dGVyOiAoKSA9PiBSb3V0ZXIsXG4gIFJvdXRlclByb3ZpZGVyOiAoKSA9PiBSb3V0ZXJQcm92aWRlcixcbiAgUm91dGVzOiAoKSA9PiBSb3V0ZXMsXG4gIFNjcmlwdHM6ICgpID0+IFNjcmlwdHMsXG4gIFNjcm9sbFJlc3RvcmF0aW9uOiAoKSA9PiBTY3JvbGxSZXN0b3JhdGlvbixcbiAgU2VydmVyUm91dGVyOiAoKSA9PiBTZXJ2ZXJSb3V0ZXIsXG4gIFN0YXRpY1JvdXRlcjogKCkgPT4gU3RhdGljUm91dGVyLFxuICBTdGF0aWNSb3V0ZXJQcm92aWRlcjogKCkgPT4gU3RhdGljUm91dGVyUHJvdmlkZXIsXG4gIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dDogKCkgPT4gRGF0YVJvdXRlckNvbnRleHQsXG4gIFVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0OiAoKSA9PiBEYXRhUm91dGVyU3RhdGVDb250ZXh0LFxuICBVTlNBRkVfRXJyb3JSZXNwb25zZUltcGw6ICgpID0+IEVycm9yUmVzcG9uc2VJbXBsLFxuICBVTlNBRkVfRmV0Y2hlcnNDb250ZXh0OiAoKSA9PiBGZXRjaGVyc0NvbnRleHQsXG4gIFVOU0FGRV9GcmFtZXdvcmtDb250ZXh0OiAoKSA9PiBGcmFtZXdvcmtDb250ZXh0LFxuICBVTlNBRkVfTG9jYXRpb25Db250ZXh0OiAoKSA9PiBMb2NhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dDogKCkgPT4gTmF2aWdhdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9SZW1peEVycm9yQm91bmRhcnk6ICgpID0+IFJlbWl4RXJyb3JCb3VuZGFyeSxcbiAgVU5TQUZFX1JvdXRlQ29udGV4dDogKCkgPT4gUm91dGVDb250ZXh0LFxuICBVTlNBRkVfU2VydmVyTW9kZTogKCkgPT4gU2VydmVyTW9kZSxcbiAgVU5TQUZFX1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2w6ICgpID0+IFNpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wsXG4gIFVOU0FGRV9WaWV3VHJhbnNpdGlvbkNvbnRleHQ6ICgpID0+IFZpZXdUcmFuc2l0aW9uQ29udGV4dCxcbiAgVU5TQUZFX2NyZWF0ZUJyb3dzZXJIaXN0b3J5OiAoKSA9PiBjcmVhdGVCcm93c2VySGlzdG9yeSxcbiAgVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlczogKCkgPT4gY3JlYXRlQ2xpZW50Um91dGVzLFxuICBVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dDogKCkgPT4gY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dCxcbiAgVU5TQUZFX2NyZWF0ZVJvdXRlcjogKCkgPT4gY3JlYXRlUm91dGVyLFxuICBVTlNBRkVfZGVjb2RlVmlhVHVyYm9TdHJlYW06ICgpID0+IGRlY29kZVZpYVR1cmJvU3RyZWFtLFxuICBVTlNBRkVfZGVzZXJpYWxpemVFcnJvcnM6ICgpID0+IGRlc2VyaWFsaXplRXJyb3JzMixcbiAgVU5TQUZFX2dldEh5ZHJhdGlvbkRhdGE6ICgpID0+IGdldEh5ZHJhdGlvbkRhdGEsXG4gIFVOU0FGRV9nZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uOiAoKSA9PiBnZXRQYXRjaFJvdXRlc09uTmF2aWdhdGlvbkZ1bmN0aW9uLFxuICBVTlNBRkVfZ2V0VHVyYm9TdHJlYW1TaW5nbGVGZXRjaERhdGFTdHJhdGVneTogKCkgPT4gZ2V0VHVyYm9TdHJlYW1TaW5nbGVGZXRjaERhdGFTdHJhdGVneSxcbiAgVU5TQUZFX2h5ZHJhdGlvblJvdXRlUHJvcGVydGllczogKCkgPT4gaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzLFxuICBVTlNBRkVfaW52YXJpYW50OiAoKSA9PiBpbnZhcmlhbnQsXG4gIFVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXM6ICgpID0+IG1hcFJvdXRlUHJvcGVydGllcyxcbiAgVU5TQUZFX3Nob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlcjogKCkgPT4gc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyLFxuICBVTlNBRkVfdXNlRm9nT0ZXYXJEaXNjb3Zlcnk6ICgpID0+IHVzZUZvZ09GV2FyRGlzY292ZXJ5LFxuICBVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb246ICgpID0+IHVzZVNjcm9sbFJlc3RvcmF0aW9uLFxuICBjcmVhdGVCcm93c2VyUm91dGVyOiAoKSA9PiBjcmVhdGVCcm93c2VyUm91dGVyLFxuICBjcmVhdGVDb29raWU6ICgpID0+IGNyZWF0ZUNvb2tpZSxcbiAgY3JlYXRlQ29va2llU2Vzc2lvblN0b3JhZ2U6ICgpID0+IGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVIYXNoUm91dGVyOiAoKSA9PiBjcmVhdGVIYXNoUm91dGVyLFxuICBjcmVhdGVNZW1vcnlSb3V0ZXI6ICgpID0+IGNyZWF0ZU1lbW9yeVJvdXRlcixcbiAgY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2U6ICgpID0+IGNyZWF0ZU1lbW9yeVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVQYXRoOiAoKSA9PiBjcmVhdGVQYXRoLFxuICBjcmVhdGVSZXF1ZXN0SGFuZGxlcjogKCkgPT4gY3JlYXRlUmVxdWVzdEhhbmRsZXIsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbjogKCkgPT4gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLFxuICBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHM6ICgpID0+IGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyxcbiAgY3JlYXRlUm91dGVzU3R1YjogKCkgPT4gY3JlYXRlUm91dGVzU3R1YixcbiAgY3JlYXRlU2VhcmNoUGFyYW1zOiAoKSA9PiBjcmVhdGVTZWFyY2hQYXJhbXMsXG4gIGNyZWF0ZVNlc3Npb246ICgpID0+IGNyZWF0ZVNlc3Npb24sXG4gIGNyZWF0ZVNlc3Npb25TdG9yYWdlOiAoKSA9PiBjcmVhdGVTZXNzaW9uU3RvcmFnZSxcbiAgY3JlYXRlU3RhdGljSGFuZGxlcjogKCkgPT4gY3JlYXRlU3RhdGljSGFuZGxlcjIsXG4gIGNyZWF0ZVN0YXRpY1JvdXRlcjogKCkgPT4gY3JlYXRlU3RhdGljUm91dGVyLFxuICBkYXRhOiAoKSA9PiBkYXRhLFxuICBnZW5lcmF0ZVBhdGg6ICgpID0+IGdlbmVyYXRlUGF0aCxcbiAgaHJlZjogKCkgPT4gaHJlZixcbiAgaXNDb29raWU6ICgpID0+IGlzQ29va2llLFxuICBpc1JvdXRlRXJyb3JSZXNwb25zZTogKCkgPT4gaXNSb3V0ZUVycm9yUmVzcG9uc2UsXG4gIGlzU2Vzc2lvbjogKCkgPT4gaXNTZXNzaW9uLFxuICBtYXRjaFBhdGg6ICgpID0+IG1hdGNoUGF0aCxcbiAgbWF0Y2hSb3V0ZXM6ICgpID0+IG1hdGNoUm91dGVzLFxuICBwYXJzZVBhdGg6ICgpID0+IHBhcnNlUGF0aCxcbiAgcmVkaXJlY3Q6ICgpID0+IHJlZGlyZWN0LFxuICByZWRpcmVjdERvY3VtZW50OiAoKSA9PiByZWRpcmVjdERvY3VtZW50LFxuICByZW5kZXJNYXRjaGVzOiAoKSA9PiByZW5kZXJNYXRjaGVzLFxuICByZXBsYWNlOiAoKSA9PiByZXBsYWNlLFxuICByZXNvbHZlUGF0aDogKCkgPT4gcmVzb2x2ZVBhdGgsXG4gIHVuc3RhYmxlX0hpc3RvcnlSb3V0ZXI6ICgpID0+IEhpc3RvcnlSb3V0ZXIsXG4gIHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlcjogKCkgPT4gdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyLFxuICB1bnN0YWJsZV9jcmVhdGVDb250ZXh0OiAoKSA9PiB1bnN0YWJsZV9jcmVhdGVDb250ZXh0LFxuICB1bnN0YWJsZV9zZXREZXZTZXJ2ZXJIb29rczogKCkgPT4gc2V0RGV2U2VydmVySG9va3MsXG4gIHVuc3RhYmxlX3VzZVByb21wdDogKCkgPT4gdXNlUHJvbXB0LFxuICB1c2VBY3Rpb25EYXRhOiAoKSA9PiB1c2VBY3Rpb25EYXRhLFxuICB1c2VBc3luY0Vycm9yOiAoKSA9PiB1c2VBc3luY0Vycm9yLFxuICB1c2VBc3luY1ZhbHVlOiAoKSA9PiB1c2VBc3luY1ZhbHVlLFxuICB1c2VCZWZvcmVVbmxvYWQ6ICgpID0+IHVzZUJlZm9yZVVubG9hZCxcbiAgdXNlQmxvY2tlcjogKCkgPT4gdXNlQmxvY2tlcixcbiAgdXNlRmV0Y2hlcjogKCkgPT4gdXNlRmV0Y2hlcixcbiAgdXNlRmV0Y2hlcnM6ICgpID0+IHVzZUZldGNoZXJzLFxuICB1c2VGb3JtQWN0aW9uOiAoKSA9PiB1c2VGb3JtQWN0aW9uLFxuICB1c2VIcmVmOiAoKSA9PiB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQ6ICgpID0+IHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTGlua0NsaWNrSGFuZGxlcjogKCkgPT4gdXNlTGlua0NsaWNrSGFuZGxlcixcbiAgdXNlTG9hZGVyRGF0YTogKCkgPT4gdXNlTG9hZGVyRGF0YSxcbiAgdXNlTG9jYXRpb246ICgpID0+IHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaDogKCkgPT4gdXNlTWF0Y2gsXG4gIHVzZU1hdGNoZXM6ICgpID0+IHVzZU1hdGNoZXMsXG4gIHVzZU5hdmlnYXRlOiAoKSA9PiB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvbjogKCkgPT4gdXNlTmF2aWdhdGlvbixcbiAgdXNlTmF2aWdhdGlvblR5cGU6ICgpID0+IHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQ6ICgpID0+IHVzZU91dGxldCxcbiAgdXNlT3V0bGV0Q29udGV4dDogKCkgPT4gdXNlT3V0bGV0Q29udGV4dCxcbiAgdXNlUGFyYW1zOiAoKSA9PiB1c2VQYXJhbXMsXG4gIHVzZVJlc29sdmVkUGF0aDogKCkgPT4gdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSZXZhbGlkYXRvcjogKCkgPT4gdXNlUmV2YWxpZGF0b3IsXG4gIHVzZVJvdXRlRXJyb3I6ICgpID0+IHVzZVJvdXRlRXJyb3IsXG4gIHVzZVJvdXRlTG9hZGVyRGF0YTogKCkgPT4gdXNlUm91dGVMb2FkZXJEYXRhLFxuICB1c2VSb3V0ZXM6ICgpID0+IHVzZVJvdXRlcyxcbiAgdXNlU2VhcmNoUGFyYW1zOiAoKSA9PiB1c2VTZWFyY2hQYXJhbXMsXG4gIHVzZVN1Ym1pdDogKCkgPT4gdXNlU3VibWl0LFxuICB1c2VWaWV3VHJhbnNpdGlvblN0YXRlOiAoKSA9PiB1c2VWaWV3VHJhbnNpdGlvblN0YXRlXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHJlYWN0X3JvdXRlcl9leHBvcnRzKTtcblxuLy8gbGliL3JvdXRlci9oaXN0b3J5LnRzXG52YXIgQWN0aW9uID0gLyogQF9fUFVSRV9fICovICgoQWN0aW9uMikgPT4ge1xuICBBY3Rpb24yW1wiUG9wXCJdID0gXCJQT1BcIjtcbiAgQWN0aW9uMltcIlB1c2hcIl0gPSBcIlBVU0hcIjtcbiAgQWN0aW9uMltcIlJlcGxhY2VcIl0gPSBcIlJFUExBQ0VcIjtcbiAgcmV0dXJuIEFjdGlvbjI7XG59KShBY3Rpb24gfHwge30pO1xudmFyIFBvcFN0YXRlRXZlbnRUeXBlID0gXCJwb3BzdGF0ZVwiO1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zID0ge30pIHtcbiAgbGV0IHsgaW5pdGlhbEVudHJpZXMgPSBbXCIvXCJdLCBpbml0aWFsSW5kZXgsIHY1Q29tcGF0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gIGxldCBlbnRyaWVzO1xuICBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKFxuICAgIChlbnRyeSwgaW5kZXgyKSA9PiBjcmVhdGVNZW1vcnlMb2NhdGlvbihcbiAgICAgIGVudHJ5LFxuICAgICAgdHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiID8gbnVsbCA6IGVudHJ5LnN0YXRlLFxuICAgICAgaW5kZXgyID09PSAwID8gXCJkZWZhdWx0XCIgOiB2b2lkIDBcbiAgICApXG4gICk7XG4gIGxldCBpbmRleCA9IGNsYW1wSW5kZXgoXG4gICAgaW5pdGlhbEluZGV4ID09IG51bGwgPyBlbnRyaWVzLmxlbmd0aCAtIDEgOiBpbml0aWFsSW5kZXhcbiAgKTtcbiAgbGV0IGFjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICBsZXQgbGlzdGVuZXIgPSBudWxsO1xuICBmdW5jdGlvbiBjbGFtcEluZGV4KG4pIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgMCksIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHJldHVybiBlbnRyaWVzW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUgPSBudWxsLCBrZXkpIHtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcbiAgICAgIGVudHJpZXMgPyBnZXRDdXJyZW50TG9jYXRpb24oKS5wYXRobmFtZSA6IFwiL1wiLFxuICAgICAgdG8sXG4gICAgICBzdGF0ZSxcbiAgICAgIGtleVxuICAgICk7XG4gICAgd2FybmluZyhcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gXCIvXCIsXG4gICAgICBgcmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX1gXG4gICAgKTtcbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZjIodG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IHtcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBnZXRDdXJyZW50TG9jYXRpb24oKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYyLFxuICAgIGNyZWF0ZVVSTCh0bykge1xuICAgICAgcmV0dXJuIG5ldyBVUkwoY3JlYXRlSHJlZjIodG8pLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gICAgfSxcbiAgICBlbmNvZGVMb2NhdGlvbih0bykge1xuICAgICAgbGV0IHBhdGggPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG87XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZTogcGF0aC5wYXRobmFtZSB8fCBcIlwiLFxuICAgICAgICBzZWFyY2g6IHBhdGguc2VhcmNoIHx8IFwiXCIsXG4gICAgICAgIGhhc2g6IHBhdGguaGFzaCB8fCBcIlwiXG4gICAgICB9O1xuICAgIH0sXG4gICAgcHVzaCh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IFwiUFVTSFwiIC8qIFB1c2ggKi87XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgZW50cmllcy5sZW5ndGgsIG5leHRMb2NhdGlvbik7XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sIGRlbHRhOiAxIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi87XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGVudHJpZXNbaW5kZXhdID0gbmV4dExvY2F0aW9uO1xuICAgICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YTogMCB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdvKGRlbHRhKSB7XG4gICAgICBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgICAgIGxldCBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGluZGV4ICsgZGVsdGEpO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGVudHJpZXNbbmV4dEluZGV4XTtcbiAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogbmV4dExvY2F0aW9uLCBkZWx0YSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KG9wdGlvbnMgPSB7fSkge1xuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VyTG9jYXRpb24od2luZG93MiwgZ2xvYmFsSGlzdG9yeSkge1xuICAgIGxldCB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSA9IHdpbmRvdzIubG9jYXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFxuICAgICAgXCJcIixcbiAgICAgIHsgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCB9LFxuICAgICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgICBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUudXNyIHx8IG51bGwsXG4gICAgICBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5IHx8IFwiZGVmYXVsdFwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VySHJlZih3aW5kb3cyLCB0bykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG4gIHJldHVybiBnZXRVcmxCYXNlZEhpc3RvcnkoXG4gICAgY3JlYXRlQnJvd3NlckxvY2F0aW9uLFxuICAgIGNyZWF0ZUJyb3dzZXJIcmVmLFxuICAgIG51bGwsXG4gICAgb3B0aW9uc1xuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3Rvcnkob3B0aW9ucyA9IHt9KSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hMb2NhdGlvbih3aW5kb3cyLCBnbG9iYWxIaXN0b3J5KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgICBzZWFyY2ggPSBcIlwiLFxuICAgICAgaGFzaCA9IFwiXCJcbiAgICB9ID0gcGFyc2VQYXRoKHdpbmRvdzIubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSkpO1xuICAgIGlmICghcGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgJiYgIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiICsgcGF0aG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcbiAgICAgIFwiXCIsXG4gICAgICB7IHBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSxcbiAgICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzciB8fCBudWxsLFxuICAgICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSB8fCBcImRlZmF1bHRcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaEhyZWYod2luZG93MiwgdG8pIHtcbiAgICBsZXQgYmFzZSA9IHdpbmRvdzIuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJhc2VcIik7XG4gICAgbGV0IGhyZWYyID0gXCJcIjtcbiAgICBpZiAoYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZShcImhyZWZcIikpIHtcbiAgICAgIGxldCB1cmwgPSB3aW5kb3cyLmxvY2F0aW9uLmhyZWY7XG4gICAgICBsZXQgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuICAgICAgaHJlZjIgPSBoYXNoSW5kZXggPT09IC0xID8gdXJsIDogdXJsLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBocmVmMiArIFwiI1wiICsgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0bykpO1xuICB9XG4gIGZ1bmN0aW9uIHZhbGlkYXRlSGFzaExvY2F0aW9uKGxvY2F0aW9uLCB0bykge1xuICAgIHdhcm5pbmcoXG4gICAgICBsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLFxuICAgICAgYHJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBoYXNoIGhpc3RvcnkucHVzaCgke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICB0b1xuICAgICAgKX0pYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShcbiAgICBjcmVhdGVIYXNoTG9jYXRpb24sXG4gICAgY3JlYXRlSGFzaEhyZWYsXG4gICAgdmFsaWRhdGVIYXNoTG9jYXRpb24sXG4gICAgb3B0aW9uc1xuICApO1xufVxuZnVuY3Rpb24gaW52YXJpYW50KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgdHJ5IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApO1xufVxuZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCkge1xuICByZXR1cm4ge1xuICAgIHVzcjogbG9jYXRpb24uc3RhdGUsXG4gICAga2V5OiBsb2NhdGlvbi5rZXksXG4gICAgaWR4OiBpbmRleFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oY3VycmVudCwgdG8sIHN0YXRlID0gbnVsbCwga2V5KSB7XG4gIGxldCBsb2NhdGlvbiA9IHtcbiAgICBwYXRobmFtZTogdHlwZW9mIGN1cnJlbnQgPT09IFwic3RyaW5nXCIgPyBjdXJyZW50IDogY3VycmVudC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IFwiXCIsXG4gICAgaGFzaDogXCJcIixcbiAgICAuLi50eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgodG8pIDogdG8sXG4gICAgc3RhdGUsXG4gICAgLy8gVE9ETzogVGhpcyBjb3VsZCBiZSBjbGVhbmVkIHVwLiAgcHVzaC9yZXBsYWNlIHNob3VsZCBwcm9iYWJseSBqdXN0IHRha2VcbiAgICAvLyBmdWxsIExvY2F0aW9ucyBub3cgYW5kIGF2b2lkIHRoZSBuZWVkIHRvIHJ1biB0aHJvdWdoIHRoaXMgZmxvdyBhdCBhbGxcbiAgICAvLyBCdXQgdGhhdCdzIGEgcHJldHR5IGJpZyByZWZhY3RvciB0byB0aGUgY3VycmVudCB0ZXN0IHN1aXRlIHNvIGdvaW5nIHRvXG4gICAgLy8ga2VlcCBhcyBpcyBmb3IgdGhlIHRpbWUgYmVpbmcgYW5kIGp1c3QgbGV0IGFueSBpbmNvbWluZyBrZXlzIHRha2UgcHJlY2VkZW5jZVxuICAgIGtleTogdG8gJiYgdG8ua2V5IHx8IGtleSB8fCBjcmVhdGVLZXkoKVxuICB9O1xuICByZXR1cm4gbG9jYXRpb247XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoKHtcbiAgcGF0aG5hbWUgPSBcIi9cIixcbiAgc2VhcmNoID0gXCJcIixcbiAgaGFzaCA9IFwiXCJcbn0pIHtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09IFwiP1wiKVxuICAgIHBhdGhuYW1lICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09IFwiP1wiID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4gIGlmIChoYXNoICYmIGhhc2ggIT09IFwiI1wiKVxuICAgIHBhdGhuYW1lICs9IGhhc2guY2hhckF0KDApID09PSBcIiNcIiA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4gIHJldHVybiBwYXRobmFtZTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0ge307XG4gIGlmIChwYXRoKSB7XG4gICAgbGV0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLmhhc2ggPSBwYXRoLnN1YnN0cmluZyhoYXNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuICAgIGxldCBzZWFyY2hJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHJpbmcoc2VhcmNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIHNlYXJjaEluZGV4KTtcbiAgICB9XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkUGF0aDtcbn1cbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShnZXRMb2NhdGlvbiwgY3JlYXRlSHJlZjIsIHZhbGlkYXRlTG9jYXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgeyB3aW5kb3c6IHdpbmRvdzIgPSBkb2N1bWVudC5kZWZhdWx0VmlldywgdjVDb21wYXQgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgbGV0IGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cyLmhpc3Rvcnk7XG4gIGxldCBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgbGV0IGluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoeyAuLi5nbG9iYWxIaXN0b3J5LnN0YXRlLCBpZHg6IGluZGV4IH0sIFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEluZGV4KCkge1xuICAgIGxldCBzdGF0ZSA9IGdsb2JhbEhpc3Rvcnkuc3RhdGUgfHwgeyBpZHg6IG51bGwgfTtcbiAgICByZXR1cm4gc3RhdGUuaWR4O1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVBvcCgpIHtcbiAgICBhY3Rpb24gPSBcIlBPUFwiIC8qIFBvcCAqLztcbiAgICBsZXQgbmV4dEluZGV4ID0gZ2V0SW5kZXgoKTtcbiAgICBsZXQgZGVsdGEgPSBuZXh0SW5kZXggPT0gbnVsbCA/IG51bGwgOiBuZXh0SW5kZXggLSBpbmRleDtcbiAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHsgYWN0aW9uLCBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbiwgZGVsdGEgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHB1c2godG8sIHN0YXRlKSB7XG4gICAgYWN0aW9uID0gXCJQVVNIXCIgLyogUHVzaCAqLztcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG4gICAgaW5kZXggPSBnZXRJbmRleCgpICsgMTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGVycm9yLm5hbWUgPT09IFwiRGF0YUNsb25lRXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHdpbmRvdzIubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgfVxuICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIoeyBhY3Rpb24sIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLCBkZWx0YTogMSB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZTIodG8sIHN0YXRlKSB7XG4gICAgYWN0aW9uID0gXCJSRVBMQUNFXCIgLyogUmVwbGFjZSAqLztcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG4gICAgaW5kZXggPSBnZXRJbmRleCgpO1xuICAgIGxldCBoaXN0b3J5U3RhdGUgPSBnZXRIaXN0b3J5U3RhdGUobG9jYXRpb24sIGluZGV4KTtcbiAgICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsIFwiXCIsIHVybCk7XG4gICAgaWYgKHY1Q29tcGF0ICYmIGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7IGFjdGlvbiwgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sIGRlbHRhOiAwIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVVUkwodG8pIHtcbiAgICByZXR1cm4gY3JlYXRlQnJvd3NlclVSTEltcGwodG8pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0ge1xuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGdldExvY2F0aW9uKHdpbmRvdzIsIGdsb2JhbEhpc3RvcnkpO1xuICAgIH0sXG4gICAgbGlzdGVuKGZuKSB7XG4gICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBoaXN0b3J5IG9ubHkgYWNjZXB0cyBvbmUgYWN0aXZlIGxpc3RlbmVyXCIpO1xuICAgICAgfVxuICAgICAgd2luZG93Mi5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdzIucmVtb3ZlRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgICAgICAgbGlzdGVuZXIgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZUhyZWYodG8pIHtcbiAgICAgIHJldHVybiBjcmVhdGVIcmVmMih3aW5kb3cyLCB0byk7XG4gICAgfSxcbiAgICBjcmVhdGVVUkwsXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIGxldCB1cmwgPSBjcmVhdGVVUkwodG8pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxuICAgICAgICBoYXNoOiB1cmwuaGFzaFxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgZ28obikge1xuICAgICAgcmV0dXJuIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJVUkxJbXBsKHRvLCBpc0Fic29sdXRlID0gZmFsc2UpIHtcbiAgbGV0IGJhc2UgPSBcImh0dHA6Ly9sb2NhbGhvc3RcIjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBiYXNlID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiAhPT0gXCJudWxsXCIgPyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIDogd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIH1cbiAgaW52YXJpYW50KGJhc2UsIFwiTm8gd2luZG93LmxvY2F0aW9uLihvcmlnaW58aHJlZikgYXZhaWxhYmxlIHRvIGNyZWF0ZSBVUkxcIik7XG4gIGxldCBocmVmMiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIGhyZWYyID0gaHJlZjIucmVwbGFjZSgvICQvLCBcIiUyMFwiKTtcbiAgaWYgKCFpc0Fic29sdXRlICYmIGhyZWYyLnN0YXJ0c1dpdGgoXCIvL1wiKSkge1xuICAgIGhyZWYyID0gYmFzZSArIGhyZWYyO1xuICB9XG4gIHJldHVybiBuZXcgVVJMKGhyZWYyLCBiYXNlKTtcbn1cblxuLy8gbGliL3JvdXRlci91dGlscy50c1xuZnVuY3Rpb24gdW5zdGFibGVfY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHsgZGVmYXVsdFZhbHVlIH07XG59XG52YXIgX21hcDtcbnZhciB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGluaXQpIHtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21hcCwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgaWYgKGluaXQpIHtcbiAgICAgIGZvciAobGV0IFtjb250ZXh0LCB2YWx1ZV0gb2YgaW5pdCkge1xuICAgICAgICB0aGlzLnNldChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldChjb250ZXh0KSB7XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfbWFwKS5oYXMoY29udGV4dCkpIHtcbiAgICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX21hcCkuZ2V0KGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5kZWZhdWx0VmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGNvbnRleHQuZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWx1ZSBmb3VuZCBmb3IgY29udGV4dFwiKTtcbiAgfVxuICBzZXQoY29udGV4dCwgdmFsdWUpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX21hcCkuc2V0KGNvbnRleHQsIHZhbHVlKTtcbiAgfVxufTtcbl9tYXAgPSBuZXcgV2Vha01hcCgpO1xudmFyIHVuc3VwcG9ydGVkTGF6eVJvdXRlT2JqZWN0S2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJsYXp5XCIsXG4gIFwiY2FzZVNlbnNpdGl2ZVwiLFxuICBcInBhdGhcIixcbiAgXCJpZFwiLFxuICBcImluZGV4XCIsXG4gIFwiY2hpbGRyZW5cIlxuXSk7XG5mdW5jdGlvbiBpc1Vuc3VwcG9ydGVkTGF6eVJvdXRlT2JqZWN0S2V5KGtleSkge1xuICByZXR1cm4gdW5zdXBwb3J0ZWRMYXp5Um91dGVPYmplY3RLZXlzLmhhcyhcbiAgICBrZXlcbiAgKTtcbn1cbnZhciB1bnN1cHBvcnRlZExhenlSb3V0ZUZ1bmN0aW9uS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJsYXp5XCIsXG4gIFwiY2FzZVNlbnNpdGl2ZVwiLFxuICBcInBhdGhcIixcbiAgXCJpZFwiLFxuICBcImluZGV4XCIsXG4gIFwidW5zdGFibGVfbWlkZGxld2FyZVwiLFxuICBcImNoaWxkcmVuXCJcbl0pO1xuZnVuY3Rpb24gaXNVbnN1cHBvcnRlZExhenlSb3V0ZUZ1bmN0aW9uS2V5KGtleSkge1xuICByZXR1cm4gdW5zdXBwb3J0ZWRMYXp5Um91dGVGdW5jdGlvbktleXMuaGFzKFxuICAgIGtleVxuICApO1xufVxuZnVuY3Rpb24gaXNJbmRleFJvdXRlKHJvdXRlKSB7XG4gIHJldHVybiByb3V0ZS5pbmRleCA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGVzLCBtYXBSb3V0ZVByb3BlcnRpZXMyLCBwYXJlbnRQYXRoID0gW10sIG1hbmlmZXN0ID0ge30pIHtcbiAgcmV0dXJuIHJvdXRlcy5tYXAoKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBTdHJpbmcoaW5kZXgpXTtcbiAgICBsZXQgaWQgPSB0eXBlb2Ygcm91dGUuaWQgPT09IFwic3RyaW5nXCIgPyByb3V0ZS5pZCA6IHRyZWVQYXRoLmpvaW4oXCItXCIpO1xuICAgIGludmFyaWFudChcbiAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlIHx8ICFyb3V0ZS5jaGlsZHJlbixcbiAgICAgIGBDYW5ub3Qgc3BlY2lmeSBjaGlsZHJlbiBvbiBhbiBpbmRleCByb3V0ZWBcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICFtYW5pZmVzdFtpZF0sXG4gICAgICBgRm91bmQgYSByb3V0ZSBpZCBjb2xsaXNpb24gb24gaWQgXCIke2lkfVwiLiAgUm91dGUgaWQncyBtdXN0IGJlIGdsb2JhbGx5IHVuaXF1ZSB3aXRoaW4gRGF0YSBSb3V0ZXIgdXNhZ2VzYFxuICAgICk7XG4gICAgaWYgKGlzSW5kZXhSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGxldCBpbmRleFJvdXRlID0ge1xuICAgICAgICAuLi5yb3V0ZSxcbiAgICAgICAgLi4ubWFwUm91dGVQcm9wZXJ0aWVzMihyb3V0ZSksXG4gICAgICAgIGlkXG4gICAgICB9O1xuICAgICAgbWFuaWZlc3RbaWRdID0gaW5kZXhSb3V0ZTtcbiAgICAgIHJldHVybiBpbmRleFJvdXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGF0aE9yTGF5b3V0Um91dGUgPSB7XG4gICAgICAgIC4uLnJvdXRlLFxuICAgICAgICAuLi5tYXBSb3V0ZVByb3BlcnRpZXMyKHJvdXRlKSxcbiAgICAgICAgaWQsXG4gICAgICAgIGNoaWxkcmVuOiB2b2lkIDBcbiAgICAgIH07XG4gICAgICBtYW5pZmVzdFtpZF0gPSBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICBwYXRoT3JMYXlvdXRSb3V0ZS5jaGlsZHJlbiA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgICAgICAgcm91dGUuY2hpbGRyZW4sXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgICB0cmVlUGF0aCxcbiAgICAgICAgICBtYW5pZmVzdFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhPckxheW91dFJvdXRlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSA9IFwiL1wiKSB7XG4gIHJldHVybiBtYXRjaFJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZywgYmFzZW5hbWUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSwgYWxsb3dQYXJ0aWFsKSB7XG4gIGxldCBsb2NhdGlvbiA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcbiAgbGV0IHBhdGhuYW1lID0gc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSB8fCBcIi9cIiwgYmFzZW5hbWUpO1xuICBpZiAocGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBicmFuY2hlcyA9IGZsYXR0ZW5Sb3V0ZXMocm91dGVzKTtcbiAgcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpO1xuICBsZXQgbWF0Y2hlcyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBtYXRjaGVzID09IG51bGwgJiYgaSA8IGJyYW5jaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGRlY29kZWQgPSBkZWNvZGVQYXRoKHBhdGhuYW1lKTtcbiAgICBtYXRjaGVzID0gbWF0Y2hSb3V0ZUJyYW5jaChcbiAgICAgIGJyYW5jaGVzW2ldLFxuICAgICAgZGVjb2RlZCxcbiAgICAgIGFsbG93UGFydGlhbFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaChtYXRjaCwgbG9hZGVyRGF0YSkge1xuICBsZXQgeyByb3V0ZSwgcGF0aG5hbWUsIHBhcmFtcyB9ID0gbWF0Y2g7XG4gIHJldHVybiB7XG4gICAgaWQ6IHJvdXRlLmlkLFxuICAgIHBhdGhuYW1lLFxuICAgIHBhcmFtcyxcbiAgICBkYXRhOiBsb2FkZXJEYXRhW3JvdXRlLmlkXSxcbiAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZVxuICB9O1xufVxuZnVuY3Rpb24gZmxhdHRlblJvdXRlcyhyb3V0ZXMsIGJyYW5jaGVzID0gW10sIHBhcmVudHNNZXRhID0gW10sIHBhcmVudFBhdGggPSBcIlwiKSB7XG4gIGxldCBmbGF0dGVuUm91dGUgPSAocm91dGUsIGluZGV4LCByZWxhdGl2ZVBhdGgpID0+IHtcbiAgICBsZXQgbWV0YSA9IHtcbiAgICAgIHJlbGF0aXZlUGF0aDogcmVsYXRpdmVQYXRoID09PSB2b2lkIDAgPyByb3V0ZS5wYXRoIHx8IFwiXCIgOiByZWxhdGl2ZVBhdGgsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSB0cnVlLFxuICAgICAgY2hpbGRyZW5JbmRleDogaW5kZXgsXG4gICAgICByb3V0ZVxuICAgIH07XG4gICAgaWYgKG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIG1ldGEucmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgocGFyZW50UGF0aCksXG4gICAgICAgIGBBYnNvbHV0ZSByb3V0ZSBwYXRoIFwiJHttZXRhLnJlbGF0aXZlUGF0aH1cIiBuZXN0ZWQgdW5kZXIgcGF0aCBcIiR7cGFyZW50UGF0aH1cIiBpcyBub3QgdmFsaWQuIEFuIGFic29sdXRlIGNoaWxkIHJvdXRlIHBhdGggbXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5gXG4gICAgICApO1xuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gam9pblBhdGhzKFtwYXJlbnRQYXRoLCBtZXRhLnJlbGF0aXZlUGF0aF0pO1xuICAgIGxldCByb3V0ZXNNZXRhID0gcGFyZW50c01ldGEuY29uY2F0KG1ldGEpO1xuICAgIGlmIChyb3V0ZS5jaGlsZHJlbiAmJiByb3V0ZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIC8vIE91ciB0eXBlcyBrbm93IGJldHRlciwgYnV0IHJ1bnRpbWUgSlMgbWF5IG5vdCFcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSxcbiAgICAgICAgYEluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkIHJvdXRlcy4gUGxlYXNlIHJlbW92ZSBhbGwgY2hpbGQgcm91dGVzIGZyb20gcm91dGUgcGF0aCBcIiR7cGF0aH1cIi5gXG4gICAgICApO1xuICAgICAgZmxhdHRlblJvdXRlcyhyb3V0ZS5jaGlsZHJlbiwgYnJhbmNoZXMsIHJvdXRlc01ldGEsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBicmFuY2hlcy5wdXNoKHtcbiAgICAgIHBhdGgsXG4gICAgICBzY29yZTogY29tcHV0ZVNjb3JlKHBhdGgsIHJvdXRlLmluZGV4KSxcbiAgICAgIHJvdXRlc01ldGFcbiAgICB9KTtcbiAgfTtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGlmIChyb3V0ZS5wYXRoID09PSBcIlwiIHx8ICFyb3V0ZS5wYXRoPy5pbmNsdWRlcyhcIj9cIikpIHtcbiAgICAgIGZsYXR0ZW5Sb3V0ZShyb3V0ZSwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBleHBsb2RlZCBvZiBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhyb3V0ZS5wYXRoKSkge1xuICAgICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4LCBleHBsb2RlZCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGJyYW5jaGVzO1xufVxuZnVuY3Rpb24gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocGF0aCkge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IHNlZ21lbnRzO1xuICBsZXQgaXNPcHRpb25hbCA9IGZpcnN0LmVuZHNXaXRoKFwiP1wiKTtcbiAgbGV0IHJlcXVpcmVkID0gZmlyc3QucmVwbGFjZSgvXFw/JC8sIFwiXCIpO1xuICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaXNPcHRpb25hbCA/IFtyZXF1aXJlZCwgXCJcIl0gOiBbcmVxdWlyZWRdO1xuICB9XG4gIGxldCByZXN0RXhwbG9kZWQgPSBleHBsb2RlT3B0aW9uYWxTZWdtZW50cyhyZXN0LmpvaW4oXCIvXCIpKTtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICByZXN1bHQucHVzaChcbiAgICAuLi5yZXN0RXhwbG9kZWQubWFwKFxuICAgICAgKHN1YnBhdGgpID0+IHN1YnBhdGggPT09IFwiXCIgPyByZXF1aXJlZCA6IFtyZXF1aXJlZCwgc3VicGF0aF0uam9pbihcIi9cIilcbiAgICApXG4gICk7XG4gIGlmIChpc09wdGlvbmFsKSB7XG4gICAgcmVzdWx0LnB1c2goLi4ucmVzdEV4cGxvZGVkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0Lm1hcChcbiAgICAoZXhwbG9kZWQpID0+IHBhdGguc3RhcnRzV2l0aChcIi9cIikgJiYgZXhwbG9kZWQgPT09IFwiXCIgPyBcIi9cIiA6IGV4cGxvZGVkXG4gICk7XG59XG5mdW5jdGlvbiByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcykge1xuICBicmFuY2hlcy5zb3J0KFxuICAgIChhLCBiKSA9PiBhLnNjb3JlICE9PSBiLnNjb3JlID8gYi5zY29yZSAtIGEuc2NvcmUgOiBjb21wYXJlSW5kZXhlcyhcbiAgICAgIGEucm91dGVzTWV0YS5tYXAoKG1ldGEpID0+IG1ldGEuY2hpbGRyZW5JbmRleCksXG4gICAgICBiLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpXG4gICAgKVxuICApO1xufVxudmFyIHBhcmFtUmUgPSAvXjpbXFx3LV0rJC87XG52YXIgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG52YXIgaW5kZXhSb3V0ZVZhbHVlID0gMjtcbnZhciBlbXB0eVNlZ21lbnRWYWx1ZSA9IDE7XG52YXIgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG52YXIgc3BsYXRQZW5hbHR5ID0gLTI7XG52YXIgaXNTcGxhdCA9IChzKSA9PiBzID09PSBcIipcIjtcbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShwYXRoLCBpbmRleCkge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgbGV0IGluaXRpYWxTY29yZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgaWYgKHNlZ21lbnRzLnNvbWUoaXNTcGxhdCkpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gc3BsYXRQZW5hbHR5O1xuICB9XG4gIGlmIChpbmRleCkge1xuICAgIGluaXRpYWxTY29yZSArPSBpbmRleFJvdXRlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRzLmZpbHRlcigocykgPT4gIWlzU3BsYXQocykpLnJlZHVjZShcbiAgICAoc2NvcmUsIHNlZ21lbnQpID0+IHNjb3JlICsgKHBhcmFtUmUudGVzdChzZWdtZW50KSA/IGR5bmFtaWNTZWdtZW50VmFsdWUgOiBzZWdtZW50ID09PSBcIlwiID8gZW1wdHlTZWdtZW50VmFsdWUgOiBzdGF0aWNTZWdtZW50VmFsdWUpLFxuICAgIGluaXRpYWxTY29yZVxuICApO1xufVxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYSwgYikge1xuICBsZXQgc2libGluZ3MgPSBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuICByZXR1cm4gc2libGluZ3MgPyAoXG4gICAgLy8gSWYgdHdvIHJvdXRlcyBhcmUgc2libGluZ3MsIHdlIHNob3VsZCB0cnkgdG8gbWF0Y2ggdGhlIGVhcmxpZXIgc2libGluZ1xuICAgIC8vIGZpcnN0LiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gaGF2ZSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBtYXRjaGluZ1xuICAgIC8vIGJlaGF2aW9yIGJ5IHNpbXBseSBwdXR0aW5nIHJvdXRlcyB3aXRoIGlkZW50aWNhbCBwYXRocyBpbiB0aGUgb3JkZXIgdGhleVxuICAgIC8vIHdhbnQgdGhlbSB0cmllZC5cbiAgICBhW2EubGVuZ3RoIC0gMV0gLSBiW2IubGVuZ3RoIC0gMV1cbiAgKSA6IChcbiAgICAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gICAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXG4gICAgMFxuICApO1xufVxuZnVuY3Rpb24gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2gsIHBhdGhuYW1lLCBhbGxvd1BhcnRpYWwgPSBmYWxzZSkge1xuICBsZXQgeyByb3V0ZXNNZXRhIH0gPSBicmFuY2g7XG4gIGxldCBtYXRjaGVkUGFyYW1zID0ge307XG4gIGxldCBtYXRjaGVkUGF0aG5hbWUgPSBcIi9cIjtcbiAgbGV0IG1hdGNoZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZXNNZXRhLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IG1ldGEgPSByb3V0ZXNNZXRhW2ldO1xuICAgIGxldCBlbmQgPSBpID09PSByb3V0ZXNNZXRhLmxlbmd0aCAtIDE7XG4gICAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZFBhdGhuYW1lID09PSBcIi9cIiA/IHBhdGhuYW1lIDogcGF0aG5hbWUuc2xpY2UobWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCkgfHwgXCIvXCI7XG4gICAgbGV0IG1hdGNoID0gbWF0Y2hQYXRoKFxuICAgICAgeyBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCwgY2FzZVNlbnNpdGl2ZTogbWV0YS5jYXNlU2Vuc2l0aXZlLCBlbmQgfSxcbiAgICAgIHJlbWFpbmluZ1BhdGhuYW1lXG4gICAgKTtcbiAgICBsZXQgcm91dGUgPSBtZXRhLnJvdXRlO1xuICAgIGlmICghbWF0Y2ggJiYgZW5kICYmIGFsbG93UGFydGlhbCAmJiAhcm91dGVzTWV0YVtyb3V0ZXNNZXRhLmxlbmd0aCAtIDFdLnJvdXRlLmluZGV4KSB7XG4gICAgICBtYXRjaCA9IG1hdGNoUGF0aChcbiAgICAgICAge1xuICAgICAgICAgIHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLFxuICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgICBlbmQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihtYXRjaGVkUGFyYW1zLCBtYXRjaC5wYXJhbXMpO1xuICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAvLyBUT0RPOiBDYW4gdGhpcyBhcyBiZSBhdm9pZGVkP1xuICAgICAgcGFyYW1zOiBtYXRjaGVkUGFyYW1zLFxuICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBub3JtYWxpemVQYXRobmFtZShcbiAgICAgICAgam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gICAgICApLFxuICAgICAgcm91dGVcbiAgICB9KTtcbiAgICBpZiAobWF0Y2gucGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgICAgbWF0Y2hlZFBhdGhuYW1lID0gam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0aChvcmlnaW5hbFBhdGgsIHBhcmFtcyA9IHt9KSB7XG4gIGxldCBwYXRoID0gb3JpZ2luYWxQYXRoO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikgJiYgcGF0aCAhPT0gXCIqXCIgJiYgIXBhdGguZW5kc1dpdGgoXCIvKlwiKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgICApO1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IHBhdGguc3RhcnRzV2l0aChcIi9cIikgPyBcIi9cIiA6IFwiXCI7XG4gIGNvbnN0IHN0cmluZ2lmeTIgPSAocCkgPT4gcCA9PSBudWxsID8gXCJcIiA6IHR5cGVvZiBwID09PSBcInN0cmluZ1wiID8gcCA6IFN0cmluZyhwKTtcbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KC9cXC8rLykubWFwKChzZWdtZW50LCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gaW5kZXggPT09IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgaWYgKGlzTGFzdFNlZ21lbnQgJiYgc2VnbWVudCA9PT0gXCIqXCIpIHtcbiAgICAgIGNvbnN0IHN0YXIgPSBcIipcIjtcbiAgICAgIHJldHVybiBzdHJpbmdpZnkyKHBhcmFtc1tzdGFyXSk7XG4gICAgfVxuICAgIGNvbnN0IGtleU1hdGNoID0gc2VnbWVudC5tYXRjaCgvXjooW1xcdy1dKykoXFw/PykkLyk7XG4gICAgaWYgKGtleU1hdGNoKSB7XG4gICAgICBjb25zdCBbLCBrZXksIG9wdGlvbmFsXSA9IGtleU1hdGNoO1xuICAgICAgbGV0IHBhcmFtID0gcGFyYW1zW2tleV07XG4gICAgICBpbnZhcmlhbnQob3B0aW9uYWwgPT09IFwiP1wiIHx8IHBhcmFtICE9IG51bGwsIGBNaXNzaW5nIFwiOiR7a2V5fVwiIHBhcmFtYCk7XG4gICAgICByZXR1cm4gc3RyaW5naWZ5MihwYXJhbSk7XG4gICAgfVxuICAgIHJldHVybiBzZWdtZW50LnJlcGxhY2UoL1xcPyQvZywgXCJcIik7XG4gIH0pLmZpbHRlcigoc2VnbWVudCkgPT4gISFzZWdtZW50KTtcbiAgcmV0dXJuIHByZWZpeCArIHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hQYXRoKHBhdHRlcm4sIHBhdGhuYW1lKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHBhdHRlcm4gPSB7IHBhdGg6IHBhdHRlcm4sIGNhc2VTZW5zaXRpdmU6IGZhbHNlLCBlbmQ6IHRydWUgfTtcbiAgfVxuICBsZXQgW21hdGNoZXIsIGNvbXBpbGVkUGFyYW1zXSA9IGNvbXBpbGVQYXRoKFxuICAgIHBhdHRlcm4ucGF0aCxcbiAgICBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsXG4gICAgcGF0dGVybi5lbmRcbiAgKTtcbiAgbGV0IG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobWF0Y2hlcik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gbWF0Y2hbMF07XG4gIGxldCBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWUucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICBsZXQgY2FwdHVyZUdyb3VwcyA9IG1hdGNoLnNsaWNlKDEpO1xuICBsZXQgcGFyYW1zID0gY29tcGlsZWRQYXJhbXMucmVkdWNlKFxuICAgIChtZW1vMiwgeyBwYXJhbU5hbWUsIGlzT3B0aW9uYWwgfSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChwYXJhbU5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgICAgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnNsaWNlKDAsIG1hdGNoZWRQYXRobmFtZS5sZW5ndGggLSBzcGxhdFZhbHVlLmxlbmd0aCkucmVwbGFjZSgvKC4pXFwvKyQvLCBcIiQxXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XTtcbiAgICAgIGlmIChpc09wdGlvbmFsICYmICF2YWx1ZSkge1xuICAgICAgICBtZW1vMltwYXJhbU5hbWVdID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVtbzJbcGFyYW1OYW1lXSA9ICh2YWx1ZSB8fCBcIlwiKS5yZXBsYWNlKC8lMkYvZywgXCIvXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW8yO1xuICAgIH0sXG4gICAge31cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoZWRQYXRobmFtZSxcbiAgICBwYXRobmFtZUJhc2UsXG4gICAgcGF0dGVyblxuICB9O1xufVxuZnVuY3Rpb24gY29tcGlsZVBhdGgocGF0aCwgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLCBlbmQgPSB0cnVlKSB7XG4gIHdhcm5pbmcoXG4gICAgcGF0aCA9PT0gXCIqXCIgfHwgIXBhdGguZW5kc1dpdGgoXCIqXCIpIHx8IHBhdGguZW5kc1dpdGgoXCIvKlwiKSxcbiAgICBgUm91dGUgcGF0aCBcIiR7cGF0aH1cIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIiBiZWNhdXNlIHRoZSBcXGAqXFxgIGNoYXJhY3RlciBtdXN0IGFsd2F5cyBmb2xsb3cgYSBcXGAvXFxgIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgcGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcIiR7cGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKX1cIi5gXG4gICk7XG4gIGxldCBwYXJhbXMgPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9IFwiXlwiICsgcGF0aC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKS5yZXBsYWNlKC9bXFxcXC4qK14ke318KClbXFxdXS9nLCBcIlxcXFwkJlwiKS5yZXBsYWNlKFxuICAgIC9cXC86KFtcXHctXSspKFxcPyk/L2csXG4gICAgKF8sIHBhcmFtTmFtZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgcGFyYW1zLnB1c2goeyBwYXJhbU5hbWUsIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwgIT0gbnVsbCB9KTtcbiAgICAgIHJldHVybiBpc09wdGlvbmFsID8gXCIvPyhbXlxcXFwvXSspP1wiIDogXCIvKFteXFxcXC9dKylcIjtcbiAgICB9XG4gICk7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtcy5wdXNoKHsgcGFyYW1OYW1lOiBcIipcIiB9KTtcbiAgICByZWdleHBTb3VyY2UgKz0gcGF0aCA9PT0gXCIqXCIgfHwgcGF0aCA9PT0gXCIvKlwiID8gXCIoLiopJFwiIDogXCIoPzpcXFxcLyguKyl8XFxcXC8qKSRcIjtcbiAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gXCJcXFxcLyokXCI7XG4gIH0gZWxzZSBpZiAocGF0aCAhPT0gXCJcIiAmJiBwYXRoICE9PSBcIi9cIikge1xuICAgIHJlZ2V4cFNvdXJjZSArPSBcIig/Oig/PVxcXFwvfCQpKVwiO1xuICB9IGVsc2Uge1xuICB9XG4gIGxldCBtYXRjaGVyID0gbmV3IFJlZ0V4cChyZWdleHBTb3VyY2UsIGNhc2VTZW5zaXRpdmUgPyB2b2lkIDAgOiBcImlcIik7XG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1zXTtcbn1cbmZ1bmN0aW9uIGRlY29kZVBhdGgodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoXCIvXCIpLm1hcCgodikgPT4gZGVjb2RlVVJJQ29tcG9uZW50KHYpLnJlcGxhY2UoL1xcLy9nLCBcIiUyRlwiKSkuam9pbihcIi9cIik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFRoZSBVUkwgcGF0aCBcIiR7dmFsdWV9XCIgY291bGQgbm90IGJlIGRlY29kZWQgYmVjYXVzZSBpdCBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseSBkdWUgdG8gYSBiYWQgcGVyY2VudCBlbmNvZGluZyAoJHtlcnJvcn0pLmBcbiAgICApO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRobmFtZSwgYmFzZW5hbWUpIHtcbiAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikgcmV0dXJuIHBhdGhuYW1lO1xuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBzdGFydEluZGV4ID0gYmFzZW5hbWUuZW5kc1dpdGgoXCIvXCIpID8gYmFzZW5hbWUubGVuZ3RoIC0gMSA6IGJhc2VuYW1lLmxlbmd0aDtcbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KHN0YXJ0SW5kZXgpO1xuICBpZiAobmV4dENoYXIgJiYgbmV4dENoYXIgIT09IFwiL1wiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKHN0YXJ0SW5kZXgpIHx8IFwiL1wiO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgodG8sIGZyb21QYXRobmFtZSA9IFwiL1wiKSB7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIlxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICBsZXQgcGF0aG5hbWUgPSB0b1BhdGhuYW1lID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSA/IHRvUGF0aG5hbWUgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKSA6IGZyb21QYXRobmFtZTtcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaClcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGgsIGZyb21QYXRobmFtZSkge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiLi5cIikge1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFBhdGhFcnJvcihjaGFyLCBmaWVsZCwgZGVzdCwgcGF0aCkge1xuICByZXR1cm4gYENhbm5vdCBpbmNsdWRlIGEgJyR7Y2hhcn0nIGNoYXJhY3RlciBpbiBhIG1hbnVhbGx5IHNwZWNpZmllZCBcXGB0by4ke2ZpZWxkfVxcYCBmaWVsZCBbJHtKU09OLnN0cmluZ2lmeShcbiAgICBwYXRoXG4gICl9XS4gIFBsZWFzZSBzZXBhcmF0ZSBpdCBvdXQgdG8gdGhlIFxcYHRvLiR7ZGVzdH1cXGAgZmllbGQuIEFsdGVybmF0aXZlbHkgeW91IG1heSBwcm92aWRlIHRoZSBmdWxsIHBhdGggYXMgYSBzdHJpbmcgaW4gPExpbmsgdG89XCIuLi5cIj4gYW5kIHRoZSByb3V0ZXIgd2lsbCBwYXJzZSBpdCBmb3IgeW91LmA7XG59XG5mdW5jdGlvbiBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIHJldHVybiBtYXRjaGVzLmZpbHRlcihcbiAgICAobWF0Y2gsIGluZGV4KSA9PiBpbmRleCA9PT0gMCB8fCBtYXRjaC5yb3V0ZS5wYXRoICYmIG1hdGNoLnJvdXRlLnBhdGgubGVuZ3RoID4gMFxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIGxldCBwYXRoTWF0Y2hlcyA9IGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpO1xuICByZXR1cm4gcGF0aE1hdGNoZXMubWFwKFxuICAgIChtYXRjaCwgaWR4KSA9PiBpZHggPT09IHBhdGhNYXRjaGVzLmxlbmd0aCAtIDEgPyBtYXRjaC5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZVxuICApO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRvKHRvQXJnLCByb3V0ZVBhdGhuYW1lcywgbG9jYXRpb25QYXRobmFtZSwgaXNQYXRoUmVsYXRpdmUgPSBmYWxzZSkge1xuICBsZXQgdG87XG4gIGlmICh0eXBlb2YgdG9BcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0byA9IHBhcnNlUGF0aCh0b0FyZyk7XG4gIH0gZWxzZSB7XG4gICAgdG8gPSB7IC4uLnRvQXJnIH07XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIj9cIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiP1wiLCBcInBhdGhuYW1lXCIsIFwic2VhcmNoXCIsIHRvKVxuICAgICk7XG4gICAgaW52YXJpYW50KFxuICAgICAgIXRvLnBhdGhuYW1lIHx8ICF0by5wYXRobmFtZS5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInBhdGhuYW1lXCIsIFwiaGFzaFwiLCB0bylcbiAgICApO1xuICAgIGludmFyaWFudChcbiAgICAgICF0by5zZWFyY2ggfHwgIXRvLnNlYXJjaC5pbmNsdWRlcyhcIiNcIiksXG4gICAgICBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInNlYXJjaFwiLCBcImhhc2hcIiwgdG8pXG4gICAgKTtcbiAgfVxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcbiAgbGV0IHRvUGF0aG5hbWUgPSBpc0VtcHR5UGF0aCA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG4gIGxldCBmcm9tO1xuICBpZiAodG9QYXRobmFtZSA9PSBudWxsKSB7XG4gICAgZnJvbSA9IGxvY2F0aW9uUGF0aG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJvdXRlUGF0aG5hbWVJbmRleCA9IHJvdXRlUGF0aG5hbWVzLmxlbmd0aCAtIDE7XG4gICAgaWYgKCFpc1BhdGhSZWxhdGl2ZSAmJiB0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cbiAgICAgIHRvLnBhdGhuYW1lID0gdG9TZWdtZW50cy5qb2luKFwiL1wiKTtcbiAgICB9XG4gICAgZnJvbSA9IHJvdXRlUGF0aG5hbWVJbmRleCA+PSAwID8gcm91dGVQYXRobmFtZXNbcm91dGVQYXRobmFtZUluZGV4XSA6IFwiL1wiO1xuICB9XG4gIGxldCBwYXRoID0gcmVzb2x2ZVBhdGgodG8sIGZyb20pO1xuICBsZXQgaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoID0gdG9QYXRobmFtZSAmJiB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgbGV0IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoID0gKGlzRW1wdHlQYXRoIHx8IHRvUGF0aG5hbWUgPT09IFwiLlwiKSAmJiBsb2NhdGlvblBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKTtcbiAgaWYgKCFwYXRoLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJiAoaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIHx8IGhhc0N1cnJlbnRUcmFpbGluZ1NsYXNoKSkge1xuICAgIHBhdGgucGF0aG5hbWUgKz0gXCIvXCI7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG52YXIgam9pblBhdGhzID0gKHBhdGhzKSA9PiBwYXRocy5qb2luKFwiL1wiKS5yZXBsYWNlKC9cXC9cXC8rL2csIFwiL1wiKTtcbnZhciBub3JtYWxpemVQYXRobmFtZSA9IChwYXRobmFtZSkgPT4gcGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbnZhciBub3JtYWxpemVTZWFyY2ggPSAoc2VhcmNoKSA9PiAhc2VhcmNoIHx8IHNlYXJjaCA9PT0gXCI/XCIgPyBcIlwiIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG52YXIgbm9ybWFsaXplSGFzaCA9IChoYXNoKSA9PiAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcbnZhciBEYXRhV2l0aFJlc3BvbnNlSW5pdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZGF0YTIsIGluaXQpIHtcbiAgICB0aGlzLnR5cGUgPSBcIkRhdGFXaXRoUmVzcG9uc2VJbml0XCI7XG4gICAgdGhpcy5kYXRhID0gZGF0YTI7XG4gICAgdGhpcy5pbml0ID0gaW5pdCB8fCBudWxsO1xuICB9XG59O1xuZnVuY3Rpb24gZGF0YShkYXRhMiwgaW5pdCkge1xuICByZXR1cm4gbmV3IERhdGFXaXRoUmVzcG9uc2VJbml0KFxuICAgIGRhdGEyLFxuICAgIHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8geyBzdGF0dXM6IGluaXQgfSA6IGluaXRcbiAgKTtcbn1cbnZhciByZWRpcmVjdCA9ICh1cmwsIGluaXQgPSAzMDIpID0+IHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG4gIGlmICh0eXBlb2YgcmVzcG9uc2VJbml0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmVzcG9uc2VJbml0ID0geyBzdGF0dXM6IHJlc3BvbnNlSW5pdCB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZUluaXQuc3RhdHVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmVzcG9uc2VJbml0LnN0YXR1cyA9IDMwMjtcbiAgfVxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgLi4ucmVzcG9uc2VJbml0LCBoZWFkZXJzIH0pO1xufTtcbnZhciByZWRpcmVjdERvY3VtZW50ID0gKHVybCwgaW5pdCkgPT4ge1xuICBsZXQgcmVzcG9uc2UgPSByZWRpcmVjdCh1cmwsIGluaXQpO1xuICByZXNwb25zZS5oZWFkZXJzLnNldChcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbnZhciByZXBsYWNlID0gKHVybCwgaW5pdCkgPT4ge1xuICBsZXQgcmVzcG9uc2UgPSByZWRpcmVjdCh1cmwsIGluaXQpO1xuICByZXNwb25zZS5oZWFkZXJzLnNldChcIlgtUmVtaXgtUmVwbGFjZVwiLCBcInRydWVcIik7XG4gIHJldHVybiByZXNwb25zZTtcbn07XG52YXIgRXJyb3JSZXNwb25zZUltcGwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YTIsIGludGVybmFsID0gZmFsc2UpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5pbnRlcm5hbCA9IGludGVybmFsO1xuICAgIGlmIChkYXRhMiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhMi50b1N0cmluZygpO1xuICAgICAgdGhpcy5lcnJvciA9IGRhdGEyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhMjtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikge1xuICByZXR1cm4gZXJyb3IgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3Iuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBlcnJvci5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5pbnRlcm5hbCA9PT0gXCJib29sZWFuXCIgJiYgXCJkYXRhXCIgaW4gZXJyb3I7XG59XG5cbi8vIGxpYi9yb3V0ZXIvcm91dGVyLnRzXG52YXIgdmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIgPSBbXG4gIFwiUE9TVFwiLFxuICBcIlBVVFwiLFxuICBcIlBBVENIXCIsXG4gIFwiREVMRVRFXCJcbl07XG52YXIgdmFsaWRNdXRhdGlvbk1ldGhvZHMgPSBuZXcgU2V0KFxuICB2YWxpZE11dGF0aW9uTWV0aG9kc0FyclxuKTtcbnZhciB2YWxpZFJlcXVlc3RNZXRob2RzQXJyID0gW1xuICBcIkdFVFwiLFxuICAuLi52YWxpZE11dGF0aW9uTWV0aG9kc0FyclxuXTtcbnZhciB2YWxpZFJlcXVlc3RNZXRob2RzID0gbmV3IFNldCh2YWxpZFJlcXVlc3RNZXRob2RzQXJyKTtcbnZhciByZWRpcmVjdFN0YXR1c0NvZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG52YXIgcmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWzMwNywgMzA4XSk7XG52YXIgSURMRV9OQVZJR0FUSU9OID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGxvY2F0aW9uOiB2b2lkIDAsXG4gIGZvcm1NZXRob2Q6IHZvaWQgMCxcbiAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICBmb3JtRGF0YTogdm9pZCAwLFxuICBqc29uOiB2b2lkIDAsXG4gIHRleHQ6IHZvaWQgMFxufTtcbnZhciBJRExFX0ZFVENIRVIgPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgZGF0YTogdm9pZCAwLFxuICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gIGZvcm1BY3Rpb246IHZvaWQgMCxcbiAgZm9ybUVuY1R5cGU6IHZvaWQgMCxcbiAgZm9ybURhdGE6IHZvaWQgMCxcbiAganNvbjogdm9pZCAwLFxuICB0ZXh0OiB2b2lkIDBcbn07XG52YXIgSURMRV9CTE9DS0VSID0ge1xuICBzdGF0ZTogXCJ1bmJsb2NrZWRcIixcbiAgcHJvY2VlZDogdm9pZCAwLFxuICByZXNldDogdm9pZCAwLFxuICBsb2NhdGlvbjogdm9pZCAwXG59O1xudmFyIEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcbnZhciBkZWZhdWx0TWFwUm91dGVQcm9wZXJ0aWVzID0gKHJvdXRlKSA9PiAoe1xuICBoYXNFcnJvckJvdW5kYXJ5OiBCb29sZWFuKHJvdXRlLmhhc0Vycm9yQm91bmRhcnkpXG59KTtcbnZhciBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSA9IFwicmVtaXgtcm91dGVyLXRyYW5zaXRpb25zXCI7XG52YXIgUmVzZXRMb2FkZXJEYXRhU3ltYm9sID0gU3ltYm9sKFwiUmVzZXRMb2FkZXJEYXRhXCIpO1xuZnVuY3Rpb24gY3JlYXRlUm91dGVyKGluaXQpIHtcbiAgY29uc3Qgcm91dGVyV2luZG93ID0gaW5pdC53aW5kb3cgPyBpbml0LndpbmRvdyA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gIGNvbnN0IGlzQnJvd3NlcjIgPSB0eXBlb2Ygcm91dGVyV2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHJvdXRlcldpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuICBpbnZhcmlhbnQoXG4gICAgaW5pdC5yb3V0ZXMubGVuZ3RoID4gMCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYSBub24tZW1wdHkgcm91dGVzIGFycmF5IHRvIGNyZWF0ZVJvdXRlclwiXG4gICk7XG4gIGxldCBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMyID0gaW5pdC5oeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMgfHwgW107XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXMyID0gaW5pdC5tYXBSb3V0ZVByb3BlcnRpZXMgfHwgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICBpbml0LnJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgIHZvaWQgMCxcbiAgICBtYW5pZmVzdFxuICApO1xuICBsZXQgaW5GbGlnaHREYXRhUm91dGVzO1xuICBsZXQgYmFzZW5hbWUgPSBpbml0LmJhc2VuYW1lIHx8IFwiL1wiO1xuICBsZXQgZGF0YVN0cmF0ZWd5SW1wbCA9IGluaXQuZGF0YVN0cmF0ZWd5IHx8IGRlZmF1bHREYXRhU3RyYXRlZ3lXaXRoTWlkZGxld2FyZTtcbiAgbGV0IGZ1dHVyZSA9IHtcbiAgICB1bnN0YWJsZV9taWRkbGV3YXJlOiBmYWxzZSxcbiAgICAuLi5pbml0LmZ1dHVyZVxuICB9O1xuICBsZXQgdW5saXN0ZW5IaXN0b3J5ID0gbnVsbDtcbiAgbGV0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IHNhdmVkU2Nyb2xsUG9zaXRpb25zMiA9IG51bGw7XG4gIGxldCBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIgPSBudWxsO1xuICBsZXQgZ2V0U2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICBsZXQgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGw7XG4gIGxldCBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGluaXQuaGlzdG9yeS5sb2NhdGlvbiwgYmFzZW5hbWUpO1xuICBsZXQgaW5pdGlhbE1hdGNoZXNJc0ZPVyA9IGZhbHNlO1xuICBsZXQgaW5pdGlhbEVycm9ycyA9IG51bGw7XG4gIGxldCBpbml0aWFsaXplZDtcbiAgaWYgKGluaXRpYWxNYXRjaGVzID09IG51bGwgJiYgIWluaXQucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24pIHtcbiAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgcGF0aG5hbWU6IGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZVxuICAgIH0pO1xuICAgIGxldCB7IG1hdGNoZXMsIHJvdXRlIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgaW5pdGlhbEVycm9ycyA9IHsgW3JvdXRlLmlkXTogZXJyb3IgfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaW5pdGlhbE1hdGNoZXMgJiYgIWluaXQuaHlkcmF0aW9uRGF0YSkge1xuICAgICAgbGV0IGZvZ09mV2FyID0gY2hlY2tGb2dPZldhcihcbiAgICAgICAgaW5pdGlhbE1hdGNoZXMsXG4gICAgICAgIGRhdGFSb3V0ZXMsXG4gICAgICAgIGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZVxuICAgICAgKTtcbiAgICAgIGlmIChmb2dPZldhci5hY3RpdmUpIHtcbiAgICAgICAgaW5pdGlhbE1hdGNoZXMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWluaXRpYWxNYXRjaGVzKSB7XG4gICAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgaW5pdGlhbE1hdGNoZXMgPSBbXTtcbiAgICAgIGxldCBmb2dPZldhciA9IGNoZWNrRm9nT2ZXYXIoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGRhdGFSb3V0ZXMsXG4gICAgICAgIGluaXQuaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZVxuICAgICAgKTtcbiAgICAgIGlmIChmb2dPZldhci5hY3RpdmUgJiYgZm9nT2ZXYXIubWF0Y2hlcykge1xuICAgICAgICBpbml0aWFsTWF0Y2hlc0lzRk9XID0gdHJ1ZTtcbiAgICAgICAgaW5pdGlhbE1hdGNoZXMgPSBmb2dPZldhci5tYXRjaGVzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5pdGlhbE1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5sYXp5KSkge1xuICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpbml0aWFsTWF0Y2hlcy5zb21lKChtKSA9PiBtLnJvdXRlLmxvYWRlcikpIHtcbiAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGxvYWRlckRhdGEgPSBpbml0Lmh5ZHJhdGlvbkRhdGEgPyBpbml0Lmh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YSA6IG51bGw7XG4gICAgICBsZXQgZXJyb3JzID0gaW5pdC5oeWRyYXRpb25EYXRhID8gaW5pdC5oeWRyYXRpb25EYXRhLmVycm9ycyA6IG51bGw7XG4gICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgIGxldCBpZHggPSBpbml0aWFsTWF0Y2hlcy5maW5kSW5kZXgoXG4gICAgICAgICAgKG0pID0+IGVycm9yc1ttLnJvdXRlLmlkXSAhPT0gdm9pZCAwXG4gICAgICAgICk7XG4gICAgICAgIGluaXRpYWxpemVkID0gaW5pdGlhbE1hdGNoZXMuc2xpY2UoMCwgaWR4ICsgMSkuZXZlcnkoXG4gICAgICAgICAgKG0pID0+ICFzaG91bGRMb2FkUm91dGVPbkh5ZHJhdGlvbihtLnJvdXRlLCBsb2FkZXJEYXRhLCBlcnJvcnMpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0aWFsaXplZCA9IGluaXRpYWxNYXRjaGVzLmV2ZXJ5KFxuICAgICAgICAgIChtKSA9PiAhc2hvdWxkTG9hZFJvdXRlT25IeWRyYXRpb24obS5yb3V0ZSwgbG9hZGVyRGF0YSwgZXJyb3JzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgcm91dGVyO1xuICBsZXQgc3RhdGUgPSB7XG4gICAgaGlzdG9yeUFjdGlvbjogaW5pdC5oaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxuICAgIG1hdGNoZXM6IGluaXRpYWxNYXRjaGVzLFxuICAgIGluaXRpYWxpemVkLFxuICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAvLyBEb24ndCByZXN0b3JlIG9uIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBpZiB3ZSB3ZXJlIFNTUidkXG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbCA/IGZhbHNlIDogbnVsbCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgbG9hZGVyRGF0YTogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5sb2FkZXJEYXRhIHx8IHt9LFxuICAgIGFjdGlvbkRhdGE6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSB8fCBudWxsLFxuICAgIGVycm9yczogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMgfHwgaW5pdGlhbEVycm9ycyxcbiAgICBmZXRjaGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBibG9ja2VyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxuICB9O1xuICBsZXQgcGVuZGluZ0FjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICBsZXQgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyO1xuICBsZXQgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICBsZXQgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCByZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIgPSBudWxsO1xuICBsZXQgaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gIGxldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gIGxldCBjYW5jZWxsZWRGZXRjaGVyTG9hZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgZmV0Y2hDb250cm9sbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBpbmNyZW1lbnRpbmdMb2FkSWQgPSAwO1xuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSAtMTtcbiAgbGV0IGZldGNoUmVsb2FkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGZldGNoUmVkaXJlY3RJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgZmV0Y2hMb2FkTWF0Y2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBhY3RpdmVGZXRjaGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgdW5ibG9ja0Jsb2NrZXJIaXN0b3J5VXBkYXRlID0gdm9pZCAwO1xuICBsZXQgcGVuZGluZ1JldmFsaWRhdGlvbkRmZCA9IG51bGw7XG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgdW5saXN0ZW5IaXN0b3J5ID0gaW5pdC5oaXN0b3J5Lmxpc3RlbihcbiAgICAgICh7IGFjdGlvbjogaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIGRlbHRhIH0pID0+IHtcbiAgICAgICAgaWYgKHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSkge1xuICAgICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSgpO1xuICAgICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDAgfHwgZGVsdGEgIT0gbnVsbCxcbiAgICAgICAgICBcIllvdSBhcmUgdHJ5aW5nIHRvIHVzZSBhIGJsb2NrZXIgb24gYSBQT1AgbmF2aWdhdGlvbiB0byBhIGxvY2F0aW9uIHRoYXQgd2FzIG5vdCBjcmVhdGVkIGJ5IEByZW1peC1ydW4vcm91dGVyLiBUaGlzIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBwcm9kdWN0aW9uLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGFyZSBuYXZpZ2F0aW5nIG91dHNpZGUgdGhlIHJvdXRlciB2aWEgYHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZWAvYHdpbmRvdy5sb2NhdGlvbi5oYXNoYCBpbnN0ZWFkIG9mIHVzaW5nIHJvdXRlciBuYXZpZ2F0aW9uIEFQSXMuICBUaGlzIGNhbiBhbHNvIGhhcHBlbiBpZiB5b3UgYXJlIHVzaW5nIGNyZWF0ZUhhc2hSb3V0ZXIgYW5kIHRoZSB1c2VyIG1hbnVhbGx5IGNoYW5nZXMgdGhlIFVSTC5cIlxuICAgICAgICApO1xuICAgICAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChibG9ja2VyS2V5ICYmIGRlbHRhICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgbmV4dEhpc3RvcnlVcGRhdGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHVuYmxvY2tCbG9ja2VySGlzdG9yeVVwZGF0ZSA9IHJlc29sdmU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5pdC5oaXN0b3J5LmdvKGRlbHRhICogLTEpO1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJwcm9jZWVkaW5nXCIsXG4gICAgICAgICAgICAgICAgcHJvY2VlZDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIHJlc2V0OiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbG9jYXRpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5leHRIaXN0b3J5VXBkYXRlUHJvbWlzZS50aGVuKCgpID0+IGluaXQuaGlzdG9yeS5nbyhkZWx0YSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgICAgIHVwZGF0ZVN0YXRlKHsgYmxvY2tlcnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24pO1xuICAgICAgfVxuICAgICk7XG4gICAgaWYgKGlzQnJvd3NlcjIpIHtcbiAgICAgIHJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIGxldCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyA9ICgpID0+IHBlcnNpc3RBcHBsaWVkVHJhbnNpdGlvbnMocm91dGVyV2luZG93LCBhcHBsaWVkVmlld1RyYW5zaXRpb25zKTtcbiAgICAgIHJvdXRlcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMpO1xuICAgICAgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyID0gKCkgPT4gcm91dGVyV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBfc2F2ZUFwcGxpZWRUcmFuc2l0aW9ucyk7XG4gICAgfVxuICAgIGlmICghc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihcIlBPUFwiIC8qIFBvcCAqLywgc3RhdGUubG9jYXRpb24sIHtcbiAgICAgICAgaW5pdGlhbEh5ZHJhdGlvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBpZiAodW5saXN0ZW5IaXN0b3J5KSB7XG4gICAgICB1bmxpc3Rlbkhpc3RvcnkoKTtcbiAgICB9XG4gICAgaWYgKHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgcmVtb3ZlUGFnZUhpZGVFdmVudExpc3RlbmVyKCk7XG4gICAgfVxuICAgIHN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgIHN0YXRlLmZldGNoZXJzLmZvckVhY2goKF8sIGtleSkgPT4gZGVsZXRlRmV0Y2hlcihrZXkpKTtcbiAgICBzdGF0ZS5ibG9ja2Vycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUJsb2NrZXIoa2V5KSk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGZuKSB7XG4gICAgc3Vic2NyaWJlcnMuYWRkKGZuKTtcbiAgICByZXR1cm4gKCkgPT4gc3Vic2NyaWJlcnMuZGVsZXRlKGZuKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgb3B0cyA9IHt9KSB7XG4gICAgc3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLm5ld1N0YXRlXG4gICAgfTtcbiAgICBsZXQgdW5tb3VudGVkRmV0Y2hlcnMgPSBbXTtcbiAgICBsZXQgbW91bnRlZEZldGNoZXJzID0gW107XG4gICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgaWYgKGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgICAgICB1bm1vdW50ZWRGZXRjaGVycy5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW91bnRlZEZldGNoZXJzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoIXN0YXRlLmZldGNoZXJzLmhhcyhrZXkpICYmICFmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIHVubW91bnRlZEZldGNoZXJzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBbLi4uc3Vic2NyaWJlcnNdLmZvckVhY2goXG4gICAgICAoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlcihzdGF0ZSwge1xuICAgICAgICBkZWxldGVkRmV0Y2hlcnM6IHVubW91bnRlZEZldGNoZXJzLFxuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHM6IG9wdHMudmlld1RyYW5zaXRpb25PcHRzLFxuICAgICAgICBmbHVzaFN5bmM6IG9wdHMuZmx1c2hTeW5jID09PSB0cnVlXG4gICAgICB9KVxuICAgICk7XG4gICAgdW5tb3VudGVkRmV0Y2hlcnMuZm9yRWFjaCgoa2V5KSA9PiBkZWxldGVGZXRjaGVyKGtleSkpO1xuICAgIG1vdW50ZWRGZXRjaGVycy5mb3JFYWNoKChrZXkpID0+IHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpKTtcbiAgfVxuICBmdW5jdGlvbiBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIG5ld1N0YXRlLCB7IGZsdXNoU3luYyB9ID0ge30pIHtcbiAgICBsZXQgaXNBY3Rpb25SZWxvYWQgPSBzdGF0ZS5hY3Rpb25EYXRhICE9IG51bGwgJiYgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmIHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiICYmIGxvY2F0aW9uLnN0YXRlPy5faXNSZWRpcmVjdCAhPT0gdHJ1ZTtcbiAgICBsZXQgYWN0aW9uRGF0YTtcbiAgICBpZiAobmV3U3RhdGUuYWN0aW9uRGF0YSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld1N0YXRlLmFjdGlvbkRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYWN0aW9uRGF0YSA9IG5ld1N0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQWN0aW9uUmVsb2FkKSB7XG4gICAgICBhY3Rpb25EYXRhID0gc3RhdGUuYWN0aW9uRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGxldCBsb2FkZXJEYXRhID0gbmV3U3RhdGUubG9hZGVyRGF0YSA/IG1lcmdlTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLmxvYWRlckRhdGEsXG4gICAgICBuZXdTdGF0ZS5sb2FkZXJEYXRhLFxuICAgICAgbmV3U3RhdGUubWF0Y2hlcyB8fCBbXSxcbiAgICAgIG5ld1N0YXRlLmVycm9yc1xuICAgICkgOiBzdGF0ZS5sb2FkZXJEYXRhO1xuICAgIGxldCBibG9ja2VycyA9IHN0YXRlLmJsb2NrZXJzO1xuICAgIGlmIChibG9ja2Vycy5zaXplID4gMCkge1xuICAgICAgYmxvY2tlcnMgPSBuZXcgTWFwKGJsb2NrZXJzKTtcbiAgICAgIGJsb2NrZXJzLmZvckVhY2goKF8sIGspID0+IGJsb2NrZXJzLnNldChrLCBJRExFX0JMT0NLRVIpKTtcbiAgICB9XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUgfHwgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmIGxvY2F0aW9uLnN0YXRlPy5faXNSZWRpcmVjdCAhPT0gdHJ1ZTtcbiAgICBpZiAoaW5GbGlnaHREYXRhUm91dGVzKSB7XG4gICAgICBkYXRhUm91dGVzID0gaW5GbGlnaHREYXRhUm91dGVzO1xuICAgICAgaW5GbGlnaHREYXRhUm91dGVzID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoaXNVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSB7XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBcIlBPUFwiIC8qIFBvcCAqLykge1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gXCJQVVNIXCIgLyogUHVzaCAqLykge1xuICAgICAgaW5pdC5oaXN0b3J5LnB1c2gobG9jYXRpb24sIGxvY2F0aW9uLnN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi8pIHtcbiAgICAgIGluaXQuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgfVxuICAgIGxldCB2aWV3VHJhbnNpdGlvbk9wdHM7XG4gICAgaWYgKHBlbmRpbmdBY3Rpb24gPT09IFwiUE9QXCIgLyogUG9wICovKSB7XG4gICAgICBsZXQgcHJpb3JQYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmIChwcmlvclBhdGhzICYmIHByaW9yUGF0aHMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuaGFzKGxvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPSB7XG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkKSB7XG4gICAgICBsZXQgdG9QYXRocyA9IGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuZ2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIGlmICh0b1BhdGhzKSB7XG4gICAgICAgIHRvUGF0aHMuYWRkKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvUGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbbG9jYXRpb24ucGF0aG5hbWVdKTtcbiAgICAgICAgYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5zZXQoc3RhdGUubG9jYXRpb24ucGF0aG5hbWUsIHRvUGF0aHMpO1xuICAgICAgfVxuICAgICAgdmlld1RyYW5zaXRpb25PcHRzID0ge1xuICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICBuZXh0TG9jYXRpb246IGxvY2F0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShcbiAgICAgIHtcbiAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgIC8vIG1hdGNoZXMsIGVycm9ycywgZmV0Y2hlcnMgZ28gdGhyb3VnaCBhcy1pc1xuICAgICAgICBhY3Rpb25EYXRhLFxuICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICBoaXN0b3J5QWN0aW9uOiBwZW5kaW5nQWN0aW9uLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcbiAgICAgICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIG5ld1N0YXRlLm1hdGNoZXMgfHwgc3RhdGUubWF0Y2hlc1xuICAgICAgICApLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGJsb2NrZXJzXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMsXG4gICAgICAgIGZsdXNoU3luYzogZmx1c2hTeW5jID09PSB0cnVlXG4gICAgICB9XG4gICAgKTtcbiAgICBwZW5kaW5nQWN0aW9uID0gXCJQT1BcIiAvKiBQb3AgKi87XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuICAgIHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgcGVuZGluZ1JldmFsaWRhdGlvbkRmZD8ucmVzb2x2ZSgpO1xuICAgIHBlbmRpbmdSZXZhbGlkYXRpb25EZmQgPSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRlKHRvLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaW5pdC5oaXN0b3J5LmdvKHRvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplVG8oXG4gICAgICBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIHN0YXRlLm1hdGNoZXMsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIHRvLFxuICAgICAgb3B0cz8uZnJvbVJvdXRlSWQsXG4gICAgICBvcHRzPy5yZWxhdGl2ZVxuICAgICk7XG4gICAgbGV0IHsgcGF0aCwgc3VibWlzc2lvbiwgZXJyb3IgfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhcbiAgICAgIGZhbHNlLFxuICAgICAgbm9ybWFsaXplZFBhdGgsXG4gICAgICBvcHRzXG4gICAgKTtcbiAgICBsZXQgY3VycmVudExvY2F0aW9uID0gc3RhdGUubG9jYXRpb247XG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHN0YXRlLmxvY2F0aW9uLCBwYXRoLCBvcHRzICYmIG9wdHMuc3RhdGUpO1xuICAgIG5leHRMb2NhdGlvbiA9IHtcbiAgICAgIC4uLm5leHRMb2NhdGlvbixcbiAgICAgIC4uLmluaXQuaGlzdG9yeS5lbmNvZGVMb2NhdGlvbihuZXh0TG9jYXRpb24pXG4gICAgfTtcbiAgICBsZXQgdXNlclJlcGxhY2UgPSBvcHRzICYmIG9wdHMucmVwbGFjZSAhPSBudWxsID8gb3B0cy5yZXBsYWNlIDogdm9pZCAwO1xuICAgIGxldCBoaXN0b3J5QWN0aW9uID0gXCJQVVNIXCIgLyogUHVzaCAqLztcbiAgICBpZiAodXNlclJlcGxhY2UgPT09IHRydWUpIHtcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovO1xuICAgIH0gZWxzZSBpZiAodXNlclJlcGxhY2UgPT09IGZhbHNlKSB7XG4gICAgfSBlbHNlIGlmIChzdWJtaXNzaW9uICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpICYmIHN1Ym1pc3Npb24uZm9ybUFjdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBcIlJFUExBQ0VcIiAvKiBSZXBsYWNlICovO1xuICAgIH1cbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID0gb3B0cyAmJiBcInByZXZlbnRTY3JvbGxSZXNldFwiIGluIG9wdHMgPyBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSA6IHZvaWQgMDtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9KTtcbiAgICBpZiAoYmxvY2tlcktleSkge1xuICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgIHN0YXRlOiBcImJsb2NrZWRcIixcbiAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgcHJvY2VlZCgpIHtcbiAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgIHN0YXRlOiBcInByb2NlZWRpbmdcIixcbiAgICAgICAgICAgIHByb2NlZWQ6IHZvaWQgMCxcbiAgICAgICAgICAgIHJlc2V0OiB2b2lkIDAsXG4gICAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbmF2aWdhdGUodG8sIG9wdHMpO1xuICAgICAgICB9LFxuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICAgICAgICBibG9ja2Vycy5zZXQoYmxvY2tlcktleSwgSURMRV9CTE9DS0VSKTtcbiAgICAgICAgICB1cGRhdGVTdGF0ZSh7IGJsb2NrZXJzIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgc3RhcnROYXZpZ2F0aW9uKGhpc3RvcnlBY3Rpb24sIG5leHRMb2NhdGlvbiwge1xuICAgICAgc3VibWlzc2lvbixcbiAgICAgIC8vIFNlbmQgdGhyb3VnaCB0aGUgZm9ybURhdGEgc2VyaWFsaXphdGlvbiBlcnJvciBpZiB3ZSBoYXZlIG9uZSBzbyB3ZSBjYW5cbiAgICAgIC8vIHJlbmRlciBhdCB0aGUgcmlnaHQgZXJyb3IgYm91bmRhcnkgYWZ0ZXIgd2UgbWF0Y2ggcm91dGVzXG4gICAgICBwZW5kaW5nRXJyb3I6IGVycm9yLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgcmVwbGFjZTogb3B0cyAmJiBvcHRzLnJlcGxhY2UsXG4gICAgICBlbmFibGVWaWV3VHJhbnNpdGlvbjogb3B0cyAmJiBvcHRzLnZpZXdUcmFuc2l0aW9uLFxuICAgICAgZmx1c2hTeW5jXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmV2YWxpZGF0ZSgpIHtcbiAgICBpZiAoIXBlbmRpbmdSZXZhbGlkYXRpb25EZmQpIHtcbiAgICAgIHBlbmRpbmdSZXZhbGlkYXRpb25EZmQgPSBjcmVhdGVEZWZlcnJlZCgpO1xuICAgIH1cbiAgICBpbnRlcnJ1cHRBY3RpdmVMb2FkcygpO1xuICAgIHVwZGF0ZVN0YXRlKHsgcmV2YWxpZGF0aW9uOiBcImxvYWRpbmdcIiB9KTtcbiAgICBsZXQgcHJvbWlzZSA9IHBlbmRpbmdSZXZhbGlkYXRpb25EZmQucHJvbWlzZTtcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJzdWJtaXR0aW5nXCIpIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5sb2NhdGlvbiwge1xuICAgICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHN0YXJ0TmF2aWdhdGlvbihcbiAgICAgIHBlbmRpbmdBY3Rpb24gfHwgc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sXG4gICAgICB7XG4gICAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbjogc3RhdGUubmF2aWdhdGlvbixcbiAgICAgICAgLy8gUHJveHkgdGhyb3VnaCBhbnkgcmVuZGluZyB2aWV3IHRyYW5zaXRpb25cbiAgICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb246IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPT09IHRydWVcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0TmF2aWdhdGlvbihoaXN0b3J5QWN0aW9uLCBsb2NhdGlvbiwgb3B0cykge1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBoaXN0b3J5QWN0aW9uO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IChvcHRzICYmIG9wdHMuc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSA9PT0gdHJ1ZTtcbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMpO1xuICAgIHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPSAob3B0cyAmJiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCkgPT09IHRydWU7XG4gICAgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IChvcHRzICYmIG9wdHMuZW5hYmxlVmlld1RyYW5zaXRpb24pID09PSB0cnVlO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9IG9wdHMgJiYgb3B0cy5vdmVycmlkZU5hdmlnYXRpb247XG4gICAgbGV0IG1hdGNoZXMgPSBvcHRzPy5pbml0aWFsSHlkcmF0aW9uICYmIHN0YXRlLm1hdGNoZXMgJiYgc3RhdGUubWF0Y2hlcy5sZW5ndGggPiAwICYmICFpbml0aWFsTWF0Y2hlc0lzRk9XID8gKFxuICAgICAgLy8gYG1hdGNoUm91dGVzKClgIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkIGlmIHdlJ3JlIGluIGhlcmUgdmlhIGByb3V0ZXIuaW5pdGlhbGl6ZSgpYFxuICAgICAgc3RhdGUubWF0Y2hlc1xuICAgICkgOiBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgbG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGlmIChtYXRjaGVzICYmIHN0YXRlLmluaXRpYWxpemVkICYmICFpc1JldmFsaWRhdGlvblJlcXVpcmVkICYmIGlzSGFzaENoYW5nZU9ubHkoc3RhdGUubG9jYXRpb24sIGxvY2F0aW9uKSAmJiAhKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7IG1hdGNoZXMgfSwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmb2dPZldhciA9IGNoZWNrRm9nT2ZXYXIobWF0Y2hlcywgcm91dGVzVG9Vc2UsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICBpZiAoZm9nT2ZXYXIuYWN0aXZlICYmIGZvZ09mV2FyLm1hdGNoZXMpIHtcbiAgICAgIG1hdGNoZXMgPSBmb2dPZldhci5tYXRjaGVzO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCB7IGVycm9yLCBub3RGb3VuZE1hdGNoZXMsIHJvdXRlIH0gPSBoYW5kbGVOYXZpZ2F0aW9uYWw0MDQoXG4gICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICApO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7IGZsdXNoU3luYyB9XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLnNpZ25hbCxcbiAgICAgIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uXG4gICAgKTtcbiAgICBsZXQgc2NvcGVkQ29udGV4dCA9IG5ldyB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXIoXG4gICAgICBpbml0LnVuc3RhYmxlX2dldENvbnRleHQgPyBhd2FpdCBpbml0LnVuc3RhYmxlX2dldENvbnRleHQoKSA6IHZvaWQgMFxuICAgICk7XG4gICAgbGV0IHBlbmRpbmdBY3Rpb25SZXN1bHQ7XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5wZW5kaW5nRXJyb3IpIHtcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQgPSBbXG4gICAgICAgIGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcykucm91dGUuaWQsXG4gICAgICAgIHsgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLCBlcnJvcjogb3B0cy5wZW5kaW5nRXJyb3IgfVxuICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBsZXQgYWN0aW9uUmVzdWx0ID0gYXdhaXQgaGFuZGxlQWN0aW9uKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgb3B0cy5zdWJtaXNzaW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgICBmb2dPZldhci5hY3RpdmUsXG4gICAgICAgIG9wdHMgJiYgb3B0cy5pbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLFxuICAgICAgICB7IHJlcGxhY2U6IG9wdHMucmVwbGFjZSwgZmx1c2hTeW5jIH1cbiAgICAgICk7XG4gICAgICBpZiAoYWN0aW9uUmVzdWx0LnNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICAgICAgICBsZXQgW3JvdXRlSWQsIHJlc3VsdF0gPSBhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdDtcbiAgICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSAmJiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpICYmIHJlc3VsdC5lcnJvci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgICAgICBtYXRjaGVzOiBhY3Rpb25SZXN1bHQubWF0Y2hlcyxcbiAgICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICAgIFtyb3V0ZUlkXTogcmVzdWx0LmVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXRjaGVzID0gYWN0aW9uUmVzdWx0Lm1hdGNoZXMgfHwgbWF0Y2hlcztcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQgPSBhY3Rpb25SZXN1bHQucGVuZGluZ0FjdGlvblJlc3VsdDtcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24obG9jYXRpb24sIG9wdHMuc3VibWlzc2lvbik7XG4gICAgICBmbHVzaFN5bmMgPSBmYWxzZTtcbiAgICAgIGZvZ09mV2FyLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgcmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KFxuICAgICAgICBpbml0Lmhpc3RvcnksXG4gICAgICAgIHJlcXVlc3QudXJsLFxuICAgICAgICByZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHNob3J0Q2lyY3VpdGVkLFxuICAgICAgbWF0Y2hlczogdXBkYXRlZE1hdGNoZXMsXG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzXG4gICAgfSA9IGF3YWl0IGhhbmRsZUxvYWRlcnMoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgIGxvYWRpbmdOYXZpZ2F0aW9uLFxuICAgICAgb3B0cyAmJiBvcHRzLnN1Ym1pc3Npb24sXG4gICAgICBvcHRzICYmIG9wdHMuZmV0Y2hlclN1Ym1pc3Npb24sXG4gICAgICBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIG9wdHMgJiYgb3B0cy5pbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLFxuICAgICAgZmx1c2hTeW5jLFxuICAgICAgcGVuZGluZ0FjdGlvblJlc3VsdFxuICAgICk7XG4gICAgaWYgKHNob3J0Q2lyY3VpdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICBtYXRjaGVzOiB1cGRhdGVkTWF0Y2hlcyB8fCBtYXRjaGVzLFxuICAgICAgLi4uZ2V0QWN0aW9uRGF0YUZvckNvbW1pdChwZW5kaW5nQWN0aW9uUmVzdWx0KSxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb24ocmVxdWVzdCwgbG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMsIHNjb3BlZENvbnRleHQsIGlzRm9nT2ZXYXIsIGluaXRpYWxIeWRyYXRpb24sIG9wdHMgPSB7fSkge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgbGV0IG5hdmlnYXRpb24gPSBnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgdXBkYXRlU3RhdGUoeyBuYXZpZ2F0aW9uIH0sIHsgZmx1c2hTeW5jOiBvcHRzLmZsdXNoU3luYyA9PT0gdHJ1ZSB9KTtcbiAgICBpZiAoaXNGb2dPZldhcikge1xuICAgICAgbGV0IGRpc2NvdmVyUmVzdWx0ID0gYXdhaXQgZGlzY292ZXJSb3V0ZXMoXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICByZXF1ZXN0LnNpZ25hbFxuICAgICAgKTtcbiAgICAgIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICByZXR1cm4geyBzaG9ydENpcmN1aXRlZDogdHJ1ZSB9O1xuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KGRpc2NvdmVyUmVzdWx0LnBhcnRpYWxNYXRjaGVzKS5yb3V0ZS5pZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXRjaGVzOiBkaXNjb3ZlclJlc3VsdC5wYXJ0aWFsTWF0Y2hlcyxcbiAgICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbXG4gICAgICAgICAgICBib3VuZGFyeUlkLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgICAgICAgIGVycm9yOiBkaXNjb3ZlclJlc3VsdC5lcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoIWRpc2NvdmVyUmVzdWx0Lm1hdGNoZXMpIHtcbiAgICAgICAgbGV0IHsgbm90Rm91bmRNYXRjaGVzLCBlcnJvciwgcm91dGUgfSA9IGhhbmRsZU5hdmlnYXRpb25hbDQwNChcbiAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0OiBbXG4gICAgICAgICAgICByb3V0ZS5pZCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBhY3Rpb25NYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKTtcbiAgICBpZiAoIWFjdGlvbk1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhYWN0aW9uTWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZHNNYXRjaGVzID0gZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzKFxuICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgYWN0aW9uTWF0Y2gsXG4gICAgICAgIGluaXRpYWxIeWRyYXRpb24gPyBbXSA6IGh5ZHJhdGlvblJvdXRlUHJvcGVydGllczIsXG4gICAgICAgIHNjb3BlZENvbnRleHRcbiAgICAgICk7XG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGRzTWF0Y2hlcyxcbiAgICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdHNbYWN0aW9uTWF0Y2gucm91dGUuaWRdO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgIGlmIChyZXN1bHRzW21hdGNoLnJvdXRlLmlkXSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCByZXBsYWNlMjtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMucmVwbGFjZSAhPSBudWxsKSB7XG4gICAgICAgIHJlcGxhY2UyID0gb3B0cy5yZXBsYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGxvY2F0aW9uMiA9IG5vcm1hbGl6ZVJlZGlyZWN0TG9jYXRpb24oXG4gICAgICAgICAgcmVzdWx0LnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIiksXG4gICAgICAgICAgbmV3IFVSTChyZXF1ZXN0LnVybCksXG4gICAgICAgICAgYmFzZW5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgcmVwbGFjZTIgPSBsb2NhdGlvbjIgPT09IHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lICsgc3RhdGUubG9jYXRpb24uc2VhcmNoO1xuICAgICAgfVxuICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmVxdWVzdCwgcmVzdWx0LCB0cnVlLCB7XG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2UyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBpZiAoKG9wdHMgJiYgb3B0cy5yZXBsYWNlKSAhPT0gdHJ1ZSkge1xuICAgICAgICBwZW5kaW5nQWN0aW9uID0gXCJQVVNIXCIgLyogUHVzaCAqLztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFtcbiAgICAgICAgICBib3VuZGFyeU1hdGNoLnJvdXRlLmlkLFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICBhY3Rpb25NYXRjaC5yb3V0ZS5pZFxuICAgICAgICBdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2hlcyxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQ6IFthY3Rpb25NYXRjaC5yb3V0ZS5pZCwgcmVzdWx0XVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVycyhyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgc2NvcGVkQ29udGV4dCwgaXNGb2dPZldhciwgb3ZlcnJpZGVOYXZpZ2F0aW9uLCBzdWJtaXNzaW9uLCBmZXRjaGVyU3VibWlzc2lvbiwgcmVwbGFjZTIsIGluaXRpYWxIeWRyYXRpb24sIGZsdXNoU3luYywgcGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICAgIGxldCBsb2FkaW5nTmF2aWdhdGlvbiA9IG92ZXJyaWRlTmF2aWdhdGlvbiB8fCBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbik7XG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uIHx8IGZldGNoZXJTdWJtaXNzaW9uIHx8IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihsb2FkaW5nTmF2aWdhdGlvbik7XG4gICAgbGV0IHNob3VsZFVwZGF0ZU5hdmlnYXRpb25TdGF0ZSA9ICFpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gJiYgIWluaXRpYWxIeWRyYXRpb247XG4gICAgaWYgKGlzRm9nT2ZXYXIpIHtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVOYXZpZ2F0aW9uU3RhdGUpIHtcbiAgICAgICAgbGV0IGFjdGlvbkRhdGEgPSBnZXRVcGRhdGVkQWN0aW9uRGF0YShwZW5kaW5nQWN0aW9uUmVzdWx0KTtcbiAgICAgICAgdXBkYXRlU3RhdGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmF2aWdhdGlvbjogbG9hZGluZ05hdmlnYXRpb24sXG4gICAgICAgICAgICAuLi5hY3Rpb25EYXRhICE9PSB2b2lkIDAgPyB7IGFjdGlvbkRhdGEgfSA6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmbHVzaFN5bmNcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBsZXQgZGlzY292ZXJSZXN1bHQgPSBhd2FpdCBkaXNjb3ZlclJvdXRlcyhcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsXG4gICAgICApO1xuICAgICAgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgICB9IGVsc2UgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkoZGlzY292ZXJSZXN1bHQucGFydGlhbE1hdGNoZXMpLnJvdXRlLmlkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1hdGNoZXM6IGRpc2NvdmVyUmVzdWx0LnBhcnRpYWxNYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgW2JvdW5kYXJ5SWRdOiBkaXNjb3ZlclJlc3VsdC5lcnJvclxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoIWRpc2NvdmVyUmVzdWx0Lm1hdGNoZXMpIHtcbiAgICAgICAgbGV0IHsgZXJyb3IsIG5vdEZvdW5kTWF0Y2hlcywgcm91dGUgfSA9IGhhbmRsZU5hdmlnYXRpb25hbDQwNChcbiAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICAgIFtyb3V0ZS5pZF06IGVycm9yXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIGxldCB7IGRzTWF0Y2hlcywgcmV2YWxpZGF0aW5nRmV0Y2hlcnMgfSA9IGdldE1hdGNoZXNUb0xvYWQoXG4gICAgICByZXF1ZXN0LFxuICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGFjdGl2ZVN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGluaXRpYWxIeWRyYXRpb24gPyBbXSA6IGh5ZHJhdGlvblJvdXRlUHJvcGVydGllczIsXG4gICAgICBpbml0aWFsSHlkcmF0aW9uID09PSB0cnVlLFxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyxcbiAgICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24sXG4gICAgICBmZXRjaExvYWRNYXRjaGVzLFxuICAgICAgZmV0Y2hSZWRpcmVjdElkcyxcbiAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBpbml0LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uICE9IG51bGwsXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0XG4gICAgKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGlmICghaW5pdC5kYXRhU3RyYXRlZ3kgJiYgIWRzTWF0Y2hlcy5zb21lKChtKSA9PiBtLnNob3VsZExvYWQpICYmIHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbGV0IHVwZGF0ZWRGZXRjaGVyczIgPSBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICAvLyBDb21taXQgcGVuZGluZyBlcnJvciBpZiB3ZSdyZSBzaG9ydCBjaXJjdWl0aW5nXG4gICAgICAgICAgZXJyb3JzOiBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyB7IFtwZW5kaW5nQWN0aW9uUmVzdWx0WzBdXTogcGVuZGluZ0FjdGlvblJlc3VsdFsxXS5lcnJvciB9IDogbnVsbCxcbiAgICAgICAgICAuLi5nZXRBY3Rpb25EYXRhRm9yQ29tbWl0KHBlbmRpbmdBY3Rpb25SZXN1bHQpLFxuICAgICAgICAgIC4uLnVwZGF0ZWRGZXRjaGVyczIgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9IDoge31cbiAgICAgICAgfSxcbiAgICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuICAgIGlmIChzaG91bGRVcGRhdGVOYXZpZ2F0aW9uU3RhdGUpIHtcbiAgICAgIGxldCB1cGRhdGVzID0ge307XG4gICAgICBpZiAoIWlzRm9nT2ZXYXIpIHtcbiAgICAgICAgdXBkYXRlcy5uYXZpZ2F0aW9uID0gbG9hZGluZ05hdmlnYXRpb247XG4gICAgICAgIGxldCBhY3Rpb25EYXRhID0gZ2V0VXBkYXRlZEFjdGlvbkRhdGEocGVuZGluZ0FjdGlvblJlc3VsdCk7XG4gICAgICAgIGlmIChhY3Rpb25EYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB1cGRhdGVzLmFjdGlvbkRhdGEgPSBhY3Rpb25EYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB1cGRhdGVzLmZldGNoZXJzID0gZ2V0VXBkYXRlZFJldmFsaWRhdGluZ0ZldGNoZXJzKHJldmFsaWRhdGluZ0ZldGNoZXJzKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZVN0YXRlKHVwZGF0ZXMsIHsgZmx1c2hTeW5jIH0pO1xuICAgIH1cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgYWJvcnRGZXRjaGVyKHJmLmtleSk7XG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChyZi5rZXksIHJmLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PiByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKChmKSA9PiBhYm9ydEZldGNoZXIoZi5rZXkpKTtcbiAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSB7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgeyBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9ID0gYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKFxuICAgICAgZHNNYXRjaGVzLFxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICByZXF1ZXN0LFxuICAgICAgc2NvcGVkQ29udGV4dFxuICAgICk7XG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiB7IHNob3J0Q2lyY3VpdGVkOiB0cnVlIH07XG4gICAgfVxuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJhYm9ydFwiLFxuICAgICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShyZi5rZXkpKTtcbiAgICBsZXQgcmVkaXJlY3QyID0gZmluZFJlZGlyZWN0KGxvYWRlclJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdDIpIHtcbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlZGlyZWN0Mi5yZXN1bHQsIHRydWUsIHtcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZTJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG4gICAgcmVkaXJlY3QyID0gZmluZFJlZGlyZWN0KGZldGNoZXJSZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QyKSB7XG4gICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChyZWRpcmVjdDIua2V5KTtcbiAgICAgIGF3YWl0IHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHJlcXVlc3QsIHJlZGlyZWN0Mi5yZXN1bHQsIHRydWUsIHtcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZTJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgc2hvcnRDaXJjdWl0ZWQ6IHRydWUgfTtcbiAgICB9XG4gICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBwZW5kaW5nQWN0aW9uUmVzdWx0LFxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgICk7XG4gICAgaWYgKGluaXRpYWxIeWRyYXRpb24gJiYgc3RhdGUuZXJyb3JzKSB7XG4gICAgICBlcnJvcnMgPSB7IC4uLnN0YXRlLmVycm9ycywgLi4uZXJyb3JzIH07XG4gICAgfVxuICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk7XG4gICAgbGV0IGRpZEFib3J0RmV0Y2hMb2FkcyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKTtcbiAgICBsZXQgc2hvdWxkVXBkYXRlRmV0Y2hlcnMgPSB1cGRhdGVkRmV0Y2hlcnMgfHwgZGlkQWJvcnRGZXRjaExvYWRzIHx8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoZXMsXG4gICAgICBsb2FkZXJEYXRhLFxuICAgICAgZXJyb3JzLFxuICAgICAgLi4uc2hvdWxkVXBkYXRlRmV0Y2hlcnMgPyB7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9IDoge31cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFVwZGF0ZWRBY3Rpb25EYXRhKHBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICBpZiAocGVuZGluZ0FjdGlvblJlc3VsdCAmJiAhaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmRhdGFcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5hY3Rpb25EYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoc3RhdGUuYWN0aW9uRGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFVwZGF0ZWRSZXZhbGlkYXRpbmdGZXRjaGVycyhyZXZhbGlkYXRpbmdGZXRjaGVycykge1xuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiB7XG4gICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChyZi5rZXkpO1xuICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBmZXRjaGVyID8gZmV0Y2hlci5kYXRhIDogdm9pZCAwXG4gICAgICApO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHJmLmtleSwgcmV2YWxpZGF0aW5nRmV0Y2hlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZldGNoMihrZXksIHJvdXRlSWQsIGhyZWYyLCBvcHRzKSB7XG4gICAgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVUbyhcbiAgICAgIHN0YXRlLmxvY2F0aW9uLFxuICAgICAgc3RhdGUubWF0Y2hlcyxcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgaHJlZjIsXG4gICAgICByb3V0ZUlkLFxuICAgICAgb3B0cz8ucmVsYXRpdmVcbiAgICApO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIG5vcm1hbGl6ZWRQYXRoLCBiYXNlbmFtZSk7XG4gICAgbGV0IGZvZ09mV2FyID0gY2hlY2tGb2dPZldhcihtYXRjaGVzLCByb3V0ZXNUb1VzZSwgbm9ybWFsaXplZFBhdGgpO1xuICAgIGlmIChmb2dPZldhci5hY3RpdmUgJiYgZm9nT2ZXYXIubWF0Y2hlcykge1xuICAgICAgbWF0Y2hlcyA9IGZvZ09mV2FyLm1hdGNoZXM7XG4gICAgfVxuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKFxuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICAgIGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBub3JtYWxpemVkUGF0aCB9KSxcbiAgICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHsgcGF0aCwgc3VibWlzc2lvbiwgZXJyb3IgfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhcbiAgICAgIHRydWUsXG4gICAgICBub3JtYWxpemVkUGF0aCxcbiAgICAgIG9wdHNcbiAgICApO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZXJyb3IsIHsgZmx1c2hTeW5jIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbWF0Y2ggPSBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBwYXRoKTtcbiAgICBsZXQgc2NvcGVkQ29udGV4dCA9IG5ldyB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXIoXG4gICAgICBpbml0LnVuc3RhYmxlX2dldENvbnRleHQgPyBhd2FpdCBpbml0LnVuc3RhYmxlX2dldENvbnRleHQoKSA6IHZvaWQgMFxuICAgICk7XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcbiAgICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIGF3YWl0IGhhbmRsZUZldGNoZXJBY3Rpb24oXG4gICAgICAgIGtleSxcbiAgICAgICAgcm91dGVJZCxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICAgIGZvZ09mV2FyLmFjdGl2ZSxcbiAgICAgICAgZmx1c2hTeW5jLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZldGNoTG9hZE1hdGNoZXMuc2V0KGtleSwgeyByb3V0ZUlkLCBwYXRoIH0pO1xuICAgIGF3YWl0IGhhbmRsZUZldGNoZXJMb2FkZXIoXG4gICAgICBrZXksXG4gICAgICByb3V0ZUlkLFxuICAgICAgcGF0aCxcbiAgICAgIG1hdGNoLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICBmb2dPZldhci5hY3RpdmUsXG4gICAgICBmbHVzaFN5bmMsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICBzdWJtaXNzaW9uXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaGVyQWN0aW9uKGtleSwgcm91dGVJZCwgcGF0aCwgbWF0Y2gsIHJlcXVlc3RNYXRjaGVzLCBzY29wZWRDb250ZXh0LCBpc0ZvZ09mV2FyLCBmbHVzaFN5bmMsIHByZXZlbnRTY3JvbGxSZXNldCwgc3VibWlzc2lvbikge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcbiAgICBmdW5jdGlvbiBkZXRlY3RBbmRIYW5kbGU0MDVFcnJvcihtKSB7XG4gICAgICBpZiAoIW0ucm91dGUuYWN0aW9uICYmICFtLnJvdXRlLmxhenkpIHtcbiAgICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgICBtZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgICAgICBwYXRobmFtZTogcGF0aCxcbiAgICAgICAgICByb3V0ZUlkXG4gICAgICAgIH0pO1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBlcnJvciwgeyBmbHVzaFN5bmMgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzRm9nT2ZXYXIgJiYgZGV0ZWN0QW5kSGFuZGxlNDA1RXJyb3IobWF0Y2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBleGlzdGluZ0ZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXRTdWJtaXR0aW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBleGlzdGluZ0ZldGNoZXIpLCB7XG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChcbiAgICAgIGluaXQuaGlzdG9yeSxcbiAgICAgIHBhdGgsXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgc3VibWlzc2lvblxuICAgICk7XG4gICAgaWYgKGlzRm9nT2ZXYXIpIHtcbiAgICAgIGxldCBkaXNjb3ZlclJlc3VsdCA9IGF3YWl0IGRpc2NvdmVyUm91dGVzKFxuICAgICAgICByZXF1ZXN0TWF0Y2hlcyxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgZmV0Y2hSZXF1ZXN0LnNpZ25hbCxcbiAgICAgICAga2V5XG4gICAgICApO1xuICAgICAgaWYgKGRpc2NvdmVyUmVzdWx0LnR5cGUgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGRpc2NvdmVyUmVzdWx0LmVycm9yLCB7IGZsdXNoU3luYyB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICghZGlzY292ZXJSZXN1bHQubWF0Y2hlcykge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3IoXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHJvdXRlSWQsXG4gICAgICAgICAgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWU6IHBhdGggfSksXG4gICAgICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0TWF0Y2hlcyA9IGRpc2NvdmVyUmVzdWx0Lm1hdGNoZXM7XG4gICAgICAgIG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gocmVxdWVzdE1hdGNoZXMsIHBhdGgpO1xuICAgICAgICBpZiAoZGV0ZWN0QW5kSGFuZGxlNDA1RXJyb3IobWF0Y2gpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IGZldGNoTWF0Y2hlcyA9IGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhcbiAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgIHJlcXVlc3RNYXRjaGVzLFxuICAgICAgbWF0Y2gsXG4gICAgICBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgc2NvcGVkQ29udGV4dFxuICAgICk7XG4gICAgbGV0IGFjdGlvblJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgZmV0Y2hNYXRjaGVzLFxuICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgIGtleVxuICAgICk7XG4gICAgbGV0IGFjdGlvblJlc3VsdCA9IGFjdGlvblJlc3VsdHNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGlmIChmZXRjaFJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkgfHwgaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHZvaWQgMCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KGFjdGlvblJlc3VsdCkpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID4gb3JpZ2luYXRpbmdMb2FkSWQpIHtcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih2b2lkIDApKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcbiAgICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uKSk7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKGZldGNoUmVxdWVzdCwgYWN0aW9uUmVzdWx0LCBmYWxzZSwge1xuICAgICAgICAgICAgZmV0Y2hlclN1Ym1pc3Npb246IHN1Ym1pc3Npb24sXG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBhY3Rpb25SZXN1bHQuZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBuZXh0TG9jYXRpb24gPSBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uO1xuICAgIGxldCByZXZhbGlkYXRpb25SZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgKTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbWF0Y2hlcyA9IHN0YXRlLm5hdmlnYXRpb24uc3RhdGUgIT09IFwiaWRsZVwiID8gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIGJhc2VuYW1lKSA6IHN0YXRlLm1hdGNoZXM7XG4gICAgaW52YXJpYW50KG1hdGNoZXMsIFwiRGlkbid0IGZpbmQgYW55IG1hdGNoZXMgYWZ0ZXIgZmV0Y2hlciBhY3Rpb25cIik7XG4gICAgbGV0IGxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGZldGNoUmVsb2FkSWRzLnNldChrZXksIGxvYWRJZCk7XG4gICAgbGV0IGxvYWRGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgYWN0aW9uUmVzdWx0LmRhdGEpO1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGxvYWRGZXRjaGVyKTtcbiAgICBsZXQgeyBkc01hdGNoZXMsIHJldmFsaWRhdGluZ0ZldGNoZXJzIH0gPSBnZXRNYXRjaGVzVG9Mb2FkKFxuICAgICAgcmV2YWxpZGF0aW9uUmVxdWVzdCxcbiAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBzdGF0ZSxcbiAgICAgIG1hdGNoZXMsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIGZhbHNlLFxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCxcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2FkcyxcbiAgICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24sXG4gICAgICBmZXRjaExvYWRNYXRjaGVzLFxuICAgICAgZmV0Y2hSZWRpcmVjdElkcyxcbiAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICBpbml0LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uICE9IG51bGwsXG4gICAgICBbbWF0Y2gucm91dGUuaWQsIGFjdGlvblJlc3VsdF1cbiAgICApO1xuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZpbHRlcigocmYpID0+IHJmLmtleSAhPT0ga2V5KS5mb3JFYWNoKChyZikgPT4ge1xuICAgICAgbGV0IHN0YWxlS2V5ID0gcmYua2V5O1xuICAgICAgbGV0IGV4aXN0aW5nRmV0Y2hlcjIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoc3RhbGVLZXkpO1xuICAgICAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXIgPSBnZXRMb2FkaW5nRmV0Y2hlcihcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBleGlzdGluZ0ZldGNoZXIyID8gZXhpc3RpbmdGZXRjaGVyMi5kYXRhIDogdm9pZCAwXG4gICAgICApO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KHN0YWxlS2V5LCByZXZhbGlkYXRpbmdGZXRjaGVyKTtcbiAgICAgIGFib3J0RmV0Y2hlcihzdGFsZUtleSk7XG4gICAgICBpZiAocmYuY29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChzdGFsZUtleSwgcmYuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXBkYXRlU3RhdGUoeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSk7XG4gICAgbGV0IGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyA9ICgpID0+IHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2goKHJmKSA9PiBhYm9ydEZldGNoZXIocmYua2V5KSk7XG4gICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJhYm9ydFwiLFxuICAgICAgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zXG4gICAgKTtcbiAgICBsZXQgeyBsb2FkZXJSZXN1bHRzLCBmZXRjaGVyUmVzdWx0cyB9ID0gYXdhaXQgY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKFxuICAgICAgZHNNYXRjaGVzLFxuICAgICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsXG4gICAgICByZXZhbGlkYXRpb25SZXF1ZXN0LFxuICAgICAgc2NvcGVkQ29udGV4dFxuICAgICk7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBcImFib3J0XCIsXG4gICAgICBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnNcbiAgICApO1xuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaCgocikgPT4gZmV0Y2hDb250cm9sbGVycy5kZWxldGUoci5rZXkpKTtcbiAgICBpZiAoc3RhdGUuZmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gICAgbGV0IHJlZGlyZWN0MiA9IGZpbmRSZWRpcmVjdChsb2FkZXJSZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QyKSB7XG4gICAgICByZXR1cm4gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oXG4gICAgICAgIHJldmFsaWRhdGlvblJlcXVlc3QsXG4gICAgICAgIHJlZGlyZWN0Mi5yZXN1bHQsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB7IHByZXZlbnRTY3JvbGxSZXNldCB9XG4gICAgICApO1xuICAgIH1cbiAgICByZWRpcmVjdDIgPSBmaW5kUmVkaXJlY3QoZmV0Y2hlclJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdDIpIHtcbiAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKHJlZGlyZWN0Mi5rZXkpO1xuICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKFxuICAgICAgICByZXZhbGlkYXRpb25SZXF1ZXN0LFxuICAgICAgICByZWRpcmVjdDIucmVzdWx0LFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgeyBwcmV2ZW50U2Nyb2xsUmVzZXQgfVxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHsgbG9hZGVyRGF0YSwgZXJyb3JzIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShcbiAgICAgIHN0YXRlLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICB2b2lkIDAsXG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgKTtcbiAgICBhYm9ydFN0YWxlRmV0Y2hMb2Fkcyhsb2FkSWQpO1xuICAgIGlmIChzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBsb2FkSWQgPiBwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCkge1xuICAgICAgaW52YXJpYW50KHBlbmRpbmdBY3Rpb24sIFwiRXhwZWN0ZWQgcGVuZGluZyBhY3Rpb25cIik7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgJiYgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyLmFib3J0KCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24oc3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiwge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBsb2FkZXJEYXRhOiBtZXJnZUxvYWRlckRhdGEoXG4gICAgICAgICAgc3RhdGUubG9hZGVyRGF0YSxcbiAgICAgICAgICBsb2FkZXJEYXRhLFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgZXJyb3JzXG4gICAgICAgICksXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJMb2FkZXIoa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcywgc2NvcGVkQ29udGV4dCwgaXNGb2dPZldhciwgZmx1c2hTeW5jLCBwcmV2ZW50U2Nyb2xsUmVzZXQsIHN1Ym1pc3Npb24pIHtcbiAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKFxuICAgICAga2V5LFxuICAgICAgZ2V0TG9hZGluZ0ZldGNoZXIoXG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdm9pZCAwXG4gICAgICApLFxuICAgICAgeyBmbHVzaFN5bmMgfVxuICAgICk7XG4gICAgbGV0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgZmV0Y2hSZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBpbml0Lmhpc3RvcnksXG4gICAgICBwYXRoLFxuICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICk7XG4gICAgaWYgKGlzRm9nT2ZXYXIpIHtcbiAgICAgIGxldCBkaXNjb3ZlclJlc3VsdCA9IGF3YWl0IGRpc2NvdmVyUm91dGVzKFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBwYXRoLFxuICAgICAgICBmZXRjaFJlcXVlc3Quc2lnbmFsLFxuICAgICAgICBrZXlcbiAgICAgICk7XG4gICAgICBpZiAoZGlzY292ZXJSZXN1bHQudHlwZSA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChkaXNjb3ZlclJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZGlzY292ZXJSZXN1bHQuZXJyb3IsIHsgZmx1c2hTeW5jIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKCFkaXNjb3ZlclJlc3VsdC5tYXRjaGVzKSB7XG4gICAgICAgIHNldEZldGNoZXJFcnJvcihcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcm91dGVJZCxcbiAgICAgICAgICBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogcGF0aCB9KSxcbiAgICAgICAgICB7IGZsdXNoU3luYyB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZXMgPSBkaXNjb3ZlclJlc3VsdC5tYXRjaGVzO1xuICAgICAgICBtYXRjaCA9IGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGFib3J0Q29udHJvbGxlcik7XG4gICAgbGV0IG9yaWdpbmF0aW5nTG9hZElkID0gaW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGxldCBkc01hdGNoZXMgPSBnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMoXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICBtYXRjaGVzLFxuICAgICAgbWF0Y2gsXG4gICAgICBoeWRyYXRpb25Sb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgc2NvcGVkQ29udGV4dFxuICAgICk7XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5KFxuICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgZHNNYXRjaGVzLFxuICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgIGtleVxuICAgICk7XG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGlmIChmZXRjaFJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uaGFzKGtleSkpIHtcbiAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHZvaWQgMCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPiBvcmlnaW5hdGluZ0xvYWRJZCkge1xuICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih2b2lkIDApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcbiAgICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oZmV0Y2hSZXF1ZXN0LCByZXN1bHQsIGZhbHNlLCB7XG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIHJlc3VsdC5lcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHJlc3VsdC5kYXRhKSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24ocmVxdWVzdCwgcmVkaXJlY3QyLCBpc05hdmlnYXRpb24sIHtcbiAgICBzdWJtaXNzaW9uLFxuICAgIGZldGNoZXJTdWJtaXNzaW9uLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICByZXBsYWNlOiByZXBsYWNlMlxuICB9ID0ge30pIHtcbiAgICBpZiAocmVkaXJlY3QyLnJlc3BvbnNlLmhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpKSB7XG4gICAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGxvY2F0aW9uID0gcmVkaXJlY3QyLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gICAgaW52YXJpYW50KGxvY2F0aW9uLCBcIkV4cGVjdGVkIGEgTG9jYXRpb24gaGVhZGVyIG9uIHRoZSByZWRpcmVjdCBSZXNwb25zZVwiKTtcbiAgICBsb2NhdGlvbiA9IG5vcm1hbGl6ZVJlZGlyZWN0TG9jYXRpb24oXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG5ldyBVUkwocmVxdWVzdC51cmwpLFxuICAgICAgYmFzZW5hbWVcbiAgICApO1xuICAgIGxldCByZWRpcmVjdExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIGxvY2F0aW9uLCB7XG4gICAgICBfaXNSZWRpcmVjdDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChpc0Jyb3dzZXIyKSB7XG4gICAgICBsZXQgaXNEb2N1bWVudFJlbG9hZCA9IGZhbHNlO1xuICAgICAgaWYgKHJlZGlyZWN0Mi5yZXNwb25zZS5oZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpKSB7XG4gICAgICAgIGlzRG9jdW1lbnRSZWxvYWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChBQlNPTFVURV9VUkxfUkVHRVgudGVzdChsb2NhdGlvbikpIHtcbiAgICAgICAgY29uc3QgdXJsID0gY3JlYXRlQnJvd3NlclVSTEltcGwobG9jYXRpb24sIHRydWUpO1xuICAgICAgICBpc0RvY3VtZW50UmVsb2FkID0gLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdG8gYSBuZXcgb3JpZ2luXG4gICAgICAgIHVybC5vcmlnaW4gIT09IHJvdXRlcldpbmRvdy5sb2NhdGlvbi5vcmlnaW4gfHwgLy8gSGFyZCByZWxvYWQgaWYgaXQncyBhbiBhYnNvbHV0ZSBVUkwgdGhhdCBkb2VzIG5vdCBtYXRjaCBvdXIgYmFzZW5hbWVcbiAgICAgICAgc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSA9PSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGlzRG9jdW1lbnRSZWxvYWQpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UyKSB7XG4gICAgICAgICAgcm91dGVyV2luZG93LmxvY2F0aW9uLnJlcGxhY2UobG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlcldpbmRvdy5sb2NhdGlvbi5hc3NpZ24obG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBsZXQgcmVkaXJlY3ROYXZpZ2F0aW9uVHlwZSA9IHJlcGxhY2UyID09PSB0cnVlIHx8IHJlZGlyZWN0Mi5yZXNwb25zZS5oZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVwbGFjZVwiKSA/IFwiUkVQTEFDRVwiIC8qIFJlcGxhY2UgKi8gOiBcIlBVU0hcIiAvKiBQdXNoICovO1xuICAgIGxldCB7IGZvcm1NZXRob2QsIGZvcm1BY3Rpb24sIGZvcm1FbmNUeXBlIH0gPSBzdGF0ZS5uYXZpZ2F0aW9uO1xuICAgIGlmICghc3VibWlzc2lvbiAmJiAhZmV0Y2hlclN1Ym1pc3Npb24gJiYgZm9ybU1ldGhvZCAmJiBmb3JtQWN0aW9uICYmIGZvcm1FbmNUeXBlKSB7XG4gICAgICBzdWJtaXNzaW9uID0gZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKHN0YXRlLm5hdmlnYXRpb24pO1xuICAgIH1cbiAgICBsZXQgYWN0aXZlU3VibWlzc2lvbiA9IHN1Ym1pc3Npb24gfHwgZmV0Y2hlclN1Ym1pc3Npb247XG4gICAgaWYgKHJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2Rlcy5oYXMocmVkaXJlY3QyLnJlc3BvbnNlLnN0YXR1cykgJiYgYWN0aXZlU3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKGFjdGl2ZVN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihyZWRpcmVjdE5hdmlnYXRpb25UeXBlLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAuLi5hY3RpdmVTdWJtaXNzaW9uLFxuICAgICAgICAgIGZvcm1BY3Rpb246IGxvY2F0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByZXNlcnZlIHRoZXNlIGZsYWdzIGFjcm9zcyByZWRpcmVjdHNcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBwcmV2ZW50U2Nyb2xsUmVzZXQgfHwgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgZW5hYmxlVmlld1RyYW5zaXRpb246IGlzTmF2aWdhdGlvbiA/IHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgb3ZlcnJpZGVOYXZpZ2F0aW9uID0gZ2V0TG9hZGluZ05hdmlnYXRpb24oXG4gICAgICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICAgIHN1Ym1pc3Npb25cbiAgICAgICk7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3ROYXZpZ2F0aW9uVHlwZSwgcmVkaXJlY3RMb2NhdGlvbiwge1xuICAgICAgICBvdmVycmlkZU5hdmlnYXRpb24sXG4gICAgICAgIC8vIFNlbmQgZmV0Y2hlciBzdWJtaXNzaW9ucyB0aHJvdWdoIGZvciBzaG91bGRSZXZhbGlkYXRlXG4gICAgICAgIGZldGNoZXJTdWJtaXNzaW9uLFxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGVzZSBmbGFncyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcHJldmVudFNjcm9sbFJlc2V0IHx8IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBpc05hdmlnYXRpb24gPyBwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbERhdGFTdHJhdGVneShyZXF1ZXN0LCBtYXRjaGVzLCBzY29wZWRDb250ZXh0LCBmZXRjaGVyS2V5KSB7XG4gICAgbGV0IHJlc3VsdHM7XG4gICAgbGV0IGRhdGFSZXN1bHRzID0ge307XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdHMgPSBhd2FpdCBjYWxsRGF0YVN0cmF0ZWd5SW1wbChcbiAgICAgICAgZGF0YVN0cmF0ZWd5SW1wbCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgZmV0Y2hlcktleSxcbiAgICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbWF0Y2hlcy5maWx0ZXIoKG0pID0+IG0uc2hvdWxkTG9hZCkuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgICBkYXRhUmVzdWx0c1ttLnJvdXRlLmlkXSA9IHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRhdGFSZXN1bHRzO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIGRhdGFSZXN1bHRzO1xuICAgIH1cbiAgICBmb3IgKGxldCBbcm91dGVJZCwgcmVzdWx0XSBvZiBPYmplY3QuZW50cmllcyhyZXN1bHRzKSkge1xuICAgICAgaWYgKGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSByZXN1bHQucmVzdWx0O1xuICAgICAgICBkYXRhUmVzdWx0c1tyb3V0ZUlkXSA9IHtcbiAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0XCIgLyogcmVkaXJlY3QgKi8sXG4gICAgICAgICAgcmVzcG9uc2U6IG5vcm1hbGl6ZVJlbGF0aXZlUm91dGluZ1JlZGlyZWN0UmVzcG9uc2UoXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgICAgKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVJlc3VsdHNbcm91dGVJZF0gPSBhd2FpdCBjb252ZXJ0RGF0YVN0cmF0ZWd5UmVzdWx0VG9EYXRhUmVzdWx0KFxuICAgICAgICAgIHJlc3VsdFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKG1hdGNoZXMsIGZldGNoZXJzVG9Mb2FkLCByZXF1ZXN0LCBzY29wZWRDb250ZXh0KSB7XG4gICAgbGV0IGxvYWRlclJlc3VsdHNQcm9taXNlID0gY2FsbERhdGFTdHJhdGVneShcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtYXRjaGVzLFxuICAgICAgc2NvcGVkQ29udGV4dCxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGxldCBmZXRjaGVyUmVzdWx0c1Byb21pc2UgPSBQcm9taXNlLmFsbChcbiAgICAgIGZldGNoZXJzVG9Mb2FkLm1hcChhc3luYyAoZikgPT4ge1xuICAgICAgICBpZiAoZi5tYXRjaGVzICYmIGYubWF0Y2ggJiYgZi5yZXF1ZXN0ICYmIGYuY29udHJvbGxlcikge1xuICAgICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgY2FsbERhdGFTdHJhdGVneShcbiAgICAgICAgICAgIGYucmVxdWVzdCxcbiAgICAgICAgICAgIGYubWF0Y2hlcyxcbiAgICAgICAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICAgICAgICBmLmtleVxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IHJlc3VsdHNbZi5tYXRjaC5yb3V0ZS5pZF07XG4gICAgICAgICAgcmV0dXJuIHsgW2Yua2V5XTogcmVzdWx0IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBbZi5rZXldOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWU6IGYucGF0aFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgbGV0IGxvYWRlclJlc3VsdHMgPSBhd2FpdCBsb2FkZXJSZXN1bHRzUHJvbWlzZTtcbiAgICBsZXQgZmV0Y2hlclJlc3VsdHMgPSAoYXdhaXQgZmV0Y2hlclJlc3VsdHNQcm9taXNlKS5yZWR1Y2UoXG4gICAgICAoYWNjLCByKSA9PiBPYmplY3QuYXNzaWduKGFjYywgciksXG4gICAgICB7fVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRlclJlc3VsdHMsXG4gICAgICBmZXRjaGVyUmVzdWx0c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJydXB0QWN0aXZlTG9hZHMoKSB7XG4gICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGZldGNoZXIsIG9wdHMgPSB7fSkge1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKFxuICAgICAgeyBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycykgfSxcbiAgICAgIHsgZmx1c2hTeW5jOiAob3B0cyAmJiBvcHRzLmZsdXNoU3luYykgPT09IHRydWUgfVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZXJyb3IsIG9wdHMgPSB7fSkge1xuICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCByb3V0ZUlkKTtcbiAgICBkZWxldGVGZXRjaGVyKGtleSk7XG4gICAgdXBkYXRlU3RhdGUoXG4gICAgICB7XG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgICB9LFxuICAgICAgeyBmbHVzaFN5bmM6IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZSB9XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRGZXRjaGVyKGtleSkge1xuICAgIGFjdGl2ZUZldGNoZXJzLnNldChrZXksIChhY3RpdmVGZXRjaGVycy5nZXQoa2V5KSB8fCAwKSArIDEpO1xuICAgIGlmIChmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmhhcyhrZXkpKSB7XG4gICAgICBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXIoa2V5KSB7XG4gICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSAmJiAhKGZldGNoZXIgJiYgZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgZmV0Y2hSZWxvYWRJZHMuaGFzKGtleSkpKSB7XG4gICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICB9XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaFJlZGlyZWN0SWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoZXJzUXVldWVkRm9yRGVsZXRpb24uZGVsZXRlKGtleSk7XG4gICAgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHF1ZXVlRmV0Y2hlckZvckRlbGV0aW9uKGtleSkge1xuICAgIGxldCBjb3VudCA9IChhY3RpdmVGZXRjaGVycy5nZXQoa2V5KSB8fCAwKSAtIDE7XG4gICAgaWYgKGNvdW50IDw9IDApIHtcbiAgICAgIGFjdGl2ZUZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbi5hZGQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aXZlRmV0Y2hlcnMuc2V0KGtleSwgY291bnQpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZSh7IGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSB9KTtcbiAgfVxuICBmdW5jdGlvbiBhYm9ydEZldGNoZXIoa2V5KSB7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpO1xuICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXJrRmV0Y2hlcnNEb25lKGtleXMpIHtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgbGV0IGZldGNoZXIgPSBnZXRGZXRjaGVyKGtleSk7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihmZXRjaGVyLmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCkge1xuICAgIGxldCBkb25lS2V5cyA9IFtdO1xuICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2YgZmV0Y2hSZWRpcmVjdElkcykge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgZG9uZUtleXMucHVzaChrZXkpO1xuICAgICAgICB1cGRhdGVkRmV0Y2hlcnMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKGRvbmVLZXlzKTtcbiAgICByZXR1cm4gdXBkYXRlZEZldGNoZXJzO1xuICB9XG4gIGZ1bmN0aW9uIGFib3J0U3RhbGVGZXRjaExvYWRzKGxhbmRlZElkKSB7XG4gICAgbGV0IHllZXRlZEtleXMgPSBbXTtcbiAgICBmb3IgKGxldCBba2V5LCBpZF0gb2YgZmV0Y2hSZWxvYWRJZHMpIHtcbiAgICAgIGlmIChpZCA8IGxhbmRlZElkKSB7XG4gICAgICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgICAgIGludmFyaWFudChmZXRjaGVyLCBgRXhwZWN0ZWQgZmV0Y2hlcjogJHtrZXl9YCk7XG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoeWVldGVkS2V5cyk7XG4gICAgcmV0dXJuIHllZXRlZEtleXMubGVuZ3RoID4gMDtcbiAgfVxuICBmdW5jdGlvbiBnZXRCbG9ja2VyKGtleSwgZm4pIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5nZXQoa2V5KSAhPT0gZm4pIHtcbiAgICAgIGJsb2NrZXJGdW5jdGlvbnMuc2V0KGtleSwgZm4pO1xuICAgIH1cbiAgICByZXR1cm4gYmxvY2tlcjtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVCbG9ja2VyKGtleSkge1xuICAgIHN0YXRlLmJsb2NrZXJzLmRlbGV0ZShrZXkpO1xuICAgIGJsb2NrZXJGdW5jdGlvbnMuZGVsZXRlKGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlQmxvY2tlcihrZXksIG5ld0Jsb2NrZXIpIHtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChrZXkpIHx8IElETEVfQkxPQ0tFUjtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBibG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIixcbiAgICAgIGBJbnZhbGlkIGJsb2NrZXIgc3RhdGUgdHJhbnNpdGlvbjogJHtibG9ja2VyLnN0YXRlfSAtPiAke25ld0Jsb2NrZXIuc3RhdGV9YFxuICAgICk7XG4gICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgYmxvY2tlcnMuc2V0KGtleSwgbmV3QmxvY2tlcik7XG4gICAgdXBkYXRlU3RhdGUoeyBibG9ja2VycyB9KTtcbiAgfVxuICBmdW5jdGlvbiBzaG91bGRCbG9ja05hdmlnYXRpb24oe1xuICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICBuZXh0TG9jYXRpb24sXG4gICAgaGlzdG9yeUFjdGlvblxuICB9KSB7XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYmxvY2tlckZ1bmN0aW9ucy5zaXplID4gMSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgXCJBIHJvdXRlciBvbmx5IHN1cHBvcnRzIG9uZSBibG9ja2VyIGF0IGEgdGltZVwiKTtcbiAgICB9XG4gICAgbGV0IGVudHJpZXMgPSBBcnJheS5mcm9tKGJsb2NrZXJGdW5jdGlvbnMuZW50cmllcygpKTtcbiAgICBsZXQgW2Jsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0gPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoYmxvY2tlcktleSk7XG4gICAgaWYgKGJsb2NrZXIgJiYgYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbih7IGN1cnJlbnRMb2NhdGlvbiwgbmV4dExvY2F0aW9uLCBoaXN0b3J5QWN0aW9uIH0pKSB7XG4gICAgICByZXR1cm4gYmxvY2tlcktleTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmF2aWdhdGlvbmFsNDA0KHBhdGhuYW1lKSB7XG4gICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHsgcGF0aG5hbWUgfSk7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IHsgbWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzVG9Vc2UpO1xuICAgIHJldHVybiB7IG5vdEZvdW5kTWF0Y2hlczogbWF0Y2hlcywgcm91dGUsIGVycm9yIH07XG4gIH1cbiAgZnVuY3Rpb24gZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24ocG9zaXRpb25zLCBnZXRQb3NpdGlvbiwgZ2V0S2V5KSB7XG4gICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMyID0gcG9zaXRpb25zO1xuICAgIGdldFNjcm9sbFBvc2l0aW9uID0gZ2V0UG9zaXRpb247XG4gICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkyID0gZ2V0S2V5IHx8IG51bGw7XG4gICAgaWYgKCFpbml0aWFsU2Nyb2xsUmVzdG9yZWQgJiYgc3RhdGUubmF2aWdhdGlvbiA9PT0gSURMRV9OQVZJR0FUSU9OKSB7XG4gICAgICBpbml0aWFsU2Nyb2xsUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgbGV0IHkgPSBnZXRTYXZlZFNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU3RhdGUoeyByZXN0b3JlU2Nyb2xsUG9zaXRpb246IHkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uczIgPSBudWxsO1xuICAgICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICAgICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkyID0gbnVsbDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFNjcm9sbEtleShsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGlmIChnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIpIHtcbiAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleTIoXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLm1hcCgobSkgPT4gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobSwgc3RhdGUubG9hZGVyRGF0YSkpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGtleSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhdGlvbi5rZXk7XG4gIH1cbiAgZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKHNhdmVkU2Nyb2xsUG9zaXRpb25zMiAmJiBnZXRTY3JvbGxQb3NpdGlvbikge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbEtleShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uczJba2V5XSA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFNhdmVkU2Nyb2xsUG9zaXRpb24obG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBpZiAoc2F2ZWRTY3JvbGxQb3NpdGlvbnMyKSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgIGxldCB5ID0gc2F2ZWRTY3JvbGxQb3NpdGlvbnMyW2tleV07XG4gICAgICBpZiAodHlwZW9mIHkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrRm9nT2ZXYXIobWF0Y2hlcywgcm91dGVzVG9Vc2UsIHBhdGhuYW1lKSB7XG4gICAgaWYgKGluaXQucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24pIHtcbiAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICBsZXQgZm9nTWF0Y2hlcyA9IG1hdGNoUm91dGVzSW1wbChcbiAgICAgICAgICByb3V0ZXNUb1VzZSxcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB7IGFjdGl2ZTogdHJ1ZSwgbWF0Y2hlczogZm9nTWF0Y2hlcyB8fCBbXSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1hdGNoZXNbMF0ucGFyYW1zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IHBhcnRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIGJhc2VuYW1lLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHsgYWN0aXZlOiB0cnVlLCBtYXRjaGVzOiBwYXJ0aWFsTWF0Y2hlcyB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGFjdGl2ZTogZmFsc2UsIG1hdGNoZXM6IG51bGwgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkaXNjb3ZlclJvdXRlcyhtYXRjaGVzLCBwYXRobmFtZSwgc2lnbmFsLCBmZXRjaGVyS2V5KSB7XG4gICAgaWYgKCFpbml0LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWF0Y2hlcyB9O1xuICAgIH1cbiAgICBsZXQgcGFydGlhbE1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgaXNOb25ITVIgPSBpbkZsaWdodERhdGFSb3V0ZXMgPT0gbnVsbDtcbiAgICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgICAgbGV0IGxvY2FsTWFuaWZlc3QgPSBtYW5pZmVzdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGluaXQucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24oe1xuICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICBwYXRoOiBwYXRobmFtZSxcbiAgICAgICAgICBtYXRjaGVzOiBwYXJ0aWFsTWF0Y2hlcyxcbiAgICAgICAgICBmZXRjaGVyS2V5LFxuICAgICAgICAgIHBhdGNoOiAocm91dGVJZCwgY2hpbGRyZW4pID0+IHtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICAgICAgcGF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgICAgICAgICByb3V0ZUlkLFxuICAgICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgICAgcm91dGVzVG9Vc2UsXG4gICAgICAgICAgICAgIGxvY2FsTWFuaWZlc3QsXG4gICAgICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogZSwgcGFydGlhbE1hdGNoZXMgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChpc05vbkhNUiAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICBkYXRhUm91dGVzID0gWy4uLmRhdGFSb3V0ZXNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJhYm9ydGVkXCIgfTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdNYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIHBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgICBpZiAobmV3TWF0Y2hlcykge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWF0Y2hlczogbmV3TWF0Y2hlcyB9O1xuICAgICAgfVxuICAgICAgbGV0IG5ld1BhcnRpYWxNYXRjaGVzID0gbWF0Y2hSb3V0ZXNJbXBsKFxuICAgICAgICByb3V0ZXNUb1VzZSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgICAgaWYgKCFuZXdQYXJ0aWFsTWF0Y2hlcyB8fCBwYXJ0aWFsTWF0Y2hlcy5sZW5ndGggPT09IG5ld1BhcnRpYWxNYXRjaGVzLmxlbmd0aCAmJiBwYXJ0aWFsTWF0Y2hlcy5ldmVyeShcbiAgICAgICAgKG0sIGkpID0+IG0ucm91dGUuaWQgPT09IG5ld1BhcnRpYWxNYXRjaGVzW2ldLnJvdXRlLmlkXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXRjaGVzOiBudWxsIH07XG4gICAgICB9XG4gICAgICBwYXJ0aWFsTWF0Y2hlcyA9IG5ld1BhcnRpYWxNYXRjaGVzO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfaW50ZXJuYWxTZXRSb3V0ZXMobmV3Um91dGVzKSB7XG4gICAgbWFuaWZlc3QgPSB7fTtcbiAgICBpbkZsaWdodERhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgICAgbmV3Um91dGVzLFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIHZvaWQgMCxcbiAgICAgIG1hbmlmZXN0XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBwYXRjaFJvdXRlcyhyb3V0ZUlkLCBjaGlsZHJlbikge1xuICAgIGxldCBpc05vbkhNUiA9IGluRmxpZ2h0RGF0YVJvdXRlcyA9PSBudWxsO1xuICAgIGxldCByb3V0ZXNUb1VzZSA9IGluRmxpZ2h0RGF0YVJvdXRlcyB8fCBkYXRhUm91dGVzO1xuICAgIHBhdGNoUm91dGVzSW1wbChcbiAgICAgIHJvdXRlSWQsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIHJvdXRlc1RvVXNlLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyXG4gICAgKTtcbiAgICBpZiAoaXNOb25ITVIpIHtcbiAgICAgIGRhdGFSb3V0ZXMgPSBbLi4uZGF0YVJvdXRlc107XG4gICAgICB1cGRhdGVTdGF0ZSh7fSk7XG4gICAgfVxuICB9XG4gIHJvdXRlciA9IHtcbiAgICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgICByZXR1cm4gYmFzZW5hbWU7XG4gICAgfSxcbiAgICBnZXQgZnV0dXJlKCkge1xuICAgICAgcmV0dXJuIGZ1dHVyZTtcbiAgICB9LFxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICByZXR1cm4gZGF0YVJvdXRlcztcbiAgICB9LFxuICAgIGdldCB3aW5kb3coKSB7XG4gICAgICByZXR1cm4gcm91dGVyV2luZG93O1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZSxcbiAgICBzdWJzY3JpYmUsXG4gICAgZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24sXG4gICAgbmF2aWdhdGUsXG4gICAgZmV0Y2g6IGZldGNoMixcbiAgICByZXZhbGlkYXRlLFxuICAgIC8vIFBhc3N0aHJvdWdoIHRvIGhpc3RvcnktYXdhcmUgY3JlYXRlSHJlZiB1c2VkIGJ5IHVzZUhyZWYgc28gd2UgZ2V0IHByb3BlclxuICAgIC8vIGhhc2gtYXdhcmUgVVJMcyBpbiBET00gcGF0aHNcbiAgICBjcmVhdGVIcmVmOiAodG8pID0+IGluaXQuaGlzdG9yeS5jcmVhdGVIcmVmKHRvKSxcbiAgICBlbmNvZGVMb2NhdGlvbjogKHRvKSA9PiBpbml0Lmhpc3RvcnkuZW5jb2RlTG9jYXRpb24odG8pLFxuICAgIGdldEZldGNoZXIsXG4gICAgZGVsZXRlRmV0Y2hlcjogcXVldWVGZXRjaGVyRm9yRGVsZXRpb24sXG4gICAgZGlzcG9zZSxcbiAgICBnZXRCbG9ja2VyLFxuICAgIGRlbGV0ZUJsb2NrZXIsXG4gICAgcGF0Y2hSb3V0ZXMsXG4gICAgX2ludGVybmFsRmV0Y2hDb250cm9sbGVyczogZmV0Y2hDb250cm9sbGVycyxcbiAgICAvLyBUT0RPOiBSZW1vdmUgc2V0Um91dGVzLCBpdCdzIHRlbXBvcmFyeSB0byBhdm9pZCBkZWFsaW5nIHdpdGhcbiAgICAvLyB1cGRhdGluZyB0aGUgdHJlZSB3aGlsZSB2YWxpZGF0aW5nIHRoZSB1cGRhdGUgYWxnb3JpdGhtLlxuICAgIF9pbnRlcm5hbFNldFJvdXRlc1xuICB9O1xuICByZXR1cm4gcm91dGVyO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljSGFuZGxlcihyb3V0ZXMsIG9wdHMpIHtcbiAgaW52YXJpYW50KFxuICAgIHJvdXRlcy5sZW5ndGggPiAwLFxuICAgIFwiWW91IG11c3QgcHJvdmlkZSBhIG5vbi1lbXB0eSByb3V0ZXMgYXJyYXkgdG8gY3JlYXRlU3RhdGljSGFuZGxlclwiXG4gICk7XG4gIGxldCBtYW5pZmVzdCA9IHt9O1xuICBsZXQgYmFzZW5hbWUgPSAob3B0cyA/IG9wdHMuYmFzZW5hbWUgOiBudWxsKSB8fCBcIi9cIjtcbiAgbGV0IG1hcFJvdXRlUHJvcGVydGllczIgPSBvcHRzPy5tYXBSb3V0ZVByb3BlcnRpZXMgfHwgZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgIHZvaWQgMCxcbiAgICBtYW5pZmVzdFxuICApO1xuICBhc3luYyBmdW5jdGlvbiBxdWVyeShyZXF1ZXN0LCB7XG4gICAgcmVxdWVzdENvbnRleHQsXG4gICAgZmlsdGVyTWF0Y2hlc1RvTG9hZCxcbiAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICBza2lwUmV2YWxpZGF0aW9uLFxuICAgIGRhdGFTdHJhdGVneSxcbiAgICB1bnN0YWJsZV9yZXNwb25kOiByZXNwb25kXG4gIH0gPSB7fSkge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIHJlcXVlc3RDb250ZXh0ID0gcmVxdWVzdENvbnRleHQgIT0gbnVsbCA/IHJlcXVlc3RDb250ZXh0IDogbmV3IHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlcigpO1xuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZCB9KTtcbiAgICAgIGxldCB7IG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLCByb3V0ZSB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIGxldCBzdGF0aWNDb250ZXh0ID0ge1xuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IG1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge31cbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzcG9uZCA/IHJlc3BvbmQoc3RhdGljQ29udGV4dCkgOiBzdGF0aWNDb250ZXh0O1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICAgIGxldCB7IG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcywgcm91dGUgfSA9IGdldFNob3J0Q2lyY3VpdE1hdGNoZXMoZGF0YVJvdXRlcyk7XG4gICAgICBsZXQgc3RhdGljQ29udGV4dCA9IHtcbiAgICAgICAgYmFzZW5hbWUsXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXNwb25kID8gcmVzcG9uZChzdGF0aWNDb250ZXh0KSA6IHN0YXRpY0NvbnRleHQ7XG4gICAgfVxuICAgIGlmIChyZXNwb25kICYmIG1hdGNoZXMuc29tZShcbiAgICAgIChtKSA9PiBtLnJvdXRlLnVuc3RhYmxlX21pZGRsZXdhcmUgfHwgdHlwZW9mIG0ucm91dGUubGF6eSA9PT0gXCJvYmplY3RcIiAmJiBtLnJvdXRlLmxhenkudW5zdGFibGVfbWlkZGxld2FyZVxuICAgICkpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgcmVxdWVzdENvbnRleHQgaW5zdGFuY2VvZiB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXIsXG4gICAgICAgIFwiV2hlbiB1c2luZyBtaWRkbGV3YXJlIGluIGBzdGF0aWNIYW5kbGVyLnF1ZXJ5KClgLCBhbnkgcHJvdmlkZWQgYHJlcXVlc3RDb250ZXh0YCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXJgXCJcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBsb2FkTGF6eU1pZGRsZXdhcmVGb3JNYXRjaGVzKFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMlxuICAgICAgICApO1xuICAgICAgICBsZXQgcmVuZGVyZWRTdGF0aWNDb250ZXh0O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBydW5NaWRkbGV3YXJlUGlwZWxpbmUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgICBwYXJhbXM6IG1hdGNoZXNbMF0ucGFyYW1zLFxuICAgICAgICAgICAgLy8gSWYgd2UncmUgY2FsbGluZyBtaWRkbGV3YXJlIHRoZW4gaXQgbXVzdCBiZSBlbmFibGVkIHNvIHdlIGNhbiBjYXN0XG4gICAgICAgICAgICAvLyB0aGlzIHRvIHRoZSBwcm9wZXIgdHlwZSBrbm93aW5nIGl0J3Mgbm90IGFuIGBBcHBMb2FkQ29udGV4dGBcbiAgICAgICAgICAgIGNvbnRleHQ6IHJlcXVlc3RDb250ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQyID0gYXdhaXQgcXVlcnlJbXBsKFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgICAgICAgIGRhdGFTdHJhdGVneSB8fCBudWxsLFxuICAgICAgICAgICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyA9PT0gdHJ1ZSxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgZmlsdGVyTWF0Y2hlc1RvTG9hZCB8fCBudWxsLFxuICAgICAgICAgICAgICBza2lwUmV2YWxpZGF0aW9uID09PSB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0MikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJlZFN0YXRpY0NvbnRleHQgPSB7IGxvY2F0aW9uLCBiYXNlbmFtZSwgLi4ucmVzdWx0MiB9O1xuICAgICAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHJlc3BvbmQocmVuZGVyZWRTdGF0aWNDb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyAoZXJyb3IsIHJvdXRlSWQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVuZGVyZWRTdGF0aWNDb250ZXh0KSB7XG4gICAgICAgICAgICAgIGlmIChyb3V0ZUlkIGluIHJlbmRlcmVkU3RhdGljQ29udGV4dC5sb2FkZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRTdGF0aWNDb250ZXh0LmxvYWRlckRhdGFbcm91dGVJZF0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbmQoXG4gICAgICAgICAgICAgICAgZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihcbiAgICAgICAgICAgICAgICAgIGRhdGFSb3V0ZXMsXG4gICAgICAgICAgICAgICAgICByZW5kZXJlZFN0YXRpY0NvbnRleHQsXG4gICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nID8gcm91dGVJZCA6IGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgcm91dGVJZCkucm91dGUuaWRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXQgYm91bmRhcnlSb3V0ZUlkID0gc2tpcExvYWRlckVycm9yQnViYmxpbmcgPyByb3V0ZUlkIDogZmluZE5lYXJlc3RCb3VuZGFyeShcbiAgICAgICAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgICAgICAgIG1hdGNoZXMuZmluZChcbiAgICAgICAgICAgICAgICAgIChtKSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkIHx8IG0ucm91dGUubG9hZGVyXG4gICAgICAgICAgICAgICAgKT8ucm91dGUuaWQgfHwgcm91dGVJZFxuICAgICAgICAgICAgICApLnJvdXRlLmlkO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uZCh7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgICAgICAgW2JvdW5kYXJ5Um91dGVJZF06IGVycm9yXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBlcnJvci5zdGF0dXMgOiA1MDAsXG4gICAgICAgICAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgbG9hZGVySGVhZGVyczoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBpbnZhcmlhbnQoaXNSZXNwb25zZShyZXNwb25zZSksIFwiRXhwZWN0ZWQgYSByZXNwb25zZSBpbiBxdWVyeSgpXCIpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChpc1Jlc3BvbnNlKGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIGRhdGFTdHJhdGVneSB8fCBudWxsLFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcgPT09IHRydWUsXG4gICAgICBudWxsLFxuICAgICAgZmlsdGVyTWF0Y2hlc1RvTG9hZCB8fCBudWxsLFxuICAgICAgc2tpcFJldmFsaWRhdGlvbiA9PT0gdHJ1ZVxuICAgICk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHsgbG9jYXRpb24sIGJhc2VuYW1lLCAuLi5yZXN1bHQgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBxdWVyeVJvdXRlKHJlcXVlc3QsIHtcbiAgICByb3V0ZUlkLFxuICAgIHJlcXVlc3RDb250ZXh0LFxuICAgIGRhdGFTdHJhdGVneSxcbiAgICB1bnN0YWJsZV9yZXNwb25kOiByZXNwb25kXG4gIH0gPSB7fSkge1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oXCJcIiwgY3JlYXRlUGF0aCh1cmwpLCBudWxsLCBcImRlZmF1bHRcIik7XG4gICAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhkYXRhUm91dGVzLCBsb2NhdGlvbiwgYmFzZW5hbWUpO1xuICAgIHJlcXVlc3RDb250ZXh0ID0gcmVxdWVzdENvbnRleHQgIT0gbnVsbCA/IHJlcXVlc3RDb250ZXh0IDogbmV3IHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlcigpO1xuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIgJiYgbWV0aG9kICE9PSBcIk9QVElPTlNcIikge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHsgbWV0aG9kIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7IHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSB9KTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gcm91dGVJZCA/IG1hdGNoZXMuZmluZCgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgOiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbik7XG4gICAgaWYgKHJvdXRlSWQgJiYgIW1hdGNoKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMywge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwgeyBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUgfSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25kICYmIG1hdGNoZXMuc29tZShcbiAgICAgIChtKSA9PiBtLnJvdXRlLnVuc3RhYmxlX21pZGRsZXdhcmUgfHwgdHlwZW9mIG0ucm91dGUubGF6eSA9PT0gXCJvYmplY3RcIiAmJiBtLnJvdXRlLmxhenkudW5zdGFibGVfbWlkZGxld2FyZVxuICAgICkpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgcmVxdWVzdENvbnRleHQgaW5zdGFuY2VvZiB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXIsXG4gICAgICAgIFwiV2hlbiB1c2luZyBtaWRkbGV3YXJlIGluIGBzdGF0aWNIYW5kbGVyLnF1ZXJ5Um91dGUoKWAsIGFueSBwcm92aWRlZCBgcmVxdWVzdENvbnRleHRgIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgYHVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlcmBcIlxuICAgICAgKTtcbiAgICAgIGF3YWl0IGxvYWRMYXp5TWlkZGxld2FyZUZvck1hdGNoZXMobWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllczIpO1xuICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgcnVuTWlkZGxld2FyZVBpcGVsaW5lKFxuICAgICAgICB7XG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIHBhcmFtczogbWF0Y2hlc1swXS5wYXJhbXMsXG4gICAgICAgICAgLy8gSWYgd2UncmUgY2FsbGluZyBtaWRkbGV3YXJlIHRoZW4gaXQgbXVzdCBiZSBlbmFibGVkIHNvIHdlIGNhbiBjYXN0XG4gICAgICAgICAgLy8gdGhpcyB0byB0aGUgcHJvcGVyIHR5cGUga25vd2luZyBpdCdzIG5vdCBhbiBgQXBwTG9hZENvbnRleHRgXG4gICAgICAgICAgY29udGV4dDogcmVxdWVzdENvbnRleHRcbiAgICAgICAgfSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGxldCByZXN1bHQyID0gYXdhaXQgcXVlcnlJbXBsKFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICAgICAgZGF0YVN0cmF0ZWd5IHx8IG51bGwsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbmQocmVzdWx0Mik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBlcnJvcjIgPSByZXN1bHQyLmVycm9ycyA/IE9iamVjdC52YWx1ZXMocmVzdWx0Mi5lcnJvcnMpWzBdIDogdm9pZCAwO1xuICAgICAgICAgIGlmIChlcnJvcjIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdmFsdWUgPSByZXN1bHQyLmFjdGlvbkRhdGEgPyBPYmplY3QudmFsdWVzKHJlc3VsdDIuYWN0aW9uRGF0YSlbMF0gOiBPYmplY3QudmFsdWVzKHJlc3VsdDIubG9hZGVyRGF0YSlbMF07XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IG5ldyBSZXNwb25zZSh2YWx1ZSkgOiBSZXNwb25zZS5qc29uKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycm9yMikgPT4ge1xuICAgICAgICAgIGlmIChpc1Jlc3BvbnNlKGVycm9yMikpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25kKGVycm9yMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoU3RyaW5nKGVycm9yMiksIHtcbiAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwoXG4gICAgICByZXF1ZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICBkYXRhU3RyYXRlZ3kgfHwgbnVsbCxcbiAgICAgIGZhbHNlLFxuICAgICAgbWF0Y2gsXG4gICAgICBudWxsLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcnMgPyBPYmplY3QudmFsdWVzKHJlc3VsdC5lcnJvcnMpWzBdIDogdm9pZCAwO1xuICAgIGlmIChlcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5hY3Rpb25EYXRhKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZXN1bHQuYWN0aW9uRGF0YSlbMF07XG4gICAgfVxuICAgIGlmIChyZXN1bHQubG9hZGVyRGF0YSkge1xuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVzdWx0LmxvYWRlckRhdGEpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIGRhdGFTdHJhdGVneSwgc2tpcExvYWRlckVycm9yQnViYmxpbmcsIHJvdXRlTWF0Y2gsIGZpbHRlck1hdGNoZXNUb0xvYWQsIHNraXBSZXZhbGlkYXRpb24pIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgIFwicXVlcnkoKS9xdWVyeVJvdXRlKCkgcmVxdWVzdHMgbXVzdCBjb250YWluIGFuIEFib3J0Q29udHJvbGxlciBzaWduYWxcIlxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICBsZXQgcmVzdWx0MiA9IGF3YWl0IHN1Ym1pdChcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgcm91dGVNYXRjaCB8fCBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbiksXG4gICAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLFxuICAgICAgICAgIHJvdXRlTWF0Y2ggIT0gbnVsbCxcbiAgICAgICAgICBmaWx0ZXJNYXRjaGVzVG9Mb2FkLFxuICAgICAgICAgIHNraXBSZXZhbGlkYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgbG9hZFJvdXRlRGF0YShcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcmVxdWVzdENvbnRleHQsXG4gICAgICAgIGRhdGFTdHJhdGVneSxcbiAgICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmcsXG4gICAgICAgIHJvdXRlTWF0Y2gsXG4gICAgICAgIGZpbHRlck1hdGNoZXNUb0xvYWRcbiAgICAgICk7XG4gICAgICByZXR1cm4gaXNSZXNwb25zZShyZXN1bHQpID8gcmVzdWx0IDoge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIGFjdGlvbkRhdGE6IG51bGwsXG4gICAgICAgIGFjdGlvbkhlYWRlcnM6IHt9XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChpc0RhdGFTdHJhdGVneVJlc3VsdChlKSAmJiBpc1Jlc3BvbnNlKGUucmVzdWx0KSkge1xuICAgICAgICBpZiAoZS50eXBlID09PSBcImVycm9yXCIgLyogZXJyb3IgKi8pIHtcbiAgICAgICAgICB0aHJvdyBlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS5yZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKGUpKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3VibWl0KHJlcXVlc3QsIG1hdGNoZXMsIGFjdGlvbk1hdGNoLCByZXF1ZXN0Q29udGV4dCwgZGF0YVN0cmF0ZWd5LCBza2lwTG9hZGVyRXJyb3JCdWJibGluZywgaXNSb3V0ZVJlcXVlc3QsIGZpbHRlck1hdGNoZXNUb0xvYWQsIHNraXBSZXZhbGlkYXRpb24pIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICB9KTtcbiAgICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRzTWF0Y2hlcyA9IGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhcbiAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGFjdGlvbk1hdGNoLFxuICAgICAgICBbXSxcbiAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgICk7XG4gICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGRzTWF0Y2hlcyxcbiAgICAgICAgaXNSb3V0ZVJlcXVlc3QsXG4gICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICBkYXRhU3RyYXRlZ3lcbiAgICAgICk7XG4gICAgICByZXN1bHQgPSByZXN1bHRzW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHRocm93U3RhdGljSGFuZGxlckFib3J0ZWRFcnJvcihyZXF1ZXN0LCBpc1JvdXRlUmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0LnJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiByZXN1bHQucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXM6IFthY3Rpb25NYXRjaF0sXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhIH0sXG4gICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBvciB2YWx1ZVxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNraXBSZXZhbGlkYXRpb24pIHtcbiAgICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBza2lwTG9hZGVyRXJyb3JCdWJibGluZyA/IGFjdGlvbk1hdGNoIDogZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSA/IHJlc3VsdC5lcnJvci5zdGF0dXMgOiByZXN1bHQuc3RhdHVzQ29kZSAhPSBudWxsID8gcmVzdWx0LnN0YXR1c0NvZGUgOiA1MDAsXG4gICAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgICBhY3Rpb25IZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5yZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXRjaGVzLFxuICAgICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxvYWRlckhlYWRlcnM6IHt9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhY3Rpb25IZWFkZXJzOiByZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9LFxuICAgICAgICAgIG1hdGNoZXMsXG4gICAgICAgICAgbG9hZGVyRGF0YToge30sXG4gICAgICAgICAgZXJyb3JzOiBudWxsLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXNDb2RlIHx8IDIwMCxcbiAgICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbG9hZGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICByZWRpcmVjdDogcmVxdWVzdC5yZWRpcmVjdCxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgICB9KTtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgYm91bmRhcnlNYXRjaCA9IHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nID8gYWN0aW9uTWF0Y2ggOiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIGxldCBoYW5kbGVyQ29udGV4dDIgPSBhd2FpdCBsb2FkUm91dGVEYXRhKFxuICAgICAgICBsb2FkZXJSZXF1ZXN0LFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgZGF0YVN0cmF0ZWd5LFxuICAgICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZmlsdGVyTWF0Y2hlc1RvTG9hZCxcbiAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWQsIHJlc3VsdF1cbiAgICAgICk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5oYW5kbGVyQ29udGV4dDIsXG4gICAgICAgIHN0YXR1c0NvZGU6IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcikgPyByZXN1bHQuZXJyb3Iuc3RhdHVzIDogcmVzdWx0LnN0YXR1c0NvZGUgIT0gbnVsbCA/IHJlc3VsdC5zdGF0dXNDb2RlIDogNTAwLFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7XG4gICAgICAgICAgLi4ucmVzdWx0LmhlYWRlcnMgPyB7IFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzIH0gOiB7fVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgaGFuZGxlckNvbnRleHQgPSBhd2FpdCBsb2FkUm91dGVEYXRhKFxuICAgICAgbG9hZGVyUmVxdWVzdCxcbiAgICAgIG1hdGNoZXMsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIGRhdGFTdHJhdGVneSxcbiAgICAgIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLFxuICAgICAgbnVsbCxcbiAgICAgIGZpbHRlck1hdGNoZXNUb0xvYWRcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5oYW5kbGVyQ29udGV4dCxcbiAgICAgIGFjdGlvbkRhdGE6IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmRhdGFcbiAgICAgIH0sXG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIC4uLnJlc3VsdC5zdGF0dXNDb2RlID8geyBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZSB9IDoge30sXG4gICAgICBhY3Rpb25IZWFkZXJzOiByZXN1bHQuaGVhZGVycyA/IHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnMgfSA6IHt9XG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3ksIHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nLCByb3V0ZU1hdGNoLCBmaWx0ZXJNYXRjaGVzVG9Mb2FkLCBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gICAgbGV0IGlzUm91dGVSZXF1ZXN0ID0gcm91dGVNYXRjaCAhPSBudWxsO1xuICAgIGlmIChpc1JvdXRlUmVxdWVzdCAmJiAhcm91dGVNYXRjaD8ucm91dGUubG9hZGVyICYmICFyb3V0ZU1hdGNoPy5yb3V0ZS5sYXp5KSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2g/LnJvdXRlLmlkXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGRzTWF0Y2hlcztcbiAgICBpZiAocm91dGVNYXRjaCkge1xuICAgICAgZHNNYXRjaGVzID0gZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzKFxuICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgcm91dGVNYXRjaCxcbiAgICAgICAgW10sXG4gICAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWF4SWR4ID0gcGVuZGluZ0FjdGlvblJlc3VsdCAmJiBpc0Vycm9yUmVzdWx0KHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0pID8gKFxuICAgICAgICAvLyBVcCB0byBidXQgbm90IGluY2x1ZGluZyB0aGUgYm91bmRhcnlcbiAgICAgICAgbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IHBlbmRpbmdBY3Rpb25SZXN1bHRbMF0pIC0gMVxuICAgICAgKSA6IHZvaWQgMDtcbiAgICAgIGRzTWF0Y2hlcyA9IG1hdGNoZXMubWFwKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKG1heElkeCAhPSBudWxsICYmIGluZGV4ID4gbWF4SWR4KSB7XG4gICAgICAgICAgcmV0dXJuIGdldERhdGFTdHJhdGVneU1hdGNoKFxuICAgICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgW10sXG4gICAgICAgICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0RGF0YVN0cmF0ZWd5TWF0Y2goXG4gICAgICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIFtdLFxuICAgICAgICAgIHJlcXVlc3RDb250ZXh0LFxuICAgICAgICAgIChtYXRjaC5yb3V0ZS5sb2FkZXIgfHwgbWF0Y2gucm91dGUubGF6eSkgIT0gbnVsbCAmJiAoIWZpbHRlck1hdGNoZXNUb0xvYWQgfHwgZmlsdGVyTWF0Y2hlc1RvTG9hZChtYXRjaCkpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFkYXRhU3RyYXRlZ3kgJiYgIWRzTWF0Y2hlcy5zb21lKChtKSA9PiBtLnNob3VsZExvYWQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgZXJyb3JzOiBwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyB7XG4gICAgICAgICAgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmVycm9yXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3koXG4gICAgICByZXF1ZXN0LFxuICAgICAgZHNNYXRjaGVzLFxuICAgICAgaXNSb3V0ZVJlcXVlc3QsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIGRhdGFTdHJhdGVneVxuICAgICk7XG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93U3RhdGljSGFuZGxlckFib3J0ZWRFcnJvcihyZXF1ZXN0LCBpc1JvdXRlUmVxdWVzdCk7XG4gICAgfVxuICAgIGxldCBoYW5kbGVyQ29udGV4dCA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEoXG4gICAgICBtYXRjaGVzLFxuICAgICAgcmVzdWx0cyxcbiAgICAgIHBlbmRpbmdBY3Rpb25SZXN1bHQsXG4gICAgICB0cnVlLFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmdcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5oYW5kbGVyQ29udGV4dCxcbiAgICAgIG1hdGNoZXNcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGxEYXRhU3RyYXRlZ3kocmVxdWVzdCwgbWF0Y2hlcywgaXNSb3V0ZVJlcXVlc3QsIHJlcXVlc3RDb250ZXh0LCBkYXRhU3RyYXRlZ3kpIHtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxEYXRhU3RyYXRlZ3lJbXBsKFxuICAgICAgZGF0YVN0cmF0ZWd5IHx8IGRlZmF1bHREYXRhU3RyYXRlZ3ksXG4gICAgICByZXF1ZXN0LFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG51bGwsXG4gICAgICByZXF1ZXN0Q29udGV4dCxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGxldCBkYXRhUmVzdWx0cyA9IHt9O1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgbWF0Y2hlcy5tYXAoYXN5bmMgKG1hdGNoKSA9PiB7XG4gICAgICAgIGlmICghKG1hdGNoLnJvdXRlLmlkIGluIHJlc3VsdHMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSByZXN1bHRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgICAgaWYgKGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgIGxldCByZXNwb25zZSA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgdGhyb3cgbm9ybWFsaXplUmVsYXRpdmVSb3V0aW5nUmVkaXJlY3RSZXNwb25zZShcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIG1hdGNoLnJvdXRlLmlkLFxuICAgICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICAgIGJhc2VuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZXNwb25zZShyZXN1bHQucmVzdWx0KSAmJiBpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBkYXRhUmVzdWx0c1ttYXRjaC5yb3V0ZS5pZF0gPSBhd2FpdCBjb252ZXJ0RGF0YVN0cmF0ZWd5UmVzdWx0VG9EYXRhUmVzdWx0KHJlc3VsdCk7XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIGRhdGFSZXN1bHRzO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YVJvdXRlcyxcbiAgICBxdWVyeSxcbiAgICBxdWVyeVJvdXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yKHJvdXRlcywgaGFuZGxlckNvbnRleHQsIGVycm9yLCBib3VuZGFyeUlkKSB7XG4gIGxldCBlcnJvckJvdW5kYXJ5SWQgPSBib3VuZGFyeUlkIHx8IGhhbmRsZXJDb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHx8IHJvdXRlc1swXS5pZDtcbiAgcmV0dXJuIHtcbiAgICAuLi5oYW5kbGVyQ29udGV4dCxcbiAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShlcnJvcikgPyBlcnJvci5zdGF0dXMgOiA1MDAsXG4gICAgZXJyb3JzOiB7XG4gICAgICBbZXJyb3JCb3VuZGFyeUlkXTogZXJyb3JcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0aHJvd1N0YXRpY0hhbmRsZXJBYm9ydGVkRXJyb3IocmVxdWVzdCwgaXNSb3V0ZVJlcXVlc3QpIHtcbiAgaWYgKHJlcXVlc3Quc2lnbmFsLnJlYXNvbiAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgcmVxdWVzdC5zaWduYWwucmVhc29uO1xuICB9XG4gIGxldCBtZXRob2QgPSBpc1JvdXRlUmVxdWVzdCA/IFwicXVlcnlSb3V0ZVwiIDogXCJxdWVyeVwiO1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYCR7bWV0aG9kfSgpIGNhbGwgYWJvcnRlZCB3aXRob3V0IGFuIFxcYEFib3J0U2lnbmFsLnJlYXNvblxcYDogJHtyZXF1ZXN0Lm1ldGhvZH0gJHtyZXF1ZXN0LnVybH1gXG4gICk7XG59XG5mdW5jdGlvbiBpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgIT0gbnVsbCAmJiAoXCJmb3JtRGF0YVwiIGluIG9wdHMgJiYgb3B0cy5mb3JtRGF0YSAhPSBudWxsIHx8IFwiYm9keVwiIGluIG9wdHMgJiYgb3B0cy5ib2R5ICE9PSB2b2lkIDApO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVG8obG9jYXRpb24sIG1hdGNoZXMsIGJhc2VuYW1lLCB0bywgZnJvbVJvdXRlSWQsIHJlbGF0aXZlKSB7XG4gIGxldCBjb250ZXh0dWFsTWF0Y2hlcztcbiAgbGV0IGFjdGl2ZVJvdXRlTWF0Y2g7XG4gIGlmIChmcm9tUm91dGVJZCkge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29udGV4dHVhbE1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IGZyb21Sb3V0ZUlkKSB7XG4gICAgICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKFxuICAgIHRvID8gdG8gOiBcIi5cIixcbiAgICBnZXRSZXNvbHZlVG9NYXRjaGVzKGNvbnRleHR1YWxNYXRjaGVzKSxcbiAgICBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgcmVsYXRpdmUgPT09IFwicGF0aFwiXG4gICk7XG4gIGlmICh0byA9PSBudWxsKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgcGF0aC5oYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgfVxuICBpZiAoKHRvID09IG51bGwgfHwgdG8gPT09IFwiXCIgfHwgdG8gPT09IFwiLlwiKSAmJiBhY3RpdmVSb3V0ZU1hdGNoKSB7XG4gICAgbGV0IG5ha2VkSW5kZXggPSBoYXNOYWtlZEluZGV4UXVlcnkocGF0aC5zZWFyY2gpO1xuICAgIGlmIChhY3RpdmVSb3V0ZU1hdGNoLnJvdXRlLmluZGV4ICYmICFuYWtlZEluZGV4KSB7XG4gICAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoID8gcGF0aC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKSA6IFwiP2luZGV4XCI7XG4gICAgfSBlbHNlIGlmICghYWN0aXZlUm91dGVNYXRjaC5yb3V0ZS5pbmRleCAmJiBuYWtlZEluZGV4KSB7XG4gICAgICBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXRoLnNlYXJjaCk7XG4gICAgICBsZXQgaW5kZXhWYWx1ZXMgPSBwYXJhbXMuZ2V0QWxsKFwiaW5kZXhcIik7XG4gICAgICBwYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gICAgICBpbmRleFZhbHVlcy5maWx0ZXIoKHYpID0+IHYpLmZvckVhY2goKHYpID0+IHBhcmFtcy5hcHBlbmQoXCJpbmRleFwiLCB2KSk7XG4gICAgICBsZXQgcXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgIHBhdGguc2VhcmNoID0gcXMgPyBgPyR7cXN9YCA6IFwiXCI7XG4gICAgfVxuICB9XG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhpc0ZldGNoZXIsIHBhdGgsIG9wdHMpIHtcbiAgaWYgKCFvcHRzIHx8ICFpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKG9wdHMpKSB7XG4gICAgcmV0dXJuIHsgcGF0aCB9O1xuICB9XG4gIGlmIChvcHRzLmZvcm1NZXRob2QgJiYgIWlzVmFsaWRNZXRob2Qob3B0cy5mb3JtTWV0aG9kKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgZXJyb3I6IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7IG1ldGhvZDogb3B0cy5mb3JtTWV0aG9kIH0pXG4gICAgfTtcbiAgfVxuICBsZXQgZ2V0SW52YWxpZEJvZHlFcnJvciA9ICgpID0+ICh7XG4gICAgcGF0aCxcbiAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHsgdHlwZTogXCJpbnZhbGlkLWJvZHlcIiB9KVxuICB9KTtcbiAgbGV0IHJhd0Zvcm1NZXRob2QgPSBvcHRzLmZvcm1NZXRob2QgfHwgXCJnZXRcIjtcbiAgbGV0IGZvcm1NZXRob2QgPSByYXdGb3JtTWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gIGxldCBmb3JtQWN0aW9uID0gc3RyaXBIYXNoRnJvbVBhdGgocGF0aCk7XG4gIGlmIChvcHRzLmJvZHkgIT09IHZvaWQgMCkge1xuICAgIGlmIChvcHRzLmZvcm1FbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgICBsZXQgdGV4dCA9IHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBvcHRzLmJvZHkgOiBvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSB8fCBvcHRzLmJvZHkgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyAoXG4gICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI3BsYWluLXRleHQtZm9ybS1kYXRhXG4gICAgICAgIEFycmF5LmZyb20ob3B0cy5ib2R5LmVudHJpZXMoKSkucmVkdWNlKFxuICAgICAgICAgIChhY2MsIFtuYW1lLCB2YWx1ZV0pID0+IGAke2FjY30ke25hbWV9PSR7dmFsdWV9XG5gLFxuICAgICAgICAgIFwiXCJcbiAgICAgICAgKVxuICAgICAgKSA6IFN0cmluZyhvcHRzLmJvZHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgc3VibWlzc2lvbjoge1xuICAgICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICBmb3JtRW5jVHlwZTogb3B0cy5mb3JtRW5jVHlwZSxcbiAgICAgICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvcHRzLmZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgaWYgKCFpc011dGF0aW9uTWV0aG9kKGZvcm1NZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBsZXQganNvbiA9IHR5cGVvZiBvcHRzLmJvZHkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKG9wdHMuYm9keSkgOiBvcHRzLmJvZHk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgICBmb3JtTWV0aG9kLFxuICAgICAgICAgICAgZm9ybUFjdGlvbixcbiAgICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRzLmZvcm1FbmNUeXBlLFxuICAgICAgICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgICAgICAgIGpzb24sXG4gICAgICAgICAgICB0ZXh0OiB2b2lkIDBcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGludmFyaWFudChcbiAgICB0eXBlb2YgRm9ybURhdGEgPT09IFwiZnVuY3Rpb25cIixcbiAgICBcIkZvcm1EYXRhIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudFwiXG4gICk7XG4gIGxldCBzZWFyY2hQYXJhbXM7XG4gIGxldCBmb3JtRGF0YTtcbiAgaWYgKG9wdHMuZm9ybURhdGEpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhvcHRzLmZvcm1EYXRhKTtcbiAgICBmb3JtRGF0YSA9IG9wdHMuZm9ybURhdGE7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhvcHRzLmJvZHkpO1xuICAgIGZvcm1EYXRhID0gb3B0cy5ib2R5O1xuICB9IGVsc2UgaWYgKG9wdHMuYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIHNlYXJjaFBhcmFtcyA9IG9wdHMuYm9keTtcbiAgICBmb3JtRGF0YSA9IGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcyk7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5ID09IG51bGwpIHtcbiAgICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRzLmJvZHkpO1xuICAgICAgZm9ybURhdGEgPSBjb252ZXJ0U2VhcmNoUGFyYW1zVG9Gb3JtRGF0YShzZWFyY2hQYXJhbXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBnZXRJbnZhbGlkQm9keUVycm9yKCk7XG4gICAgfVxuICB9XG4gIGxldCBzdWJtaXNzaW9uID0ge1xuICAgIGZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbixcbiAgICBmb3JtRW5jVHlwZTogb3B0cyAmJiBvcHRzLmZvcm1FbmNUeXBlIHx8IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsXG4gICAgZm9ybURhdGEsXG4gICAganNvbjogdm9pZCAwLFxuICAgIHRleHQ6IHZvaWQgMFxuICB9O1xuICBpZiAoaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgcmV0dXJuIHsgcGF0aCwgc3VibWlzc2lvbiB9O1xuICB9XG4gIGxldCBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xuICBpZiAoaXNGZXRjaGVyICYmIHBhcnNlZFBhdGguc2VhcmNoICYmIGhhc05ha2VkSW5kZXhRdWVyeShwYXJzZWRQYXRoLnNlYXJjaCkpIHtcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgXCJcIik7XG4gIH1cbiAgcGFyc2VkUGF0aC5zZWFyY2ggPSBgPyR7c2VhcmNoUGFyYW1zfWA7XG4gIHJldHVybiB7IHBhdGg6IGNyZWF0ZVBhdGgocGFyc2VkUGF0aCksIHN1Ym1pc3Npb24gfTtcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXNUb0xvYWQocmVxdWVzdCwgc2NvcGVkQ29udGV4dCwgbWFwUm91dGVQcm9wZXJ0aWVzMiwgbWFuaWZlc3QsIGhpc3RvcnksIHN0YXRlLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBsb2NhdGlvbiwgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCwgaW5pdGlhbEh5ZHJhdGlvbiwgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCwgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLCBmZXRjaExvYWRNYXRjaGVzLCBmZXRjaFJlZGlyZWN0SWRzLCByb3V0ZXNUb1VzZSwgYmFzZW5hbWUsIGhhc1BhdGNoUm91dGVzT25OYXZpZ2F0aW9uLCBwZW5kaW5nQWN0aW9uUmVzdWx0KSB7XG4gIGxldCBhY3Rpb25SZXN1bHQgPSBwZW5kaW5nQWN0aW9uUmVzdWx0ID8gaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSA/IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZXJyb3IgOiBwZW5kaW5nQWN0aW9uUmVzdWx0WzFdLmRhdGEgOiB2b2lkIDA7XG4gIGxldCBjdXJyZW50VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RhdGUubG9jYXRpb24pO1xuICBsZXQgbmV4dFVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKGxvY2F0aW9uKTtcbiAgbGV0IG1heElkeDtcbiAgaWYgKGluaXRpYWxIeWRyYXRpb24gJiYgc3RhdGUuZXJyb3JzKSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBPYmplY3Qua2V5cyhzdGF0ZS5lcnJvcnMpWzBdO1xuICAgIG1heElkeCA9IG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBtLnJvdXRlLmlkID09PSBib3VuZGFyeUlkKTtcbiAgfSBlbHNlIGlmIChwZW5kaW5nQWN0aW9uUmVzdWx0ICYmIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IHBlbmRpbmdBY3Rpb25SZXN1bHRbMF07XG4gICAgbWF4SWR4ID0gbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IGJvdW5kYXJ5SWQpIC0gMTtcbiAgfVxuICBsZXQgYWN0aW9uU3RhdHVzID0gcGVuZGluZ0FjdGlvblJlc3VsdCA/IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uc3RhdHVzQ29kZSA6IHZvaWQgMDtcbiAgbGV0IHNob3VsZFNraXBSZXZhbGlkYXRpb24gPSBhY3Rpb25TdGF0dXMgJiYgYWN0aW9uU3RhdHVzID49IDQwMDtcbiAgbGV0IGJhc2VTaG91bGRSZXZhbGlkYXRlQXJncyA9IHtcbiAgICBjdXJyZW50VXJsLFxuICAgIGN1cnJlbnRQYXJhbXM6IHN0YXRlLm1hdGNoZXNbMF0/LnBhcmFtcyB8fCB7fSxcbiAgICBuZXh0VXJsLFxuICAgIG5leHRQYXJhbXM6IG1hdGNoZXNbMF0ucGFyYW1zLFxuICAgIC4uLnN1Ym1pc3Npb24sXG4gICAgYWN0aW9uUmVzdWx0LFxuICAgIGFjdGlvblN0YXR1c1xuICB9O1xuICBsZXQgZHNNYXRjaGVzID0gbWF0Y2hlcy5tYXAoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGxldCB7IHJvdXRlIH0gPSBtYXRjaDtcbiAgICBsZXQgZm9yY2VTaG91bGRMb2FkID0gbnVsbDtcbiAgICBpZiAobWF4SWR4ICE9IG51bGwgJiYgaW5kZXggPiBtYXhJZHgpIHtcbiAgICAgIGZvcmNlU2hvdWxkTG9hZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAocm91dGUubGF6eSkge1xuICAgICAgZm9yY2VTaG91bGRMb2FkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJvdXRlLmxvYWRlciA9PSBudWxsKSB7XG4gICAgICBmb3JjZVNob3VsZExvYWQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGluaXRpYWxIeWRyYXRpb24pIHtcbiAgICAgIGZvcmNlU2hvdWxkTG9hZCA9IHNob3VsZExvYWRSb3V0ZU9uSHlkcmF0aW9uKFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgc3RhdGUubG9hZGVyRGF0YSxcbiAgICAgICAgc3RhdGUuZXJyb3JzXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNOZXdMb2FkZXIoc3RhdGUubG9hZGVyRGF0YSwgc3RhdGUubWF0Y2hlc1tpbmRleF0sIG1hdGNoKSkge1xuICAgICAgZm9yY2VTaG91bGRMb2FkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGZvcmNlU2hvdWxkTG9hZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGdldERhdGFTdHJhdGVneU1hdGNoKFxuICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICBtYW5pZmVzdCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAsXG4gICAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICAgIGZvcmNlU2hvdWxkTG9hZFxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlID0gc2hvdWxkU2tpcFJldmFsaWRhdGlvbiA/IGZhbHNlIDogKFxuICAgICAgLy8gRm9yY2VkIHJldmFsaWRhdGlvbiBkdWUgdG8gc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0b3IsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZVxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCB8fCBjdXJyZW50VXJsLnBhdGhuYW1lICsgY3VycmVudFVybC5zZWFyY2ggPT09IG5leHRVcmwucGF0aG5hbWUgKyBuZXh0VXJsLnNlYXJjaCB8fCAvLyBTZWFyY2ggcGFyYW1zIGFmZmVjdCBhbGwgbG9hZGVyc1xuICAgICAgY3VycmVudFVybC5zZWFyY2ggIT09IG5leHRVcmwuc2VhcmNoIHx8IGlzTmV3Um91dGVJbnN0YW5jZShzdGF0ZS5tYXRjaGVzW2luZGV4XSwgbWF0Y2gpXG4gICAgKTtcbiAgICBsZXQgc2hvdWxkUmV2YWxpZGF0ZUFyZ3MgPSB7XG4gICAgICAuLi5iYXNlU2hvdWxkUmV2YWxpZGF0ZUFyZ3MsXG4gICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZVxuICAgIH07XG4gICAgbGV0IHNob3VsZExvYWQgPSBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKG1hdGNoLCBzaG91bGRSZXZhbGlkYXRlQXJncyk7XG4gICAgcmV0dXJuIGdldERhdGFTdHJhdGVneU1hdGNoKFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcmVxdWVzdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCxcbiAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICBzaG91bGRMb2FkLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZUFyZ3NcbiAgICApO1xuICB9KTtcbiAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXJzID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoZiwga2V5KSA9PiB7XG4gICAgaWYgKGluaXRpYWxIeWRyYXRpb24gfHwgIW1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS5pZCA9PT0gZi5yb3V0ZUlkKSB8fCBmZXRjaGVyc1F1ZXVlZEZvckRlbGV0aW9uLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgbGV0IGlzTWlkSW5pdGlhbExvYWQgPSBmZXRjaGVyICYmIGZldGNoZXIuc3RhdGUgIT09IFwiaWRsZVwiICYmIGZldGNoZXIuZGF0YSA9PT0gdm9pZCAwO1xuICAgIGxldCBmZXRjaGVyTWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBmLnBhdGgsIGJhc2VuYW1lKTtcbiAgICBpZiAoIWZldGNoZXJNYXRjaGVzKSB7XG4gICAgICBpZiAoaGFzUGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24gJiYgaXNNaWRJbml0aWFsTG9hZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogbnVsbCxcbiAgICAgICAgbWF0Y2g6IG51bGwsXG4gICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hSZWRpcmVjdElkcy5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZmV0Y2hlck1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2goZmV0Y2hlck1hdGNoZXMsIGYucGF0aCk7XG4gICAgbGV0IGZldGNoQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgZmV0Y2hSZXF1ZXN0ID0gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoXG4gICAgICBoaXN0b3J5LFxuICAgICAgZi5wYXRoLFxuICAgICAgZmV0Y2hDb250cm9sbGVyLnNpZ25hbFxuICAgICk7XG4gICAgbGV0IGZldGNoZXJEc01hdGNoZXMgPSBudWxsO1xuICAgIGlmIChjYW5jZWxsZWRGZXRjaGVyTG9hZHMuaGFzKGtleSkpIHtcbiAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5kZWxldGUoa2V5KTtcbiAgICAgIGZldGNoZXJEc01hdGNoZXMgPSBnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMoXG4gICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICBmZXRjaFJlcXVlc3QsXG4gICAgICAgIGZldGNoZXJNYXRjaGVzLFxuICAgICAgICBmZXRjaGVyTWF0Y2gsXG4gICAgICAgIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAsXG4gICAgICAgIHNjb3BlZENvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc01pZEluaXRpYWxMb2FkKSB7XG4gICAgICBpZiAoaXNSZXZhbGlkYXRpb25SZXF1aXJlZCkge1xuICAgICAgICBmZXRjaGVyRHNNYXRjaGVzID0gZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzKFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgZmV0Y2hSZXF1ZXN0LFxuICAgICAgICAgIGZldGNoZXJNYXRjaGVzLFxuICAgICAgICAgIGZldGNoZXJNYXRjaCxcbiAgICAgICAgICBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLFxuICAgICAgICAgIHNjb3BlZENvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHNob3VsZFJldmFsaWRhdGVBcmdzID0ge1xuICAgICAgICAuLi5iYXNlU2hvdWxkUmV2YWxpZGF0ZUFyZ3MsXG4gICAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiBzaG91bGRTa2lwUmV2YWxpZGF0aW9uID8gZmFsc2UgOiBpc1JldmFsaWRhdGlvblJlcXVpcmVkXG4gICAgICB9O1xuICAgICAgaWYgKHNob3VsZFJldmFsaWRhdGVMb2FkZXIoZmV0Y2hlck1hdGNoLCBzaG91bGRSZXZhbGlkYXRlQXJncykpIHtcbiAgICAgICAgZmV0Y2hlckRzTWF0Y2hlcyA9IGdldFRhcmdldGVkRGF0YVN0cmF0ZWd5TWF0Y2hlcyhcbiAgICAgICAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgICAgICAgIG1hbmlmZXN0LFxuICAgICAgICAgIGZldGNoUmVxdWVzdCxcbiAgICAgICAgICBmZXRjaGVyTWF0Y2hlcyxcbiAgICAgICAgICBmZXRjaGVyTWF0Y2gsXG4gICAgICAgICAgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCxcbiAgICAgICAgICBzY29wZWRDb250ZXh0LFxuICAgICAgICAgIHNob3VsZFJldmFsaWRhdGVBcmdzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmZXRjaGVyRHNNYXRjaGVzKSB7XG4gICAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICByb3V0ZUlkOiBmLnJvdXRlSWQsXG4gICAgICAgIHBhdGg6IGYucGF0aCxcbiAgICAgICAgbWF0Y2hlczogZmV0Y2hlckRzTWF0Y2hlcyxcbiAgICAgICAgbWF0Y2g6IGZldGNoZXJNYXRjaCxcbiAgICAgICAgcmVxdWVzdDogZmV0Y2hSZXF1ZXN0LFxuICAgICAgICBjb250cm9sbGVyOiBmZXRjaENvbnRyb2xsZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7IGRzTWF0Y2hlcywgcmV2YWxpZGF0aW5nRmV0Y2hlcnMgfTtcbn1cbmZ1bmN0aW9uIHNob3VsZExvYWRSb3V0ZU9uSHlkcmF0aW9uKHJvdXRlLCBsb2FkZXJEYXRhLCBlcnJvcnMpIHtcbiAgaWYgKHJvdXRlLmxhenkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIXJvdXRlLmxvYWRlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgaGFzRGF0YSA9IGxvYWRlckRhdGEgIT0gbnVsbCAmJiByb3V0ZS5pZCBpbiBsb2FkZXJEYXRhO1xuICBsZXQgaGFzRXJyb3IgPSBlcnJvcnMgIT0gbnVsbCAmJiBlcnJvcnNbcm91dGUuaWRdICE9PSB2b2lkIDA7XG4gIGlmICghaGFzRGF0YSAmJiBoYXNFcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHJvdXRlLmxvYWRlciA9PT0gXCJmdW5jdGlvblwiICYmIHJvdXRlLmxvYWRlci5oeWRyYXRlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuICFoYXNEYXRhICYmICFoYXNFcnJvcjtcbn1cbmZ1bmN0aW9uIGlzTmV3TG9hZGVyKGN1cnJlbnRMb2FkZXJEYXRhLCBjdXJyZW50TWF0Y2gsIG1hdGNoKSB7XG4gIGxldCBpc05ldyA9IChcbiAgICAvLyBbYV0gLT4gW2EsIGJdXG4gICAgIWN1cnJlbnRNYXRjaCB8fCAvLyBbYSwgYl0gLT4gW2EsIGNdXG4gICAgbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaC5yb3V0ZS5pZFxuICApO1xuICBsZXQgaXNNaXNzaW5nRGF0YSA9ICFjdXJyZW50TG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShtYXRjaC5yb3V0ZS5pZCk7XG4gIHJldHVybiBpc05ldyB8fCBpc01pc3NpbmdEYXRhO1xufVxuZnVuY3Rpb24gaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRNYXRjaCwgbWF0Y2gpIHtcbiAgbGV0IGN1cnJlbnRQYXRoID0gY3VycmVudE1hdGNoLnJvdXRlLnBhdGg7XG4gIHJldHVybiAoXG4gICAgLy8gcGFyYW0gY2hhbmdlIGZvciB0aGlzIG1hdGNoLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICBjdXJyZW50TWF0Y2gucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8IC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAvLyBlLmcuIC9maWxlcy9pbWFnZXMvYXZhdGFyLmpwZyAtPiBmaWxlcy9maW5hbmNlcy54bHNcbiAgICBjdXJyZW50UGF0aCAhPSBudWxsICYmIGN1cnJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSAmJiBjdXJyZW50TWF0Y2gucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxuICApO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV2YWxpZGF0ZUxvYWRlcihsb2FkZXJNYXRjaCwgYXJnKSB7XG4gIGlmIChsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IHJvdXRlQ2hvaWNlID0gbG9hZGVyTWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZShhcmcpO1xuICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gcm91dGVDaG9pY2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmcuZGVmYXVsdFNob3VsZFJldmFsaWRhdGU7XG59XG5mdW5jdGlvbiBwYXRjaFJvdXRlc0ltcGwocm91dGVJZCwgY2hpbGRyZW4sIHJvdXRlc1RvVXNlLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzMikge1xuICBsZXQgY2hpbGRyZW5Ub1BhdGNoO1xuICBpZiAocm91dGVJZCkge1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0W3JvdXRlSWRdO1xuICAgIGludmFyaWFudChcbiAgICAgIHJvdXRlLFxuICAgICAgYE5vIHJvdXRlIGZvdW5kIHRvIHBhdGNoIGNoaWxkcmVuIGludG86IHJvdXRlSWQgPSAke3JvdXRlSWR9YFxuICAgICk7XG4gICAgaWYgKCFyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBbXTtcbiAgICB9XG4gICAgY2hpbGRyZW5Ub1BhdGNoID0gcm91dGUuY2hpbGRyZW47XG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW5Ub1BhdGNoID0gcm91dGVzVG9Vc2U7XG4gIH1cbiAgbGV0IHVuaXF1ZUNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKFxuICAgIChuZXdSb3V0ZSkgPT4gIWNoaWxkcmVuVG9QYXRjaC5zb21lKFxuICAgICAgKGV4aXN0aW5nUm91dGUpID0+IGlzU2FtZVJvdXRlKG5ld1JvdXRlLCBleGlzdGluZ1JvdXRlKVxuICAgIClcbiAgKTtcbiAgbGV0IG5ld1JvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMoXG4gICAgdW5pcXVlQ2hpbGRyZW4sXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICBbcm91dGVJZCB8fCBcIl9cIiwgXCJwYXRjaFwiLCBTdHJpbmcoY2hpbGRyZW5Ub1BhdGNoPy5sZW5ndGggfHwgXCIwXCIpXSxcbiAgICBtYW5pZmVzdFxuICApO1xuICBjaGlsZHJlblRvUGF0Y2gucHVzaCguLi5uZXdSb3V0ZXMpO1xufVxuZnVuY3Rpb24gaXNTYW1lUm91dGUobmV3Um91dGUsIGV4aXN0aW5nUm91dGUpIHtcbiAgaWYgKFwiaWRcIiBpbiBuZXdSb3V0ZSAmJiBcImlkXCIgaW4gZXhpc3RpbmdSb3V0ZSAmJiBuZXdSb3V0ZS5pZCA9PT0gZXhpc3RpbmdSb3V0ZS5pZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghKG5ld1JvdXRlLmluZGV4ID09PSBleGlzdGluZ1JvdXRlLmluZGV4ICYmIG5ld1JvdXRlLnBhdGggPT09IGV4aXN0aW5nUm91dGUucGF0aCAmJiBuZXdSb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSBleGlzdGluZ1JvdXRlLmNhc2VTZW5zaXRpdmUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoIW5ld1JvdXRlLmNoaWxkcmVuIHx8IG5ld1JvdXRlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgJiYgKCFleGlzdGluZ1JvdXRlLmNoaWxkcmVuIHx8IGV4aXN0aW5nUm91dGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBuZXdSb3V0ZS5jaGlsZHJlbi5ldmVyeShcbiAgICAoYUNoaWxkLCBpKSA9PiBleGlzdGluZ1JvdXRlLmNoaWxkcmVuPy5zb21lKChiQ2hpbGQpID0+IGlzU2FtZVJvdXRlKGFDaGlsZCwgYkNoaWxkKSlcbiAgKTtcbn1cbnZhciBsYXp5Um91dGVQcm9wZXJ0eUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgbG9hZExhenlSb3V0ZVByb3BlcnR5ID0gKHtcbiAga2V5LFxuICByb3V0ZSxcbiAgbWFuaWZlc3QsXG4gIG1hcFJvdXRlUHJvcGVydGllczogbWFwUm91dGVQcm9wZXJ0aWVzMlxufSkgPT4ge1xuICBsZXQgcm91dGVUb1VwZGF0ZSA9IG1hbmlmZXN0W3JvdXRlLmlkXTtcbiAgaW52YXJpYW50KHJvdXRlVG9VcGRhdGUsIFwiTm8gcm91dGUgZm91bmQgaW4gbWFuaWZlc3RcIik7XG4gIGlmICghcm91dGVUb1VwZGF0ZS5sYXp5IHx8IHR5cGVvZiByb3V0ZVRvVXBkYXRlLmxhenkgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGxhenlGbiA9IHJvdXRlVG9VcGRhdGUubGF6eVtrZXldO1xuICBpZiAoIWxhenlGbikge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgY2FjaGUgPSBsYXp5Um91dGVQcm9wZXJ0eUNhY2hlLmdldChyb3V0ZVRvVXBkYXRlKTtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0ge307XG4gICAgbGF6eVJvdXRlUHJvcGVydHlDYWNoZS5zZXQocm91dGVUb1VwZGF0ZSwgY2FjaGUpO1xuICB9XG4gIGxldCBjYWNoZWRQcm9taXNlID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgfVxuICBsZXQgcHJvcGVydHlQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICBsZXQgaXNVbnN1cHBvcnRlZCA9IGlzVW5zdXBwb3J0ZWRMYXp5Um91dGVPYmplY3RLZXkoa2V5KTtcbiAgICBsZXQgc3RhdGljUm91dGVWYWx1ZSA9IHJvdXRlVG9VcGRhdGVba2V5XTtcbiAgICBsZXQgaXNTdGF0aWNhbGx5RGVmaW5lZCA9IHN0YXRpY1JvdXRlVmFsdWUgIT09IHZvaWQgMCAmJiBrZXkgIT09IFwiaGFzRXJyb3JCb3VuZGFyeVwiO1xuICAgIGlmIChpc1Vuc3VwcG9ydGVkKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhaXNVbnN1cHBvcnRlZCxcbiAgICAgICAgXCJSb3V0ZSBwcm9wZXJ0eSBcIiArIGtleSArIFwiIGlzIG5vdCBhIHN1cHBvcnRlZCBsYXp5IHJvdXRlIHByb3BlcnR5LiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgKTtcbiAgICAgIGNhY2hlW2tleV0gPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RhdGljYWxseURlZmluZWQpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBgUm91dGUgXCIke3JvdXRlVG9VcGRhdGUuaWR9XCIgaGFzIGEgc3RhdGljIHByb3BlcnR5IFwiJHtrZXl9XCIgZGVmaW5lZC4gVGhlIGxhenkgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLmBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB2YWx1ZSA9IGF3YWl0IGxhenlGbigpO1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCB7IFtrZXldOiB2YWx1ZSB9KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMyKHJvdXRlVG9VcGRhdGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiByb3V0ZVRvVXBkYXRlLmxhenkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJvdXRlVG9VcGRhdGUubGF6eVtrZXldID0gdm9pZCAwO1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMocm91dGVUb1VwZGF0ZS5sYXp5KS5ldmVyeSgodmFsdWUpID0+IHZhbHVlID09PSB2b2lkIDApKSB7XG4gICAgICAgIHJvdXRlVG9VcGRhdGUubGF6eSA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0pKCk7XG4gIGNhY2hlW2tleV0gPSBwcm9wZXJ0eVByb21pc2U7XG4gIHJldHVybiBwcm9wZXJ0eVByb21pc2U7XG59O1xudmFyIGxhenlSb3V0ZUZ1bmN0aW9uQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGxvYWRMYXp5Um91dGUocm91dGUsIHR5cGUsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMyLCBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwKSB7XG4gIGxldCByb3V0ZVRvVXBkYXRlID0gbWFuaWZlc3Rbcm91dGUuaWRdO1xuICBpbnZhcmlhbnQocm91dGVUb1VwZGF0ZSwgXCJObyByb3V0ZSBmb3VuZCBpbiBtYW5pZmVzdFwiKTtcbiAgaWYgKCFyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhenlSb3V0ZVByb21pc2U6IHZvaWQgMCxcbiAgICAgIGxhenlIYW5kbGVyUHJvbWlzZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHJvdXRlLmxhenkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGxldCBjYWNoZWRQcm9taXNlID0gbGF6eVJvdXRlRnVuY3Rpb25DYWNoZS5nZXQocm91dGVUb1VwZGF0ZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhenlSb3V0ZVByb21pc2U6IGNhY2hlZFByb21pc2UsXG4gICAgICAgIGxhenlIYW5kbGVyUHJvbWlzZTogY2FjaGVkUHJvbWlzZVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGxhenlSb3V0ZVByb21pc2UyID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgdHlwZW9mIHJvdXRlLmxhenkgPT09IFwiZnVuY3Rpb25cIixcbiAgICAgICAgXCJObyBsYXp5IHJvdXRlIGZ1bmN0aW9uIGZvdW5kXCJcbiAgICAgICk7XG4gICAgICBsZXQgbGF6eVJvdXRlID0gYXdhaXQgcm91dGUubGF6eSgpO1xuICAgICAgbGV0IHJvdXRlVXBkYXRlcyA9IHt9O1xuICAgICAgZm9yIChsZXQgbGF6eVJvdXRlUHJvcGVydHkgaW4gbGF6eVJvdXRlKSB7XG4gICAgICAgIGxldCBsYXp5VmFsdWUgPSBsYXp5Um91dGVbbGF6eVJvdXRlUHJvcGVydHldO1xuICAgICAgICBpZiAobGF6eVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNVbnN1cHBvcnRlZCA9IGlzVW5zdXBwb3J0ZWRMYXp5Um91dGVGdW5jdGlvbktleShsYXp5Um91dGVQcm9wZXJ0eSk7XG4gICAgICAgIGxldCBzdGF0aWNSb3V0ZVZhbHVlID0gcm91dGVUb1VwZGF0ZVtsYXp5Um91dGVQcm9wZXJ0eV07XG4gICAgICAgIGxldCBpc1N0YXRpY2FsbHlEZWZpbmVkID0gc3RhdGljUm91dGVWYWx1ZSAhPT0gdm9pZCAwICYmIC8vIFRoaXMgcHJvcGVydHkgaXNuJ3Qgc3RhdGljIHNpbmNlIGl0IHNob3VsZCBhbHdheXMgYmUgdXBkYXRlZCBiYXNlZFxuICAgICAgICAvLyBvbiB0aGUgcm91dGUgdXBkYXRlc1xuICAgICAgICBsYXp5Um91dGVQcm9wZXJ0eSAhPT0gXCJoYXNFcnJvckJvdW5kYXJ5XCI7XG4gICAgICAgIGlmIChpc1Vuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICFpc1Vuc3VwcG9ydGVkLFxuICAgICAgICAgICAgXCJSb3V0ZSBwcm9wZXJ0eSBcIiArIGxhenlSb3V0ZVByb3BlcnR5ICsgXCIgaXMgbm90IGEgc3VwcG9ydGVkIHByb3BlcnR5IHRvIGJlIHJldHVybmVkIGZyb20gYSBsYXp5IHJvdXRlIGZ1bmN0aW9uLiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdGF0aWNhbGx5RGVmaW5lZCkge1xuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAhaXNTdGF0aWNhbGx5RGVmaW5lZCxcbiAgICAgICAgICAgIGBSb3V0ZSBcIiR7cm91dGVUb1VwZGF0ZS5pZH1cIiBoYXMgYSBzdGF0aWMgcHJvcGVydHkgXCIke2xhenlSb3V0ZVByb3BlcnR5fVwiIGRlZmluZWQgYnV0IGl0cyBsYXp5IGZ1bmN0aW9uIGlzIGFsc28gcmV0dXJuaW5nIGEgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHkuIFRoZSBsYXp5IHJvdXRlIHByb3BlcnR5IFwiJHtsYXp5Um91dGVQcm9wZXJ0eX1cIiB3aWxsIGJlIGlnbm9yZWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVVcGRhdGVzW2xhenlSb3V0ZVByb3BlcnR5XSA9IGxhenlWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCByb3V0ZVVwZGF0ZXMpO1xuICAgICAgT2JqZWN0LmFzc2lnbihyb3V0ZVRvVXBkYXRlLCB7XG4gICAgICAgIC8vIFRvIGtlZXAgdGhpbmdzIGZyYW1ld29yayBhZ25vc3RpYywgd2UgdXNlIHRoZSBwcm92aWRlZCBgbWFwUm91dGVQcm9wZXJ0aWVzYFxuICAgICAgICAvLyBmdW5jdGlvbiB0byBzZXQgdGhlIGZyYW1ld29yay1hd2FyZSBwcm9wZXJ0aWVzIChgZWxlbWVudGAvYGhhc0Vycm9yQm91bmRhcnlgKVxuICAgICAgICAvLyBzaW5jZSB0aGUgbG9naWMgd2lsbCBkaWZmZXIgYmV0d2VlbiBmcmFtZXdvcmtzLlxuICAgICAgICAuLi5tYXBSb3V0ZVByb3BlcnRpZXMyKHJvdXRlVG9VcGRhdGUpLFxuICAgICAgICBsYXp5OiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gICAgbGF6eVJvdXRlRnVuY3Rpb25DYWNoZS5zZXQocm91dGVUb1VwZGF0ZSwgbGF6eVJvdXRlUHJvbWlzZTIpO1xuICAgIGxhenlSb3V0ZVByb21pc2UyLmNhdGNoKCgpID0+IHtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGF6eVJvdXRlUHJvbWlzZTogbGF6eVJvdXRlUHJvbWlzZTIsXG4gICAgICBsYXp5SGFuZGxlclByb21pc2U6IGxhenlSb3V0ZVByb21pc2UyXG4gICAgfTtcbiAgfVxuICBsZXQgbGF6eUtleXMgPSBPYmplY3Qua2V5cyhyb3V0ZS5sYXp5KTtcbiAgbGV0IGxhenlQcm9wZXJ0eVByb21pc2VzID0gW107XG4gIGxldCBsYXp5SGFuZGxlclByb21pc2UgPSB2b2lkIDA7XG4gIGZvciAobGV0IGtleSBvZiBsYXp5S2V5cykge1xuICAgIGlmIChsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwICYmIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXAuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBwcm9taXNlID0gbG9hZExhenlSb3V0ZVByb3BlcnR5KHtcbiAgICAgIGtleSxcbiAgICAgIHJvdXRlLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXM6IG1hcFJvdXRlUHJvcGVydGllczJcbiAgICB9KTtcbiAgICBpZiAocHJvbWlzZSkge1xuICAgICAgbGF6eVByb3BlcnR5UHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgIGlmIChrZXkgPT09IHR5cGUpIHtcbiAgICAgICAgbGF6eUhhbmRsZXJQcm9taXNlID0gcHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGxhenlSb3V0ZVByb21pc2UgPSBsYXp5UHJvcGVydHlQcm9taXNlcy5sZW5ndGggPiAwID8gUHJvbWlzZS5hbGwobGF6eVByb3BlcnR5UHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICB9KSA6IHZvaWQgMDtcbiAgbGF6eVJvdXRlUHJvbWlzZT8uY2F0Y2goKCkgPT4ge1xuICB9KTtcbiAgbGF6eUhhbmRsZXJQcm9taXNlPy5jYXRjaCgoKSA9PiB7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGxhenlSb3V0ZVByb21pc2UsXG4gICAgbGF6eUhhbmRsZXJQcm9taXNlXG4gIH07XG59XG5mdW5jdGlvbiBpc05vbk51bGxhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gbG9hZExhenlNaWRkbGV3YXJlRm9yTWF0Y2hlcyhtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzMikge1xuICBsZXQgcHJvbWlzZXMgPSBtYXRjaGVzLm1hcCgoeyByb3V0ZSB9KSA9PiB7XG4gICAgaWYgKHR5cGVvZiByb3V0ZS5sYXp5ICE9PSBcIm9iamVjdFwiIHx8ICFyb3V0ZS5sYXp5LnVuc3RhYmxlX21pZGRsZXdhcmUpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsb2FkTGF6eVJvdXRlUHJvcGVydHkoe1xuICAgICAga2V5OiBcInVuc3RhYmxlX21pZGRsZXdhcmVcIixcbiAgICAgIHJvdXRlLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBtYXBSb3V0ZVByb3BlcnRpZXM6IG1hcFJvdXRlUHJvcGVydGllczJcbiAgICB9KTtcbiAgfSkuZmlsdGVyKGlzTm9uTnVsbGFibGUpO1xuICByZXR1cm4gcHJvbWlzZXMubGVuZ3RoID4gMCA/IFByb21pc2UuYWxsKHByb21pc2VzKSA6IHZvaWQgMDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlZmF1bHREYXRhU3RyYXRlZ3koYXJncykge1xuICBsZXQgbWF0Y2hlc1RvTG9hZCA9IGFyZ3MubWF0Y2hlcy5maWx0ZXIoKG0pID0+IG0uc2hvdWxkTG9hZCk7XG4gIGxldCBrZXllZFJlc3VsdHMgPSB7fTtcbiAgbGV0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChtYXRjaGVzVG9Mb2FkLm1hcCgobSkgPT4gbS5yZXNvbHZlKCkpKTtcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGkpID0+IHtcbiAgICBrZXllZFJlc3VsdHNbbWF0Y2hlc1RvTG9hZFtpXS5yb3V0ZS5pZF0gPSByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4ga2V5ZWRSZXN1bHRzO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVmYXVsdERhdGFTdHJhdGVneVdpdGhNaWRkbGV3YXJlKGFyZ3MpIHtcbiAgaWYgKCFhcmdzLm1hdGNoZXMuc29tZSgobSkgPT4gbS5yb3V0ZS51bnN0YWJsZV9taWRkbGV3YXJlKSkge1xuICAgIHJldHVybiBkZWZhdWx0RGF0YVN0cmF0ZWd5KGFyZ3MpO1xuICB9XG4gIHJldHVybiBydW5NaWRkbGV3YXJlUGlwZWxpbmUoXG4gICAgYXJncyxcbiAgICBmYWxzZSxcbiAgICAoKSA9PiBkZWZhdWx0RGF0YVN0cmF0ZWd5KGFyZ3MpLFxuICAgIChlcnJvciwgcm91dGVJZCkgPT4gKHsgW3JvdXRlSWRdOiB7IHR5cGU6IFwiZXJyb3JcIiwgcmVzdWx0OiBlcnJvciB9IH0pXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBydW5NaWRkbGV3YXJlUGlwZWxpbmUoYXJncywgcHJvcGFnYXRlUmVzdWx0LCBoYW5kbGVyLCBlcnJvckhhbmRsZXIpIHtcbiAgbGV0IHsgbWF0Y2hlcywgcmVxdWVzdCwgcGFyYW1zLCBjb250ZXh0IH0gPSBhcmdzO1xuICBsZXQgbWlkZGxld2FyZVN0YXRlID0ge1xuICAgIGhhbmRsZXJSZXN1bHQ6IHZvaWQgMFxuICB9O1xuICB0cnkge1xuICAgIGxldCB0dXBsZXMgPSBtYXRjaGVzLmZsYXRNYXAoXG4gICAgICAobSkgPT4gbS5yb3V0ZS51bnN0YWJsZV9taWRkbGV3YXJlID8gbS5yb3V0ZS51bnN0YWJsZV9taWRkbGV3YXJlLm1hcCgoZm4pID0+IFttLnJvdXRlLmlkLCBmbl0pIDogW11cbiAgICApO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWxsUm91dGVNaWRkbGV3YXJlKFxuICAgICAgeyByZXF1ZXN0LCBwYXJhbXMsIGNvbnRleHQgfSxcbiAgICAgIHR1cGxlcyxcbiAgICAgIHByb3BhZ2F0ZVJlc3VsdCxcbiAgICAgIG1pZGRsZXdhcmVTdGF0ZSxcbiAgICAgIGhhbmRsZXJcbiAgICApO1xuICAgIHJldHVybiBwcm9wYWdhdGVSZXN1bHQgPyByZXN1bHQgOiBtaWRkbGV3YXJlU3RhdGUuaGFuZGxlclJlc3VsdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICghbWlkZGxld2FyZVN0YXRlLm1pZGRsZXdhcmVFcnJvcikge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGVycm9ySGFuZGxlcihcbiAgICAgIG1pZGRsZXdhcmVTdGF0ZS5taWRkbGV3YXJlRXJyb3IuZXJyb3IsXG4gICAgICBtaWRkbGV3YXJlU3RhdGUubWlkZGxld2FyZUVycm9yLnJvdXRlSWRcbiAgICApO1xuICAgIGlmIChwcm9wYWdhdGVSZXN1bHQgfHwgIW1pZGRsZXdhcmVTdGF0ZS5oYW5kbGVyUmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihtaWRkbGV3YXJlU3RhdGUuaGFuZGxlclJlc3VsdCwgcmVzdWx0KTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gY2FsbFJvdXRlTWlkZGxld2FyZShhcmdzLCBtaWRkbGV3YXJlcywgcHJvcGFnYXRlUmVzdWx0LCBtaWRkbGV3YXJlU3RhdGUsIGhhbmRsZXIsIGlkeCA9IDApIHtcbiAgbGV0IHsgcmVxdWVzdCB9ID0gYXJncztcbiAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICBpZiAocmVxdWVzdC5zaWduYWwucmVhc29uKSB7XG4gICAgICB0aHJvdyByZXF1ZXN0LnNpZ25hbC5yZWFzb247XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZXF1ZXN0IGFib3J0ZWQgd2l0aG91dCBhbiBcXGBBYm9ydFNpZ25hbC5yZWFzb25cXGA6ICR7cmVxdWVzdC5tZXRob2R9ICR7cmVxdWVzdC51cmx9YFxuICAgICk7XG4gIH1cbiAgbGV0IHR1cGxlID0gbWlkZGxld2FyZXNbaWR4XTtcbiAgaWYgKCF0dXBsZSkge1xuICAgIG1pZGRsZXdhcmVTdGF0ZS5oYW5kbGVyUmVzdWx0ID0gYXdhaXQgaGFuZGxlcigpO1xuICAgIHJldHVybiBtaWRkbGV3YXJlU3RhdGUuaGFuZGxlclJlc3VsdDtcbiAgfVxuICBsZXQgW3JvdXRlSWQsIG1pZGRsZXdhcmVdID0gdHVwbGU7XG4gIGxldCBuZXh0Q2FsbGVkID0gZmFsc2U7XG4gIGxldCBuZXh0UmVzdWx0ID0gdm9pZCAwO1xuICBsZXQgbmV4dCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAobmV4dENhbGxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG1heSBvbmx5IGNhbGwgYG5leHQoKWAgb25jZSBwZXIgbWlkZGxld2FyZVwiKTtcbiAgICB9XG4gICAgbmV4dENhbGxlZCA9IHRydWU7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNhbGxSb3V0ZU1pZGRsZXdhcmUoXG4gICAgICBhcmdzLFxuICAgICAgbWlkZGxld2FyZXMsXG4gICAgICBwcm9wYWdhdGVSZXN1bHQsXG4gICAgICBtaWRkbGV3YXJlU3RhdGUsXG4gICAgICBoYW5kbGVyLFxuICAgICAgaWR4ICsgMVxuICAgICk7XG4gICAgaWYgKHByb3BhZ2F0ZVJlc3VsdCkge1xuICAgICAgbmV4dFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIHJldHVybiBuZXh0UmVzdWx0O1xuICAgIH1cbiAgfTtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgbWlkZGxld2FyZShcbiAgICAgIHtcbiAgICAgICAgcmVxdWVzdDogYXJncy5yZXF1ZXN0LFxuICAgICAgICBwYXJhbXM6IGFyZ3MucGFyYW1zLFxuICAgICAgICBjb250ZXh0OiBhcmdzLmNvbnRleHRcbiAgICAgIH0sXG4gICAgICBuZXh0XG4gICAgKTtcbiAgICBpZiAobmV4dENhbGxlZCkge1xuICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBuZXh0UmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCFtaWRkbGV3YXJlU3RhdGUubWlkZGxld2FyZUVycm9yKSB7XG4gICAgICBtaWRkbGV3YXJlU3RhdGUubWlkZGxld2FyZUVycm9yID0geyByb3V0ZUlkLCBlcnJvciB9O1xuICAgIH0gZWxzZSBpZiAobWlkZGxld2FyZVN0YXRlLm1pZGRsZXdhcmVFcnJvci5lcnJvciAhPT0gZXJyb3IpIHtcbiAgICAgIG1pZGRsZXdhcmVTdGF0ZS5taWRkbGV3YXJlRXJyb3IgPSB7IHJvdXRlSWQsIGVycm9yIH07XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBnZXREYXRhU3RyYXRlZ3lNYXRjaExhenlQcm9taXNlcyhtYXBSb3V0ZVByb3BlcnRpZXMyLCBtYW5pZmVzdCwgcmVxdWVzdCwgbWF0Y2gsIGxhenlSb3V0ZVByb3BlcnRpZXNUb1NraXApIHtcbiAgbGV0IGxhenlNaWRkbGV3YXJlUHJvbWlzZSA9IGxvYWRMYXp5Um91dGVQcm9wZXJ0eSh7XG4gICAga2V5OiBcInVuc3RhYmxlX21pZGRsZXdhcmVcIixcbiAgICByb3V0ZTogbWF0Y2gucm91dGUsXG4gICAgbWFuaWZlc3QsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzOiBtYXBSb3V0ZVByb3BlcnRpZXMyXG4gIH0pO1xuICBsZXQgbGF6eVJvdXRlUHJvbWlzZXMgPSBsb2FkTGF6eVJvdXRlKFxuICAgIG1hdGNoLnJvdXRlLFxuICAgIGlzTXV0YXRpb25NZXRob2QocmVxdWVzdC5tZXRob2QpID8gXCJhY3Rpb25cIiA6IFwibG9hZGVyXCIsXG4gICAgbWFuaWZlc3QsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwXG4gICk7XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZTogbGF6eU1pZGRsZXdhcmVQcm9taXNlLFxuICAgIHJvdXRlOiBsYXp5Um91dGVQcm9taXNlcy5sYXp5Um91dGVQcm9taXNlLFxuICAgIGhhbmRsZXI6IGxhenlSb3V0ZVByb21pc2VzLmxhenlIYW5kbGVyUHJvbWlzZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGF0YVN0cmF0ZWd5TWF0Y2gobWFwUm91dGVQcm9wZXJ0aWVzMiwgbWFuaWZlc3QsIHJlcXVlc3QsIG1hdGNoLCBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLCBzY29wZWRDb250ZXh0LCBzaG91bGRMb2FkLCB1bnN0YWJsZV9zaG91bGRSZXZhbGlkYXRlQXJncyA9IG51bGwpIHtcbiAgbGV0IGlzVXNpbmdOZXdBcGkgPSBmYWxzZTtcbiAgbGV0IF9sYXp5UHJvbWlzZXMgPSBnZXREYXRhU3RyYXRlZ3lNYXRjaExhenlQcm9taXNlcyhcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMyLFxuICAgIG1hbmlmZXN0LFxuICAgIHJlcXVlc3QsXG4gICAgbWF0Y2gsXG4gICAgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcFxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLm1hdGNoLFxuICAgIF9sYXp5UHJvbWlzZXMsXG4gICAgc2hvdWxkTG9hZCxcbiAgICB1bnN0YWJsZV9zaG91bGRSZXZhbGlkYXRlQXJncyxcbiAgICB1bnN0YWJsZV9zaG91bGRDYWxsSGFuZGxlcihkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSkge1xuICAgICAgaXNVc2luZ05ld0FwaSA9IHRydWU7XG4gICAgICBpZiAoIXVuc3RhYmxlX3Nob3VsZFJldmFsaWRhdGVBcmdzKSB7XG4gICAgICAgIHJldHVybiBzaG91bGRMb2FkO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHNob3VsZFJldmFsaWRhdGVMb2FkZXIobWF0Y2gsIHtcbiAgICAgICAgICAuLi51bnN0YWJsZV9zaG91bGRSZXZhbGlkYXRlQXJncyxcbiAgICAgICAgICBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKG1hdGNoLCB1bnN0YWJsZV9zaG91bGRSZXZhbGlkYXRlQXJncyk7XG4gICAgfSxcbiAgICByZXNvbHZlKGhhbmRsZXJPdmVycmlkZSkge1xuICAgICAgaWYgKGlzVXNpbmdOZXdBcGkgfHwgc2hvdWxkTG9hZCB8fCBoYW5kbGVyT3ZlcnJpZGUgJiYgcmVxdWVzdC5tZXRob2QgPT09IFwiR0VUXCIgJiYgKG1hdGNoLnJvdXRlLmxhenkgfHwgbWF0Y2gucm91dGUubG9hZGVyKSkge1xuICAgICAgICByZXR1cm4gY2FsbExvYWRlck9yQWN0aW9uKHtcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGxhenlIYW5kbGVyUHJvbWlzZTogX2xhenlQcm9taXNlcz8uaGFuZGxlcixcbiAgICAgICAgICBsYXp5Um91dGVQcm9taXNlOiBfbGF6eVByb21pc2VzPy5yb3V0ZSxcbiAgICAgICAgICBoYW5kbGVyT3ZlcnJpZGUsXG4gICAgICAgICAgc2NvcGVkQ29udGV4dFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB0eXBlOiBcImRhdGFcIiAvKiBkYXRhICovLCByZXN1bHQ6IHZvaWQgMCB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRlZERhdGFTdHJhdGVneU1hdGNoZXMobWFwUm91dGVQcm9wZXJ0aWVzMiwgbWFuaWZlc3QsIHJlcXVlc3QsIG1hdGNoZXMsIHRhcmdldE1hdGNoLCBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwLCBzY29wZWRDb250ZXh0LCBzaG91bGRSZXZhbGlkYXRlQXJncyA9IG51bGwpIHtcbiAgcmV0dXJuIG1hdGNoZXMubWFwKChtYXRjaCkgPT4ge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5pZCAhPT0gdGFyZ2V0TWF0Y2gucm91dGUuaWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1hdGNoLFxuICAgICAgICBzaG91bGRMb2FkOiBmYWxzZSxcbiAgICAgICAgdW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3M6IHNob3VsZFJldmFsaWRhdGVBcmdzLFxuICAgICAgICB1bnN0YWJsZV9zaG91bGRDYWxsSGFuZGxlcjogKCkgPT4gZmFsc2UsXG4gICAgICAgIF9sYXp5UHJvbWlzZXM6IGdldERhdGFTdHJhdGVneU1hdGNoTGF6eVByb21pc2VzKFxuICAgICAgICAgIG1hcFJvdXRlUHJvcGVydGllczIsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBsYXp5Um91dGVQcm9wZXJ0aWVzVG9Ta2lwXG4gICAgICAgICksXG4gICAgICAgIHJlc29sdmU6ICgpID0+IFByb21pc2UucmVzb2x2ZSh7IHR5cGU6IFwiZGF0YVwiLCByZXN1bHQ6IHZvaWQgMCB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGdldERhdGFTdHJhdGVneU1hdGNoKFxuICAgICAgbWFwUm91dGVQcm9wZXJ0aWVzMixcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcmVxdWVzdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCxcbiAgICAgIHNjb3BlZENvbnRleHQsXG4gICAgICB0cnVlLFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZUFyZ3NcbiAgICApO1xuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGxEYXRhU3RyYXRlZ3lJbXBsKGRhdGFTdHJhdGVneUltcGwsIHJlcXVlc3QsIG1hdGNoZXMsIGZldGNoZXJLZXksIHNjb3BlZENvbnRleHQsIGlzU3RhdGljSGFuZGxlcikge1xuICBpZiAobWF0Y2hlcy5zb21lKChtKSA9PiBtLl9sYXp5UHJvbWlzZXM/Lm1pZGRsZXdhcmUpKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwobWF0Y2hlcy5tYXAoKG0pID0+IG0uX2xhenlQcm9taXNlcz8ubWlkZGxld2FyZSkpO1xuICB9XG4gIGxldCBkYXRhU3RyYXRlZ3lBcmdzID0ge1xuICAgIHJlcXVlc3QsXG4gICAgcGFyYW1zOiBtYXRjaGVzWzBdLnBhcmFtcyxcbiAgICBjb250ZXh0OiBzY29wZWRDb250ZXh0LFxuICAgIG1hdGNoZXNcbiAgfTtcbiAgbGV0IHVuc3RhYmxlX3J1bkNsaWVudE1pZGRsZXdhcmUgPSBpc1N0YXRpY0hhbmRsZXIgPyAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2Fubm90IGNhbGwgYHVuc3RhYmxlX3J1bkNsaWVudE1pZGRsZXdhcmUoKWAgZnJvbSBhIHN0YXRpYyBoYW5kbGVyIGBkYXRhU3RyYXRlZ3lgLiBNaWRkbGV3YXJlIGlzIHJ1biBvdXRzaWRlIG9mIGBkYXRhU3RyYXRlZ3lgIGR1cmluZyBTU1IgaW4gb3JkZXIgdG8gYnViYmxlIHVwIHRoZSBSZXNwb25zZS4gIFlvdSBjYW4gZW5hYmxlIG1pZGRsZXdhcmUgdmlhIHRoZSBgcmVzcG9uZGAgQVBJIGluIGBxdWVyeWAvYHF1ZXJ5Um91dGVgXCJcbiAgICApO1xuICB9IDogKGNiKSA9PiB7XG4gICAgbGV0IHR5cGVkRGF0YVN0cmF0ZWd5QXJncyA9IGRhdGFTdHJhdGVneUFyZ3M7XG4gICAgcmV0dXJuIHJ1bk1pZGRsZXdhcmVQaXBlbGluZShcbiAgICAgIHR5cGVkRGF0YVN0cmF0ZWd5QXJncyxcbiAgICAgIGZhbHNlLFxuICAgICAgKCkgPT4gY2Ioe1xuICAgICAgICAuLi50eXBlZERhdGFTdHJhdGVneUFyZ3MsXG4gICAgICAgIGZldGNoZXJLZXksXG4gICAgICAgIHVuc3RhYmxlX3J1bkNsaWVudE1pZGRsZXdhcmU6ICgpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBjYWxsIGB1bnN0YWJsZV9ydW5DbGllbnRNaWRkbGV3YXJlKClgIGZyb20gd2l0aGluIGFuIGB1bnN0YWJsZV9ydW5DbGllbnRNaWRkbGV3YXJlYCBoYW5kbGVyXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIChlcnJvciwgcm91dGVJZCkgPT4gKHtcbiAgICAgICAgW3JvdXRlSWRdOiB7IHR5cGU6IFwiZXJyb3JcIiwgcmVzdWx0OiBlcnJvciB9XG4gICAgICB9KVxuICAgICk7XG4gIH07XG4gIGxldCByZXN1bHRzID0gYXdhaXQgZGF0YVN0cmF0ZWd5SW1wbCh7XG4gICAgLi4uZGF0YVN0cmF0ZWd5QXJncyxcbiAgICBmZXRjaGVyS2V5LFxuICAgIHVuc3RhYmxlX3J1bkNsaWVudE1pZGRsZXdhcmVcbiAgfSk7XG4gIHRyeSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBtYXRjaGVzLmZsYXRNYXAoKG0pID0+IFttLl9sYXp5UHJvbWlzZXM/LmhhbmRsZXIsIG0uX2xhenlQcm9taXNlcz8ucm91dGVdKVxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXJPckFjdGlvbih7XG4gIHJlcXVlc3QsXG4gIG1hdGNoLFxuICBsYXp5SGFuZGxlclByb21pc2UsXG4gIGxhenlSb3V0ZVByb21pc2UsXG4gIGhhbmRsZXJPdmVycmlkZSxcbiAgc2NvcGVkQ29udGV4dFxufSkge1xuICBsZXQgcmVzdWx0O1xuICBsZXQgb25SZWplY3Q7XG4gIGxldCBpc0FjdGlvbiA9IGlzTXV0YXRpb25NZXRob2QocmVxdWVzdC5tZXRob2QpO1xuICBsZXQgdHlwZSA9IGlzQWN0aW9uID8gXCJhY3Rpb25cIiA6IFwibG9hZGVyXCI7XG4gIGxldCBydW5IYW5kbGVyID0gKGhhbmRsZXIpID0+IHtcbiAgICBsZXQgcmVqZWN0O1xuICAgIGxldCBhYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gcmVqZWN0ID0gcik7XG4gICAgb25SZWplY3QgPSAoKSA9PiByZWplY3QoKTtcbiAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25SZWplY3QpO1xuICAgIGxldCBhY3R1YWxIYW5kbGVyID0gKGN0eCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBZb3UgY2Fubm90IGNhbGwgdGhlIGhhbmRsZXIgZm9yIGEgcm91dGUgd2hpY2ggZGVmaW5lcyBhIGJvb2xlYW4gXCIke3R5cGV9XCIgW3JvdXRlSWQ6ICR7bWF0Y2gucm91dGUuaWR9XWBcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFuZGxlcihcbiAgICAgICAge1xuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgICAgY29udGV4dDogc2NvcGVkQ29udGV4dFxuICAgICAgICB9LFxuICAgICAgICAuLi5jdHggIT09IHZvaWQgMCA/IFtjdHhdIDogW11cbiAgICAgICk7XG4gICAgfTtcbiAgICBsZXQgaGFuZGxlclByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHZhbCA9IGF3YWl0IChoYW5kbGVyT3ZlcnJpZGUgPyBoYW5kbGVyT3ZlcnJpZGUoKGN0eCkgPT4gYWN0dWFsSGFuZGxlcihjdHgpKSA6IGFjdHVhbEhhbmRsZXIoKSk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZGF0YVwiLCByZXN1bHQ6IHZhbCB9O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHJlc3VsdDogZSB9O1xuICAgICAgfVxuICAgIH0pKCk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbaGFuZGxlclByb21pc2UsIGFib3J0UHJvbWlzZV0pO1xuICB9O1xuICB0cnkge1xuICAgIGxldCBoYW5kbGVyID0gaXNBY3Rpb24gPyBtYXRjaC5yb3V0ZS5hY3Rpb24gOiBtYXRjaC5yb3V0ZS5sb2FkZXI7XG4gICAgaWYgKGxhenlIYW5kbGVyUHJvbWlzZSB8fCBsYXp5Um91dGVQcm9taXNlKSB7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBsZXQgaGFuZGxlckVycm9yO1xuICAgICAgICBsZXQgW3ZhbHVlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAvLyBJZiB0aGUgaGFuZGxlciB0aHJvd3MsIGRvbid0IGxldCBpdCBpbW1lZGlhdGVseSBidWJibGUgb3V0LFxuICAgICAgICAgIC8vIHNpbmNlIHdlIG5lZWQgdG8gbGV0IHRoZSBsYXp5KCkgZXhlY3V0aW9uIGZpbmlzaCBzbyB3ZSBrbm93IGlmIHRoaXNcbiAgICAgICAgICAvLyByb3V0ZSBoYXMgYSBib3VuZGFyeSB0aGF0IGNhbiBoYW5kbGUgdGhlIGVycm9yXG4gICAgICAgICAgcnVuSGFuZGxlcihoYW5kbGVyKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlckVycm9yID0gZTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAvLyBFbnN1cmUgYWxsIGxhenkgcm91dGUgcHJvbWlzZXMgYXJlIHJlc29sdmVkIGJlZm9yZSBjb250aW51aW5nXG4gICAgICAgICAgbGF6eUhhbmRsZXJQcm9taXNlLFxuICAgICAgICAgIGxhenlSb3V0ZVByb21pc2VcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChoYW5kbGVyRXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGxhenlIYW5kbGVyUHJvbWlzZTtcbiAgICAgICAgbGV0IGhhbmRsZXIyID0gaXNBY3Rpb24gPyBtYXRjaC5yb3V0ZS5hY3Rpb24gOiBtYXRjaC5yb3V0ZS5sb2FkZXI7XG4gICAgICAgIGlmIChoYW5kbGVyMikge1xuICAgICAgICAgIFtyZXN1bHRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3J1bkhhbmRsZXIoaGFuZGxlcjIpLCBsYXp5Um91dGVQcm9taXNlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJhY3Rpb25cIikge1xuICAgICAgICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICAgICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA1LCB7XG4gICAgICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICByb3V0ZUlkOiBtYXRjaC5yb3V0ZS5pZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZGF0YVwiIC8qIGRhdGEgKi8sIHJlc3VsdDogdm9pZCAwIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICBsZXQgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLywgcmVzdWx0OiBlIH07XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKG9uUmVqZWN0KSB7XG4gICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25SZWplY3QpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuYXN5bmMgZnVuY3Rpb24gY29udmVydERhdGFTdHJhdGVneVJlc3VsdFRvRGF0YVJlc3VsdChkYXRhU3RyYXRlZ3lSZXN1bHQpIHtcbiAgbGV0IHsgcmVzdWx0LCB0eXBlIH0gPSBkYXRhU3RyYXRlZ3lSZXN1bHQ7XG4gIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICBsZXQgZGF0YTI7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb250ZW50VHlwZSA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgIGlmIChjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgICBpZiAocmVzdWx0LmJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgIGRhdGEyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhMiA9IGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEyID0gYXdhaXQgcmVzdWx0LnRleHQoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sIGVycm9yOiBlIH07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImVycm9yXCIgLyogZXJyb3IgKi8pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlSW1wbChyZXN1bHQuc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgZGF0YTIpLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzLFxuICAgICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVyc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZGF0YVwiIC8qIGRhdGEgKi8sXG4gICAgICBkYXRhOiBkYXRhMixcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXMsXG4gICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVyc1xuICAgIH07XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiZXJyb3JcIiAvKiBlcnJvciAqLykge1xuICAgIGlmIChpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHJlc3VsdCkpIHtcbiAgICAgIGlmIChyZXN1bHQuZGF0YSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiIC8qIGVycm9yICovLFxuICAgICAgICAgIGVycm9yOiByZXN1bHQuZGF0YSxcbiAgICAgICAgICBzdGF0dXNDb2RlOiByZXN1bHQuaW5pdD8uc3RhdHVzLFxuICAgICAgICAgIGhlYWRlcnM6IHJlc3VsdC5pbml0Py5oZWFkZXJzID8gbmV3IEhlYWRlcnMocmVzdWx0LmluaXQuaGVhZGVycykgOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIiAvKiBlcnJvciAqLyxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvclJlc3BvbnNlSW1wbChcbiAgICAgICAgICByZXN1bHQuaW5pdD8uc3RhdHVzIHx8IDUwMCxcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgcmVzdWx0LmRhdGFcbiAgICAgICAgKSxcbiAgICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdC5zdGF0dXMgOiB2b2lkIDAsXG4gICAgICAgIGhlYWRlcnM6IHJlc3VsdC5pbml0Py5oZWFkZXJzID8gbmV3IEhlYWRlcnMocmVzdWx0LmluaXQuaGVhZGVycykgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVycm9yXCIgLyogZXJyb3IgKi8sXG4gICAgICBlcnJvcjogcmVzdWx0LFxuICAgICAgc3RhdHVzQ29kZTogaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdC5zdGF0dXMgOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGlmIChpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHJlc3VsdCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkYXRhXCIgLyogZGF0YSAqLyxcbiAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxuICAgICAgc3RhdHVzQ29kZTogcmVzdWx0LmluaXQ/LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdC5pbml0Py5oZWFkZXJzID8gbmV3IEhlYWRlcnMocmVzdWx0LmluaXQuaGVhZGVycykgOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIHJldHVybiB7IHR5cGU6IFwiZGF0YVwiIC8qIGRhdGEgKi8sIGRhdGE6IHJlc3VsdCB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVsYXRpdmVSb3V0aW5nUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSwgcmVxdWVzdCwgcm91dGVJZCwgbWF0Y2hlcywgYmFzZW5hbWUpIHtcbiAgbGV0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgaW52YXJpYW50KFxuICAgIGxvY2F0aW9uLFxuICAgIFwiUmVkaXJlY3RzIHJldHVybmVkL3Rocm93biBmcm9tIGxvYWRlcnMvYWN0aW9ucyBtdXN0IGhhdmUgYSBMb2NhdGlvbiBoZWFkZXJcIlxuICApO1xuICBpZiAoIUFCU09MVVRFX1VSTF9SRUdFWC50ZXN0KGxvY2F0aW9uKSkge1xuICAgIGxldCB0cmltbWVkTWF0Y2hlcyA9IG1hdGNoZXMuc2xpY2UoXG4gICAgICAwLFxuICAgICAgbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpICsgMVxuICAgICk7XG4gICAgbG9jYXRpb24gPSBub3JtYWxpemVUbyhcbiAgICAgIG5ldyBVUkwocmVxdWVzdC51cmwpLFxuICAgICAgdHJpbW1lZE1hdGNoZXMsXG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGxvY2F0aW9uXG4gICAgKTtcbiAgICByZXNwb25zZS5oZWFkZXJzLnNldChcIkxvY2F0aW9uXCIsIGxvY2F0aW9uKTtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2U7XG59XG5mdW5jdGlvbiBub3JtYWxpemVSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uLCBjdXJyZW50VXJsLCBiYXNlbmFtZSkge1xuICBpZiAoQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XG4gICAgbGV0IG5vcm1hbGl6ZWRMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIGxldCB1cmwgPSBub3JtYWxpemVkTG9jYXRpb24uc3RhcnRzV2l0aChcIi8vXCIpID8gbmV3IFVSTChjdXJyZW50VXJsLnByb3RvY29sICsgbm9ybWFsaXplZExvY2F0aW9uKSA6IG5ldyBVUkwobm9ybWFsaXplZExvY2F0aW9uKTtcbiAgICBsZXQgaXNTYW1lQmFzZW5hbWUgPSBzdHJpcEJhc2VuYW1lKHVybC5wYXRobmFtZSwgYmFzZW5hbWUpICE9IG51bGw7XG4gICAgaWYgKHVybC5vcmlnaW4gPT09IGN1cnJlbnRVcmwub3JpZ2luICYmIGlzU2FtZUJhc2VuYW1lKSB7XG4gICAgICByZXR1cm4gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCArIHVybC5oYXNoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG9jYXRpb247XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChoaXN0b3J5LCBsb2NhdGlvbiwgc2lnbmFsLCBzdWJtaXNzaW9uKSB7XG4gIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZVVSTChzdHJpcEhhc2hGcm9tUGF0aChsb2NhdGlvbikpLnRvU3RyaW5nKCk7XG4gIGxldCBpbml0ID0geyBzaWduYWwgfTtcbiAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUVuY1R5cGUgfSA9IHN1Ym1pc3Npb247XG4gICAgaW5pdC5tZXRob2QgPSBmb3JtTWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgaW5pdC5oZWFkZXJzID0gbmV3IEhlYWRlcnMoeyBcIkNvbnRlbnQtVHlwZVwiOiBmb3JtRW5jVHlwZSB9KTtcbiAgICAgIGluaXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KHN1Ym1pc3Npb24uanNvbik7XG4gICAgfSBlbHNlIGlmIChmb3JtRW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIGluaXQuYm9keSA9IHN1Ym1pc3Npb24udGV4dDtcbiAgICB9IGVsc2UgaWYgKGZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICYmIHN1Ym1pc3Npb24uZm9ybURhdGEpIHtcbiAgICAgIGluaXQuYm9keSA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKHN1Ym1pc3Npb24uZm9ybURhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0LmJvZHkgPSBzdWJtaXNzaW9uLmZvcm1EYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLCBpbml0KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKGZvcm1EYXRhKSB7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpIHtcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiB2YWx1ZS5uYW1lKTtcbiAgfVxuICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuZnVuY3Rpb24gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKSB7XG4gIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygc2VhcmNoUGFyYW1zLmVudHJpZXMoKSkge1xuICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZm9ybURhdGE7XG59XG5mdW5jdGlvbiBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKG1hdGNoZXMsIHJlc3VsdHMsIHBlbmRpbmdBY3Rpb25SZXN1bHQsIGlzU3RhdGljSGFuZGxlciA9IGZhbHNlLCBza2lwTG9hZGVyRXJyb3JCdWJibGluZyA9IGZhbHNlKSB7XG4gIGxldCBsb2FkZXJEYXRhID0ge307XG4gIGxldCBlcnJvcnMgPSBudWxsO1xuICBsZXQgc3RhdHVzQ29kZTtcbiAgbGV0IGZvdW5kRXJyb3IgPSBmYWxzZTtcbiAgbGV0IGxvYWRlckhlYWRlcnMgPSB7fTtcbiAgbGV0IHBlbmRpbmdFcnJvciA9IHBlbmRpbmdBY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChwZW5kaW5nQWN0aW9uUmVzdWx0WzFdKSA/IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZXJyb3IgOiB2b2lkIDA7XG4gIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICBpZiAoIShtYXRjaC5yb3V0ZS5pZCBpbiByZXN1bHRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgaWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tpZF07XG4gICAgaW52YXJpYW50KFxuICAgICAgIWlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSxcbiAgICAgIFwiQ2Fubm90IGhhbmRsZSByZWRpcmVjdCByZXN1bHRzIGluIHByb2Nlc3NMb2FkZXJEYXRhXCJcbiAgICApO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICAgIGlmIChwZW5kaW5nRXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgICBlcnJvciA9IHBlbmRpbmdFcnJvcjtcbiAgICAgICAgcGVuZGluZ0Vycm9yID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IHt9O1xuICAgICAgaWYgKHNraXBMb2FkZXJFcnJvckJ1YmJsaW5nKSB7XG4gICAgICAgIGVycm9yc1tpZF0gPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBpZCk7XG4gICAgICAgIGlmIChlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU3RhdGljSGFuZGxlcikge1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IFJlc2V0TG9hZGVyRGF0YVN5bWJvbDtcbiAgICAgIH1cbiAgICAgIGlmICghZm91bmRFcnJvcikge1xuICAgICAgICBmb3VuZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgc3RhdHVzQ29kZSA9IGlzUm91dGVFcnJvclJlc3BvbnNlKHJlc3VsdC5lcnJvcikgPyByZXN1bHQuZXJyb3Iuc3RhdHVzIDogNTAwO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5oZWFkZXJzKSB7XG4gICAgICAgIGxvYWRlckhlYWRlcnNbaWRdID0gcmVzdWx0LmhlYWRlcnM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRlckRhdGFbaWRdID0gcmVzdWx0LmRhdGE7XG4gICAgICBpZiAocmVzdWx0LnN0YXR1c0NvZGUgJiYgcmVzdWx0LnN0YXR1c0NvZGUgIT09IDIwMCAmJiAhZm91bmRFcnJvcikge1xuICAgICAgICBzdGF0dXNDb2RlID0gcmVzdWx0LnN0YXR1c0NvZGU7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAocGVuZGluZ0Vycm9yICE9PSB2b2lkIDAgJiYgcGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICAgIGVycm9ycyA9IHsgW3BlbmRpbmdBY3Rpb25SZXN1bHRbMF1dOiBwZW5kaW5nRXJyb3IgfTtcbiAgICBpZiAocGVuZGluZ0FjdGlvblJlc3VsdFsyXSkge1xuICAgICAgbG9hZGVyRGF0YVtwZW5kaW5nQWN0aW9uUmVzdWx0WzJdXSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsb2FkZXJEYXRhLFxuICAgIGVycm9ycyxcbiAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlIHx8IDIwMCxcbiAgICBsb2FkZXJIZWFkZXJzXG4gIH07XG59XG5mdW5jdGlvbiBwcm9jZXNzTG9hZGVyRGF0YShzdGF0ZSwgbWF0Y2hlcywgcmVzdWx0cywgcGVuZGluZ0FjdGlvblJlc3VsdCwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsIGZldGNoZXJSZXN1bHRzKSB7XG4gIGxldCB7IGxvYWRlckRhdGEsIGVycm9ycyB9ID0gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShcbiAgICBtYXRjaGVzLFxuICAgIHJlc3VsdHMsXG4gICAgcGVuZGluZ0FjdGlvblJlc3VsdFxuICApO1xuICByZXZhbGlkYXRpbmdGZXRjaGVycy5maWx0ZXIoKGYpID0+ICFmLm1hdGNoZXMgfHwgZi5tYXRjaGVzLnNvbWUoKG0pID0+IG0uc2hvdWxkTG9hZCkpLmZvckVhY2goKHJmKSA9PiB7XG4gICAgbGV0IHsga2V5LCBtYXRjaCwgY29udHJvbGxlciB9ID0gcmY7XG4gICAgbGV0IHJlc3VsdCA9IGZldGNoZXJSZXN1bHRzW2tleV07XG4gICAgaW52YXJpYW50KHJlc3VsdCwgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiKTtcbiAgICBpZiAoY29udHJvbGxlciAmJiBjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCBtYXRjaD8ucm91dGUuaWQpO1xuICAgICAgaWYgKCEoZXJyb3JzICYmIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSkpIHtcbiAgICAgICAgZXJyb3JzID0ge1xuICAgICAgICAgIC4uLmVycm9ycyxcbiAgICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvclxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgXCJVbmhhbmRsZWQgZmV0Y2hlciByZXZhbGlkYXRpb24gcmVkaXJlY3RcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IGdldERvbmVGZXRjaGVyKHJlc3VsdC5kYXRhKTtcbiAgICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGRvbmVGZXRjaGVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4geyBsb2FkZXJEYXRhLCBlcnJvcnMgfTtcbn1cbmZ1bmN0aW9uIG1lcmdlTG9hZGVyRGF0YShsb2FkZXJEYXRhLCBuZXdMb2FkZXJEYXRhLCBtYXRjaGVzLCBlcnJvcnMpIHtcbiAgbGV0IG1lcmdlZExvYWRlckRhdGEgPSBPYmplY3QuZW50cmllcyhuZXdMb2FkZXJEYXRhKS5maWx0ZXIoKFssIHZdKSA9PiB2ICE9PSBSZXNldExvYWRlckRhdGFTeW1ib2wpLnJlZHVjZSgobWVyZ2VkLCBbaywgdl0pID0+IHtcbiAgICBtZXJnZWRba10gPSB2O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTtcbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGlmICghbmV3TG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbG9hZGVyRGF0YS5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWF0Y2gucm91dGUubG9hZGVyKSB7XG4gICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IGxvYWRlckRhdGFbaWRdO1xuICAgIH1cbiAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkTG9hZGVyRGF0YTtcbn1cbmZ1bmN0aW9uIGdldEFjdGlvbkRhdGFGb3JDb21taXQocGVuZGluZ0FjdGlvblJlc3VsdCkge1xuICBpZiAoIXBlbmRpbmdBY3Rpb25SZXN1bHQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIGlzRXJyb3JSZXN1bHQocGVuZGluZ0FjdGlvblJlc3VsdFsxXSkgPyB7XG4gICAgLy8gQ2xlYXIgb3V0IHByaW9yIGFjdGlvbkRhdGEgb24gZXJyb3JzXG4gICAgYWN0aW9uRGF0YToge31cbiAgfSA6IHtcbiAgICBhY3Rpb25EYXRhOiB7XG4gICAgICBbcGVuZGluZ0FjdGlvblJlc3VsdFswXV06IHBlbmRpbmdBY3Rpb25SZXN1bHRbMV0uZGF0YVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcywgcm91dGVJZCkge1xuICBsZXQgZWxpZ2libGVNYXRjaGVzID0gcm91dGVJZCA/IG1hdGNoZXMuc2xpY2UoMCwgbWF0Y2hlcy5maW5kSW5kZXgoKG0pID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpICsgMSkgOiBbLi4ubWF0Y2hlc107XG4gIHJldHVybiBlbGlnaWJsZU1hdGNoZXMucmV2ZXJzZSgpLmZpbmQoKG0pID0+IG0ucm91dGUuaGFzRXJyb3JCb3VuZGFyeSA9PT0gdHJ1ZSkgfHwgbWF0Y2hlc1swXTtcbn1cbmZ1bmN0aW9uIGdldFNob3J0Q2lyY3VpdE1hdGNoZXMocm91dGVzKSB7XG4gIGxldCByb3V0ZSA9IHJvdXRlcy5sZW5ndGggPT09IDEgPyByb3V0ZXNbMF0gOiByb3V0ZXMuZmluZCgocikgPT4gci5pbmRleCB8fCAhci5wYXRoIHx8IHIucGF0aCA9PT0gXCIvXCIpIHx8IHtcbiAgICBpZDogYF9fc2hpbS1lcnJvci1yb3V0ZV9fYFxuICB9O1xuICByZXR1cm4ge1xuICAgIG1hdGNoZXM6IFtcbiAgICAgIHtcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICAgIHBhdGhuYW1lQmFzZTogXCJcIixcbiAgICAgICAgcm91dGVcbiAgICAgIH1cbiAgICBdLFxuICAgIHJvdXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKHN0YXR1cywge1xuICBwYXRobmFtZSxcbiAgcm91dGVJZCxcbiAgbWV0aG9kLFxuICB0eXBlLFxuICBtZXNzYWdlXG59ID0ge30pIHtcbiAgbGV0IHN0YXR1c1RleHQgPSBcIlVua25vd24gU2VydmVyIEVycm9yXCI7XG4gIGxldCBlcnJvck1lc3NhZ2UgPSBcIlVua25vd24gQHJlbWl4LXJ1bi9yb3V0ZXIgZXJyb3JcIjtcbiAgaWYgKHN0YXR1cyA9PT0gNDAwKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiQmFkIFJlcXVlc3RcIjtcbiAgICBpZiAobWV0aG9kICYmIHBhdGhuYW1lICYmIHJvdXRlSWQpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBZb3UgbWFkZSBhICR7bWV0aG9kfSByZXF1ZXN0IHRvIFwiJHtwYXRobmFtZX1cIiBidXQgZGlkIG5vdCBwcm92aWRlIGEgXFxgbG9hZGVyXFxgIGZvciByb3V0ZSBcIiR7cm91dGVJZH1cIiwgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5gO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJpbnZhbGlkLWJvZHlcIikge1xuICAgICAgZXJyb3JNZXNzYWdlID0gXCJVbmFibGUgdG8gZW5jb2RlIHN1Ym1pc3Npb24gYm9keVwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwMykge1xuICAgIHN0YXR1c1RleHQgPSBcIkZvcmJpZGRlblwiO1xuICAgIGVycm9yTWVzc2FnZSA9IGBSb3V0ZSBcIiR7cm91dGVJZH1cIiBkb2VzIG5vdCBtYXRjaCBVUkwgXCIke3BhdGhuYW1lfVwiYDtcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09IDQwNCkge1xuICAgIHN0YXR1c1RleHQgPSBcIk5vdCBGb3VuZFwiO1xuICAgIGVycm9yTWVzc2FnZSA9IGBObyByb3V0ZSBtYXRjaGVzIFVSTCBcIiR7cGF0aG5hbWV9XCJgO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA1KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBgWW91IG1hZGUgYSAke21ldGhvZC50b1VwcGVyQ2FzZSgpfSByZXF1ZXN0IHRvIFwiJHtwYXRobmFtZX1cIiBidXQgZGlkIG5vdCBwcm92aWRlIGFuIFxcYGFjdGlvblxcYCBmb3Igcm91dGUgXCIke3JvdXRlSWR9XCIsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuYDtcbiAgICB9IGVsc2UgaWYgKG1ldGhvZCkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYEludmFsaWQgcmVxdWVzdCBtZXRob2QgXCIke21ldGhvZC50b1VwcGVyQ2FzZSgpfVwiYDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBFcnJvclJlc3BvbnNlSW1wbChcbiAgICBzdGF0dXMgfHwgNTAwLFxuICAgIHN0YXR1c1RleHQsXG4gICAgbmV3IEVycm9yKGVycm9yTWVzc2FnZSksXG4gICAgdHJ1ZVxuICApO1xufVxuZnVuY3Rpb24gZmluZFJlZGlyZWN0KHJlc3VsdHMpIHtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhyZXN1bHRzKTtcbiAgZm9yIChsZXQgaSA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgW2tleSwgcmVzdWx0XSA9IGVudHJpZXNbaV07XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHsga2V5LCByZXN1bHQgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN0cmlwSGFzaEZyb21QYXRoKHBhdGgpIHtcbiAgbGV0IHBhcnNlZFBhdGggPSB0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChwYXRoKSA6IHBhdGg7XG4gIHJldHVybiBjcmVhdGVQYXRoKHsgLi4ucGFyc2VkUGF0aCwgaGFzaDogXCJcIiB9KTtcbn1cbmZ1bmN0aW9uIGlzSGFzaENoYW5nZU9ubHkoYSwgYikge1xuICBpZiAoYS5wYXRobmFtZSAhPT0gYi5wYXRobmFtZSB8fCBhLnNlYXJjaCAhPT0gYi5zZWFyY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGEuaGFzaCA9PT0gXCJcIikge1xuICAgIHJldHVybiBiLmhhc2ggIT09IFwiXCI7XG4gIH0gZWxzZSBpZiAoYS5oYXNoID09PSBiLmhhc2gpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChiLmhhc2ggIT09IFwiXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0RhdGFTdHJhdGVneVJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdCAhPSBudWxsICYmIHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiYgXCJ0eXBlXCIgaW4gcmVzdWx0ICYmIFwicmVzdWx0XCIgaW4gcmVzdWx0ICYmIChyZXN1bHQudHlwZSA9PT0gXCJkYXRhXCIgLyogZGF0YSAqLyB8fCByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovKTtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdC5yZXN1bHQpICYmIHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHJlc3VsdC5yZXN1bHQuc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIC8qIGVycm9yICovO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIChyZXN1bHQgJiYgcmVzdWx0LnR5cGUpID09PSBcInJlZGlyZWN0XCIgLyogcmVkaXJlY3QgKi87XG59XG5mdW5jdGlvbiBpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT0gbnVsbCAmJiBcInR5cGVcIiBpbiB2YWx1ZSAmJiBcImRhdGFcIiBpbiB2YWx1ZSAmJiBcImluaXRcIiBpbiB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcIkRhdGFXaXRoUmVzcG9uc2VJbml0XCI7XG59XG5mdW5jdGlvbiBpc1Jlc3BvbnNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHZhbHVlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHZhbHVlLmhlYWRlcnMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLmJvZHkgIT09IFwidW5kZWZpbmVkXCI7XG59XG5mdW5jdGlvbiBpc1JlZGlyZWN0U3RhdHVzQ29kZShzdGF0dXNDb2RlKSB7XG4gIHJldHVybiByZWRpcmVjdFN0YXR1c0NvZGVzLmhhcyhzdGF0dXNDb2RlKTtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXN1bHQpIHtcbiAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSAmJiBpc1JlZGlyZWN0U3RhdHVzQ29kZShyZXN1bHQuc3RhdHVzKSAmJiByZXN1bHQuaGVhZGVycy5oYXMoXCJMb2NhdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRNZXRob2QobWV0aG9kKSB7XG4gIHJldHVybiB2YWxpZFJlcXVlc3RNZXRob2RzLmhhcyhtZXRob2QudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBpc011dGF0aW9uTWV0aG9kKG1ldGhvZCkge1xuICByZXR1cm4gdmFsaWRNdXRhdGlvbk1ldGhvZHMuaGFzKG1ldGhvZC50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2gpIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKS5nZXRBbGwoXCJpbmRleFwiKS5zb21lKCh2KSA9PiB2ID09PSBcIlwiKTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldE1hdGNoKG1hdGNoZXMsIGxvY2F0aW9uKSB7XG4gIGxldCBzZWFyY2ggPSB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBwYXJzZVBhdGgobG9jYXRpb24pLnNlYXJjaCA6IGxvY2F0aW9uLnNlYXJjaDtcbiAgaWYgKG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5pbmRleCAmJiBoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoIHx8IFwiXCIpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgfVxuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgcmV0dXJuIHBhdGhNYXRjaGVzW3BhdGhNYXRjaGVzLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKG5hdmlnYXRpb24pIHtcbiAgbGV0IHsgZm9ybU1ldGhvZCwgZm9ybUFjdGlvbiwgZm9ybUVuY1R5cGUsIHRleHQsIGZvcm1EYXRhLCBqc29uIH0gPSBuYXZpZ2F0aW9uO1xuICBpZiAoIWZvcm1NZXRob2QgfHwgIWZvcm1BY3Rpb24gfHwgIWZvcm1FbmNUeXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB2b2lkIDAsXG4gICAgICBqc29uOiB2b2lkIDAsXG4gICAgICB0ZXh0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmb3JtRGF0YSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgIHRleHQ6IHZvaWQgMFxuICAgIH07XG4gIH0gZWxzZSBpZiAoanNvbiAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAganNvbixcbiAgICAgIHRleHQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XG4gIGlmIChzdWJtaXNzaW9uKSB7XG4gICAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICB9IGVsc2Uge1xuICAgIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gICAgICBmb3JtQWN0aW9uOiB2b2lkIDAsXG4gICAgICBmb3JtRW5jVHlwZTogdm9pZCAwLFxuICAgICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICAgIGpzb246IHZvaWQgMCxcbiAgICAgIHRleHQ6IHZvaWQgMFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XG4gIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICBsb2NhdGlvbixcbiAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcbiAgfTtcbiAgcmV0dXJuIG5hdmlnYXRpb247XG59XG5mdW5jdGlvbiBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBkYXRhMikge1xuICBpZiAoc3VibWlzc2lvbikge1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgZm9ybU1ldGhvZDogc3VibWlzc2lvbi5mb3JtTWV0aG9kLFxuICAgICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogc3VibWlzc2lvbi5mb3JtRGF0YSxcbiAgICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICAgIGRhdGE6IGRhdGEyXG4gICAgfTtcbiAgICByZXR1cm4gZmV0Y2hlcjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIGZvcm1NZXRob2Q6IHZvaWQgMCxcbiAgICAgIGZvcm1BY3Rpb246IHZvaWQgMCxcbiAgICAgIGZvcm1FbmNUeXBlOiB2b2lkIDAsXG4gICAgICBmb3JtRGF0YTogdm9pZCAwLFxuICAgICAganNvbjogdm9pZCAwLFxuICAgICAgdGV4dDogdm9pZCAwLFxuICAgICAgZGF0YTogZGF0YTJcbiAgICB9O1xuICAgIHJldHVybiBmZXRjaGVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdWJtaXR0aW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBleGlzdGluZ0ZldGNoZXIpIHtcbiAgbGV0IGZldGNoZXIgPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICBkYXRhOiBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHZvaWQgMFxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cbmZ1bmN0aW9uIGdldERvbmVGZXRjaGVyKGRhdGEyKSB7XG4gIGxldCBmZXRjaGVyID0ge1xuICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICBmb3JtTWV0aG9kOiB2b2lkIDAsXG4gICAgZm9ybUFjdGlvbjogdm9pZCAwLFxuICAgIGZvcm1FbmNUeXBlOiB2b2lkIDAsXG4gICAgZm9ybURhdGE6IHZvaWQgMCxcbiAgICBqc29uOiB2b2lkIDAsXG4gICAgdGV4dDogdm9pZCAwLFxuICAgIGRhdGE6IGRhdGEyXG4gIH07XG4gIHJldHVybiBmZXRjaGVyO1xufVxuZnVuY3Rpb24gcmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyhfd2luZG93LCB0cmFuc2l0aW9ucykge1xuICB0cnkge1xuICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFxuICAgICAgVFJBTlNJVElPTlNfU1RPUkFHRV9LRVlcbiAgICApO1xuICAgIGlmIChzZXNzaW9uUG9zaXRpb25zKSB7XG4gICAgICBsZXQganNvbiA9IEpTT04ucGFyc2Uoc2Vzc2lvblBvc2l0aW9ucyk7XG4gICAgICBmb3IgKGxldCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoanNvbiB8fCB7fSkpIHtcbiAgICAgICAgaWYgKHYgJiYgQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgIHRyYW5zaXRpb25zLnNldChrLCBuZXcgU2V0KHYgfHwgW10pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5mdW5jdGlvbiBwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zKF93aW5kb3csIHRyYW5zaXRpb25zKSB7XG4gIGlmICh0cmFuc2l0aW9ucy5zaXplID4gMCkge1xuICAgIGxldCBqc29uID0ge307XG4gICAgZm9yIChsZXQgW2ssIHZdIG9mIHRyYW5zaXRpb25zKSB7XG4gICAgICBqc29uW2tdID0gWy4uLnZdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICBUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoanNvbilcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBgRmFpbGVkIHRvIHNhdmUgYXBwbGllZCB2aWV3IHRyYW5zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlICgke2Vycm9yfSkuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gYXN5bmMgKHZhbCkgPT4ge1xuICAgICAgcmVzKHZhbCk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH07XG4gICAgcmVqZWN0ID0gYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICByZWooZXJyb3IpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgcHJvbWlzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIC8vQHRzLWlnbm9yZVxuICAgIHJlc29sdmUsXG4gICAgLy9AdHMtaWdub3JlXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIGxpYi9jb21wb25lbnRzLnRzeFxudmFyIFJlYWN0MyA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcblxuLy8gbGliL2NvbnRleHQudHNcbnZhciBSZWFjdCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBEYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5EYXRhUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclwiO1xudmFyIERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuRGF0YVJvdXRlclN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclN0YXRlXCI7XG52YXIgVmlld1RyYW5zaXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGlzVHJhbnNpdGlvbmluZzogZmFsc2Vcbn0pO1xuVmlld1RyYW5zaXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJWaWV3VHJhbnNpdGlvblwiO1xudmFyIEZldGNoZXJzQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoXG4gIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbik7XG5GZXRjaGVyc0NvbnRleHQuZGlzcGxheU5hbWUgPSBcIkZldGNoZXJzXCI7XG52YXIgQXdhaXRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkF3YWl0Q29udGV4dC5kaXNwbGF5TmFtZSA9IFwiQXdhaXRcIjtcbnZhciBOYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoXG4gIG51bGxcbik7XG5OYXZpZ2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTmF2aWdhdGlvblwiO1xudmFyIExvY2F0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoXG4gIG51bGxcbik7XG5Mb2NhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkxvY2F0aW9uXCI7XG52YXIgUm91dGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIG91dGxldDogbnVsbCxcbiAgbWF0Y2hlczogW10sXG4gIGlzRGF0YVJvdXRlOiBmYWxzZVxufSk7XG5Sb3V0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlXCI7XG52YXIgUm91dGVFcnJvckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuUm91dGVFcnJvckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlRXJyb3JcIjtcbnZhciBFTkFCTEVfREVWX1dBUk5JTkdTID0gdHJ1ZTtcblxuLy8gbGliL2hvb2tzLnRzeFxudmFyIFJlYWN0MiA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIHVzZUhyZWYodG8sIHsgcmVsYXRpdmUgfSA9IHt9KSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZUhyZWYoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QyLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgeyBoYXNoLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmUgfSk7XG4gIGxldCBqb2luZWRQYXRobmFtZSA9IHBhdGhuYW1lO1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvci5jcmVhdGVIcmVmKHsgcGF0aG5hbWU6IGpvaW5lZFBhdGhuYW1lLCBzZWFyY2gsIGhhc2ggfSk7XG59XG5mdW5jdGlvbiB1c2VJblJvdXRlckNvbnRleHQoKSB7XG4gIHJldHVybiBSZWFjdDIudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpICE9IG51bGw7XG59XG5mdW5jdGlvbiB1c2VMb2NhdGlvbigpIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTG9jYXRpb24oKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcbiAgcmV0dXJuIFJlYWN0Mi51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubG9jYXRpb247XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0aW9uVHlwZSgpIHtcbiAgcmV0dXJuIFJlYWN0Mi51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubmF2aWdhdGlvblR5cGU7XG59XG5mdW5jdGlvbiB1c2VNYXRjaChwYXR0ZXJuKSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG4gIGxldCB7IHBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oXG4gICAgKCkgPT4gbWF0Y2hQYXRoKHBhdHRlcm4sIGRlY29kZVBhdGgocGF0aG5hbWUpKSxcbiAgICBbcGF0aG5hbWUsIHBhdHRlcm5dXG4gICk7XG59XG52YXIgbmF2aWdhdGVFZmZlY3RXYXJuaW5nID0gYFlvdSBzaG91bGQgY2FsbCBuYXZpZ2F0ZSgpIGluIGEgUmVhY3QudXNlRWZmZWN0KCksIG5vdCB3aGVuIHlvdXIgY29tcG9uZW50IGlzIGZpcnN0IHJlbmRlcmVkLmA7XG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGNiKSB7XG4gIGxldCBpc1N0YXRpYyA9IFJlYWN0Mi51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KS5zdGF0aWM7XG4gIGlmICghaXNTdGF0aWMpIHtcbiAgICBSZWFjdDIudXNlTGF5b3V0RWZmZWN0KGNiKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGUoKSB7XG4gIGxldCB7IGlzRGF0YVJvdXRlIH0gPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICByZXR1cm4gaXNEYXRhUm91dGUgPyB1c2VOYXZpZ2F0ZVN0YWJsZSgpIDogdXNlTmF2aWdhdGVVbnN0YWJsZSgpO1xufVxuZnVuY3Rpb24gdXNlTmF2aWdhdGVVbnN0YWJsZSgpIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTmF2aWdhdGUoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QyLnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBsZXQgeyBiYXNlbmFtZSwgbmF2aWdhdG9yIH0gPSBSZWFjdDIudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzKSk7XG4gIGxldCBhY3RpdmVSZWYgPSBSZWFjdDIudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcbiAgbGV0IG5hdmlnYXRlID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgICh0bywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICB3YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcpO1xuICAgICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBuYXZpZ2F0b3IuZ28odG8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgcGF0aCA9IHJlc29sdmVUbyhcbiAgICAgICAgdG8sXG4gICAgICAgIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSxcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZSxcbiAgICAgICAgb3B0aW9ucy5yZWxhdGl2ZSA9PT0gXCJwYXRoXCJcbiAgICAgICk7XG4gICAgICBpZiAoZGF0YVJvdXRlckNvbnRleHQgPT0gbnVsbCAmJiBiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gICAgICB9XG4gICAgICAoISFvcHRpb25zLnJlcGxhY2UgPyBuYXZpZ2F0b3IucmVwbGFjZSA6IG5hdmlnYXRvci5wdXNoKShcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb3B0aW9ucy5zdGF0ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICB9LFxuICAgIFtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgbmF2aWdhdG9yLFxuICAgICAgcm91dGVQYXRobmFtZXNKc29uLFxuICAgICAgbG9jYXRpb25QYXRobmFtZSxcbiAgICAgIGRhdGFSb3V0ZXJDb250ZXh0XG4gICAgXVxuICApO1xuICByZXR1cm4gbmF2aWdhdGU7XG59XG52YXIgT3V0bGV0Q29udGV4dCA9IFJlYWN0Mi5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0Mi51c2VDb250ZXh0KE91dGxldENvbnRleHQpO1xufVxuZnVuY3Rpb24gdXNlT3V0bGV0KGNvbnRleHQpIHtcbiAgbGV0IG91dGxldCA9IFJlYWN0Mi51c2VDb250ZXh0KFJvdXRlQ29udGV4dCkub3V0bGV0O1xuICBpZiAob3V0bGV0KSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChPdXRsZXRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIG91dGxldCk7XG4gIH1cbiAgcmV0dXJuIG91dGxldDtcbn1cbmZ1bmN0aW9uIHVzZVBhcmFtcygpIHtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXJhbXMgOiB7fTtcbn1cbmZ1bmN0aW9uIHVzZVJlc29sdmVkUGF0aCh0bywgeyByZWxhdGl2ZSB9ID0ge30pIHtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHsgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShnZXRSZXNvbHZlVG9NYXRjaGVzKG1hdGNoZXMpKTtcbiAgcmV0dXJuIFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+IHJlc29sdmVUbyhcbiAgICAgIHRvLFxuICAgICAgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLFxuICAgICAgbG9jYXRpb25QYXRobmFtZSxcbiAgICAgIHJlbGF0aXZlID09PSBcInBhdGhcIlxuICAgICksXG4gICAgW3RvLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWUsIHJlbGF0aXZlXVxuICApO1xufVxuZnVuY3Rpb24gdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcpIHtcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZyk7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgbG9jYXRpb25BcmcsIGRhdGFSb3V0ZXJTdGF0ZSwgZnV0dXJlKSB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZVJvdXRlcygpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuICBsZXQgeyBuYXZpZ2F0b3IgfSA9IFJlYWN0Mi51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgbWF0Y2hlczogcGFyZW50TWF0Y2hlcyB9ID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBwYXJlbnRNYXRjaGVzW3BhcmVudE1hdGNoZXMubGVuZ3RoIC0gMV07XG4gIGxldCBwYXJlbnRQYXJhbXMgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXJhbXMgOiB7fTtcbiAgbGV0IHBhcmVudFBhdGhuYW1lID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWUgOiBcIi9cIjtcbiAgbGV0IHBhcmVudFBhdGhuYW1lQmFzZSA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhdGhuYW1lQmFzZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50Um91dGUgPSByb3V0ZU1hdGNoICYmIHJvdXRlTWF0Y2gucm91dGU7XG4gIGlmIChFTkFCTEVfREVWX1dBUk5JTkdTKSB7XG4gICAgbGV0IHBhcmVudFBhdGggPSBwYXJlbnRSb3V0ZSAmJiBwYXJlbnRSb3V0ZS5wYXRoIHx8IFwiXCI7XG4gICAgd2FybmluZ09uY2UoXG4gICAgICBwYXJlbnRQYXRobmFtZSxcbiAgICAgICFwYXJlbnRSb3V0ZSB8fCBwYXJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSB8fCBwYXJlbnRQYXRoLmVuZHNXaXRoKFwiKj9cIiksXG4gICAgICBgWW91IHJlbmRlcmVkIGRlc2NlbmRhbnQgPFJvdXRlcz4gKG9yIGNhbGxlZCBcXGB1c2VSb3V0ZXMoKVxcYCkgYXQgXCIke3BhcmVudFBhdGhuYW1lfVwiICh1bmRlciA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aH1cIj4pIGJ1dCB0aGUgcGFyZW50IHJvdXRlIHBhdGggaGFzIG5vIHRyYWlsaW5nIFwiKlwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBkZWVwZXIsIHRoZSBwYXJlbnQgd29uJ3QgbWF0Y2ggYW55bW9yZSBhbmQgdGhlcmVmb3JlIHRoZSBjaGlsZCByb3V0ZXMgd2lsbCBuZXZlciByZW5kZXIuXG5cblBsZWFzZSBjaGFuZ2UgdGhlIHBhcmVudCA8Um91dGUgcGF0aD1cIiR7cGFyZW50UGF0aH1cIj4gdG8gPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGggPT09IFwiL1wiID8gXCIqXCIgOiBgJHtwYXJlbnRQYXRofS8qYH1cIj4uYFxuICAgICk7XG4gIH1cbiAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbG9jYXRpb247XG4gIGlmIChsb2NhdGlvbkFyZykge1xuICAgIGxldCBwYXJzZWRMb2NhdGlvbkFyZyA9IHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcbiAgICBpbnZhcmlhbnQoXG4gICAgICBwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiIHx8IHBhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lPy5zdGFydHNXaXRoKHBhcmVudFBhdGhuYW1lQmFzZSksXG4gICAgICBgV2hlbiBvdmVycmlkaW5nIHRoZSBsb2NhdGlvbiB1c2luZyBcXGA8Um91dGVzIGxvY2F0aW9uPlxcYCBvciBcXGB1c2VSb3V0ZXMocm91dGVzLCBsb2NhdGlvbilcXGAsIHRoZSBsb2NhdGlvbiBwYXRobmFtZSBtdXN0IGJlZ2luIHdpdGggdGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFwiJHtwYXJlbnRQYXRobmFtZUJhc2V9XCIgYnV0IHBhdGhuYW1lIFwiJHtwYXJzZWRMb2NhdGlvbkFyZy5wYXRobmFtZX1cIiB3YXMgZ2l2ZW4gaW4gdGhlIFxcYGxvY2F0aW9uXFxgIHByb3AuYFxuICAgICk7XG4gICAgbG9jYXRpb24gPSBwYXJzZWRMb2NhdGlvbkFyZztcbiAgfSBlbHNlIHtcbiAgICBsb2NhdGlvbiA9IGxvY2F0aW9uRnJvbUNvbnRleHQ7XG4gIH1cbiAgbGV0IHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCI7XG4gIGxldCByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lO1xuICBpZiAocGFyZW50UGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgIGxldCBwYXJlbnRTZWdtZW50cyA9IHBhcmVudFBhdGhuYW1lQmFzZS5yZXBsYWNlKC9eXFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIGxldCBzZWdtZW50cyA9IHBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgcmVtYWluaW5nUGF0aG5hbWUgPSBcIi9cIiArIHNlZ21lbnRzLnNsaWNlKHBhcmVudFNlZ21lbnRzLmxlbmd0aCkuam9pbihcIi9cIik7XG4gIH1cbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHsgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lIH0pO1xuICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUykge1xuICAgIHdhcm5pbmcoXG4gICAgICBwYXJlbnRSb3V0ZSB8fCBtYXRjaGVzICE9IG51bGwsXG4gICAgICBgTm8gcm91dGVzIG1hdGNoZWQgbG9jYXRpb24gXCIke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofSR7bG9jYXRpb24uaGFzaH1cIiBgXG4gICAgKTtcbiAgICB3YXJuaW5nKFxuICAgICAgbWF0Y2hlcyA9PSBudWxsIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5lbGVtZW50ICE9PSB2b2lkIDAgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLkNvbXBvbmVudCAhPT0gdm9pZCAwIHx8IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXS5yb3V0ZS5sYXp5ICE9PSB2b2lkIDAsXG4gICAgICBgTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFwiJHtsb2NhdGlvbi5wYXRobmFtZX0ke2xvY2F0aW9uLnNlYXJjaH0ke2xvY2F0aW9uLmhhc2h9XCIgZG9lcyBub3QgaGF2ZSBhbiBlbGVtZW50IG9yIENvbXBvbmVudC4gVGhpcyBtZWFucyBpdCB3aWxsIHJlbmRlciBhbiA8T3V0bGV0IC8+IHdpdGggYSBudWxsIHZhbHVlIGJ5IGRlZmF1bHQgcmVzdWx0aW5nIGluIGFuIFwiZW1wdHlcIiBwYWdlLmBcbiAgICApO1xuICB9XG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBfcmVuZGVyTWF0Y2hlcyhcbiAgICBtYXRjaGVzICYmIG1hdGNoZXMubWFwKFxuICAgICAgKG1hdGNoKSA9PiBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCwge1xuICAgICAgICBwYXJhbXM6IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudFBhcmFtcywgbWF0Y2gucGFyYW1zKSxcbiAgICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbXG4gICAgICAgICAgcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgICAgICAgIC8vIFJlLWVuY29kZSBwYXRobmFtZXMgdGhhdCB3ZXJlIGRlY29kZWQgaW5zaWRlIG1hdGNoUm91dGVzXG4gICAgICAgICAgbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKG1hdGNoLnBhdGhuYW1lKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lXG4gICAgICAgIF0pLFxuICAgICAgICBwYXRobmFtZUJhc2U6IG1hdGNoLnBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgPyBwYXJlbnRQYXRobmFtZUJhc2UgOiBqb2luUGF0aHMoW1xuICAgICAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSxcbiAgICAgICAgICAvLyBSZS1lbmNvZGUgcGF0aG5hbWVzIHRoYXQgd2VyZSBkZWNvZGVkIGluc2lkZSBtYXRjaFJvdXRlc1xuICAgICAgICAgIG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihtYXRjaC5wYXRobmFtZUJhc2UpLnBhdGhuYW1lIDogbWF0Y2gucGF0aG5hbWVCYXNlXG4gICAgICAgIF0pXG4gICAgICB9KVxuICAgICksXG4gICAgcGFyZW50TWF0Y2hlcyxcbiAgICBkYXRhUm91dGVyU3RhdGUsXG4gICAgZnV0dXJlXG4gICk7XG4gIGlmIChsb2NhdGlvbkFyZyAmJiByZW5kZXJlZE1hdGNoZXMpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgICBwYXRobmFtZTogXCIvXCIsXG4gICAgICAgICAgICBzZWFyY2g6IFwiXCIsXG4gICAgICAgICAgICBoYXNoOiBcIlwiLFxuICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgICAgICBrZXk6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgLi4ubG9jYXRpb25cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hdmlnYXRpb25UeXBlOiBcIlBPUFwiIC8qIFBvcCAqL1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVuZGVyZWRNYXRjaGVzXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVuZGVyZWRNYXRjaGVzO1xufVxuZnVuY3Rpb24gRGVmYXVsdEVycm9yQ29tcG9uZW50KCkge1xuICBsZXQgZXJyb3IgPSB1c2VSb3V0ZUVycm9yKCk7XG4gIGxldCBtZXNzYWdlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpID8gYCR7ZXJyb3Iuc3RhdHVzfSAke2Vycm9yLnN0YXR1c1RleHR9YCA6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICBsZXQgc3RhY2sgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiBudWxsO1xuICBsZXQgbGlnaHRncmV5ID0gXCJyZ2JhKDIwMCwyMDAsMjAwLCAwLjUpXCI7XG4gIGxldCBwcmVTdHlsZXMgPSB7IHBhZGRpbmc6IFwiMC41cmVtXCIsIGJhY2tncm91bmRDb2xvcjogbGlnaHRncmV5IH07XG4gIGxldCBjb2RlU3R5bGVzID0geyBwYWRkaW5nOiBcIjJweCA0cHhcIiwgYmFja2dyb3VuZENvbG9yOiBsaWdodGdyZXkgfTtcbiAgbGV0IGRldkluZm8gPSBudWxsO1xuICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUykge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIkVycm9yIGhhbmRsZWQgYnkgUmVhY3QgUm91dGVyIGRlZmF1bHQgRXJyb3JCb3VuZGFyeTpcIixcbiAgICAgIGVycm9yXG4gICAgKTtcbiAgICBkZXZJbmZvID0gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJlYWN0Mi5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIlxcdXsxRjRCRn0gSGV5IGRldmVsb3BlciBcXHV7MUY0NEJ9XCIpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXCJwXCIsIG51bGwsIFwiWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgd2hlbiB5b3VyIGFwcCB0aHJvd3MgZXJyb3JzIGJ5IHByb3ZpZGluZyB5b3VyIG93biBcIiwgLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwiY29kZVwiLCB7IHN0eWxlOiBjb2RlU3R5bGVzIH0sIFwiRXJyb3JCb3VuZGFyeVwiKSwgXCIgb3JcIiwgXCIgXCIsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgeyBzdHlsZTogY29kZVN0eWxlcyB9LCBcImVycm9yRWxlbWVudFwiKSwgXCIgcHJvcCBvbiB5b3VyIHJvdXRlLlwiKSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSZWFjdDIuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcImgyXCIsIG51bGwsIFwiVW5leHBlY3RlZCBBcHBsaWNhdGlvbiBFcnJvciFcIiksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcImgzXCIsIHsgc3R5bGU6IHsgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0gfSwgbWVzc2FnZSksIHN0YWNrID8gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHsgc3R5bGU6IHByZVN0eWxlcyB9LCBzdGFjaykgOiBudWxsLCBkZXZJbmZvKTtcbn1cbnZhciBkZWZhdWx0RXJyb3JFbGVtZW50ID0gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KERlZmF1bHRFcnJvckNvbXBvbmVudCwgbnVsbCk7XG52YXIgUmVuZGVyRXJyb3JCb3VuZGFyeSA9IGNsYXNzIGV4dGVuZHMgUmVhY3QyLkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbixcbiAgICAgIGVycm9yOiBwcm9wcy5lcnJvclxuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUubG9jYXRpb24gIT09IHByb3BzLmxvY2F0aW9uIHx8IHN0YXRlLnJldmFsaWRhdGlvbiAhPT0gXCJpZGxlXCIgJiYgcHJvcHMucmV2YWxpZGF0aW9uID09PSBcImlkbGVcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHByb3BzLmVycm9yLFxuICAgICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24sXG4gICAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHByb3BzLmVycm9yICE9PSB2b2lkIDAgPyBwcm9wcy5lcnJvciA6IHN0YXRlLmVycm9yLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgcmV2YWxpZGF0aW9uOiBwcm9wcy5yZXZhbGlkYXRpb24gfHwgc3RhdGUucmV2YWxpZGF0aW9uXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiUmVhY3QgUm91dGVyIGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIixcbiAgICAgIGVycm9yLFxuICAgICAgZXJyb3JJbmZvXG4gICAgKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgIT09IHZvaWQgMCA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMucHJvcHMucm91dGVDb250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgIFJvdXRlRXJyb3JDb250ZXh0LlByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICB2YWx1ZTogdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY29tcG9uZW50XG4gICAgICB9XG4gICAgKSkgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59O1xuZnVuY3Rpb24gUmVuZGVyZWRSb3V0ZSh7IHJvdXRlQ29udGV4dCwgbWF0Y2gsIGNoaWxkcmVuIH0pIHtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QyLnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICBpZiAoZGF0YVJvdXRlckNvbnRleHQgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljICYmIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQgJiYgKG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5KSkge1xuICAgIGRhdGFSb3V0ZXJDb250ZXh0LnN0YXRpY0NvbnRleHQuX2RlZXBlc3RSZW5kZXJlZEJvdW5kYXJ5SWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFJvdXRlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcm91dGVDb250ZXh0IH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMsIHBhcmVudE1hdGNoZXMgPSBbXSwgZGF0YVJvdXRlclN0YXRlID0gbnVsbCwgZnV0dXJlID0gbnVsbCkge1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgaWYgKCFkYXRhUm91dGVyU3RhdGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlLmVycm9ycykge1xuICAgICAgbWF0Y2hlcyA9IGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzO1xuICAgIH0gZWxzZSBpZiAocGFyZW50TWF0Y2hlcy5sZW5ndGggPT09IDAgJiYgIWRhdGFSb3V0ZXJTdGF0ZS5pbml0aWFsaXplZCAmJiBkYXRhUm91dGVyU3RhdGUubWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBtYXRjaGVzID0gZGF0YVJvdXRlclN0YXRlLm1hdGNoZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBsZXQgcmVuZGVyZWRNYXRjaGVzID0gbWF0Y2hlcztcbiAgbGV0IGVycm9ycyA9IGRhdGFSb3V0ZXJTdGF0ZT8uZXJyb3JzO1xuICBpZiAoZXJyb3JzICE9IG51bGwpIHtcbiAgICBsZXQgZXJyb3JJbmRleCA9IHJlbmRlcmVkTWF0Y2hlcy5maW5kSW5kZXgoXG4gICAgICAobSkgPT4gbS5yb3V0ZS5pZCAmJiBlcnJvcnM/LlttLnJvdXRlLmlkXSAhPT0gdm9pZCAwXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBlcnJvckluZGV4ID49IDAsXG4gICAgICBgQ291bGQgbm90IGZpbmQgYSBtYXRjaGluZyByb3V0ZSBmb3IgZXJyb3JzIG9uIHJvdXRlIElEczogJHtPYmplY3Qua2V5cyhcbiAgICAgICAgZXJyb3JzXG4gICAgICApLmpvaW4oXCIsXCIpfWBcbiAgICApO1xuICAgIHJlbmRlcmVkTWF0Y2hlcyA9IHJlbmRlcmVkTWF0Y2hlcy5zbGljZShcbiAgICAgIDAsXG4gICAgICBNYXRoLm1pbihyZW5kZXJlZE1hdGNoZXMubGVuZ3RoLCBlcnJvckluZGV4ICsgMSlcbiAgICApO1xuICB9XG4gIGxldCByZW5kZXJGYWxsYmFjayA9IGZhbHNlO1xuICBsZXQgZmFsbGJhY2tJbmRleCA9IC0xO1xuICBpZiAoZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlZE1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBtYXRjaCA9IHJlbmRlcmVkTWF0Y2hlc1tpXTtcbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5IeWRyYXRlRmFsbGJhY2sgfHwgbWF0Y2gucm91dGUuaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCkge1xuICAgICAgICBmYWxsYmFja0luZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCkge1xuICAgICAgICBsZXQgeyBsb2FkZXJEYXRhLCBlcnJvcnM6IGVycm9yczIgfSA9IGRhdGFSb3V0ZXJTdGF0ZTtcbiAgICAgICAgbGV0IG5lZWRzVG9SdW5Mb2FkZXIgPSBtYXRjaC5yb3V0ZS5sb2FkZXIgJiYgIWxvYWRlckRhdGEuaGFzT3duUHJvcGVydHkobWF0Y2gucm91dGUuaWQpICYmICghZXJyb3JzMiB8fCBlcnJvcnMyW21hdGNoLnJvdXRlLmlkXSA9PT0gdm9pZCAwKTtcbiAgICAgICAgaWYgKG1hdGNoLnJvdXRlLmxhenkgfHwgbmVlZHNUb1J1bkxvYWRlcikge1xuICAgICAgICAgIHJlbmRlckZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZmFsbGJhY2tJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZW5kZXJlZE1hdGNoZXMgPSByZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgZmFsbGJhY2tJbmRleCArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlZE1hdGNoZXMgPSBbcmVuZGVyZWRNYXRjaGVzWzBdXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcy5yZWR1Y2VSaWdodCgob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IGZhbHNlO1xuICAgIGxldCBlcnJvckVsZW1lbnQgPSBudWxsO1xuICAgIGxldCBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbnVsbDtcbiAgICBpZiAoZGF0YVJvdXRlclN0YXRlKSB7XG4gICAgICBlcnJvciA9IGVycm9ycyAmJiBtYXRjaC5yb3V0ZS5pZCA/IGVycm9yc1ttYXRjaC5yb3V0ZS5pZF0gOiB2b2lkIDA7XG4gICAgICBlcnJvckVsZW1lbnQgPSBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgZGVmYXVsdEVycm9yRWxlbWVudDtcbiAgICAgIGlmIChyZW5kZXJGYWxsYmFjaykge1xuICAgICAgICBpZiAoZmFsbGJhY2tJbmRleCA8IDAgJiYgaW5kZXggPT09IDApIHtcbiAgICAgICAgICB3YXJuaW5nT25jZShcbiAgICAgICAgICAgIFwicm91dGUtZmFsbGJhY2tcIixcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJObyBgSHlkcmF0ZUZhbGxiYWNrYCBlbGVtZW50IHByb3ZpZGVkIHRvIHJlbmRlciBkdXJpbmcgaW5pdGlhbCBoeWRyYXRpb25cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgc2hvdWxkUmVuZGVySHlkcmF0ZUZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmYWxsYmFja0luZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgIHNob3VsZFJlbmRlckh5ZHJhdGVGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCA9IG1hdGNoLnJvdXRlLmh5ZHJhdGVGYWxsYmFja0VsZW1lbnQgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWF0Y2hlczIgPSBwYXJlbnRNYXRjaGVzLmNvbmNhdChyZW5kZXJlZE1hdGNoZXMuc2xpY2UoMCwgaW5kZXggKyAxKSk7XG4gICAgbGV0IGdldENoaWxkcmVuID0gKCkgPT4ge1xuICAgICAgbGV0IGNoaWxkcmVuO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZXJyb3JFbGVtZW50O1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2spIHtcbiAgICAgICAgY2hpbGRyZW4gPSBoeWRyYXRlRmFsbGJhY2tFbGVtZW50O1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC5yb3V0ZS5Db21wb25lbnQpIHtcbiAgICAgICAgY2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQobWF0Y2gucm91dGUuQ29tcG9uZW50LCBudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2gucm91dGUuZWxlbWVudCkge1xuICAgICAgICBjaGlsZHJlbiA9IG1hdGNoLnJvdXRlLmVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IG91dGxldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFJlbmRlcmVkUm91dGUsXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICByb3V0ZUNvbnRleHQ6IHtcbiAgICAgICAgICAgIG91dGxldCxcbiAgICAgICAgICAgIG1hdGNoZXM6IG1hdGNoZXMyLFxuICAgICAgICAgICAgaXNEYXRhUm91dGU6IGRhdGFSb3V0ZXJTdGF0ZSAhPSBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlblxuICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG4gICAgcmV0dXJuIGRhdGFSb3V0ZXJTdGF0ZSAmJiAobWF0Y2gucm91dGUuRXJyb3JCb3VuZGFyeSB8fCBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgaW5kZXggPT09IDApID8gLyogQF9fUFVSRV9fICovIFJlYWN0Mi5jcmVhdGVFbGVtZW50KFxuICAgICAgUmVuZGVyRXJyb3JCb3VuZGFyeSxcbiAgICAgIHtcbiAgICAgICAgbG9jYXRpb246IGRhdGFSb3V0ZXJTdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBkYXRhUm91dGVyU3RhdGUucmV2YWxpZGF0aW9uLFxuICAgICAgICBjb21wb25lbnQ6IGVycm9yRWxlbWVudCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGNoaWxkcmVuOiBnZXRDaGlsZHJlbigpLFxuICAgICAgICByb3V0ZUNvbnRleHQ6IHsgb3V0bGV0OiBudWxsLCBtYXRjaGVzOiBtYXRjaGVzMiwgaXNEYXRhUm91dGU6IHRydWUgfVxuICAgICAgfVxuICAgICkgOiBnZXRDaGlsZHJlbigpO1xuICB9LCBudWxsKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpIHtcbiAgcmV0dXJuIGAke2hvb2tOYW1lfSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZW4vbWFpbi9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuYDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0KGhvb2tOYW1lKSB7XG4gIGxldCBjdHggPSBSZWFjdDIudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGludmFyaWFudChjdHgsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZShob29rTmFtZSkge1xuICBsZXQgc3RhdGUgPSBSZWFjdDIudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgaW52YXJpYW50KHN0YXRlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlQ29udGV4dChob29rTmFtZSkge1xuICBsZXQgcm91dGUgPSBSZWFjdDIudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKTtcbiAgcmV0dXJuIHJvdXRlO1xufVxuZnVuY3Rpb24gdXNlQ3VycmVudFJvdXRlSWQoaG9va05hbWUpIHtcbiAgbGV0IHJvdXRlID0gdXNlUm91dGVDb250ZXh0KGhvb2tOYW1lKTtcbiAgbGV0IHRoaXNSb3V0ZSA9IHJvdXRlLm1hdGNoZXNbcm91dGUubWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgaW52YXJpYW50KFxuICAgIHRoaXNSb3V0ZS5yb3V0ZS5pZCxcbiAgICBgJHtob29rTmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFwiaWRcImBcbiAgKTtcbiAgcmV0dXJuIHRoaXNSb3V0ZS5yb3V0ZS5pZDtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlSWQoKSB7XG4gIHJldHVybiB1c2VDdXJyZW50Um91dGVJZChcInVzZVJvdXRlSWRcIiAvKiBVc2VSb3V0ZUlkICovKTtcbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb24oKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZU5hdmlnYXRpb25cIiAvKiBVc2VOYXZpZ2F0aW9uICovKTtcbiAgcmV0dXJuIHN0YXRlLm5hdmlnYXRpb247XG59XG5mdW5jdGlvbiB1c2VSZXZhbGlkYXRvcigpIHtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoXCJ1c2VSZXZhbGlkYXRvclwiIC8qIFVzZVJldmFsaWRhdG9yICovKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlUmV2YWxpZGF0b3JcIiAvKiBVc2VSZXZhbGlkYXRvciAqLyk7XG4gIGxldCByZXZhbGlkYXRlID0gUmVhY3QyLnVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBkYXRhUm91dGVyQ29udGV4dC5yb3V0ZXIucmV2YWxpZGF0ZSgpO1xuICB9LCBbZGF0YVJvdXRlckNvbnRleHQucm91dGVyXSk7XG4gIHJldHVybiBSZWFjdDIudXNlTWVtbyhcbiAgICAoKSA9PiAoeyByZXZhbGlkYXRlLCBzdGF0ZTogc3RhdGUucmV2YWxpZGF0aW9uIH0pLFxuICAgIFtyZXZhbGlkYXRlLCBzdGF0ZS5yZXZhbGlkYXRpb25dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXRjaGVzKCkge1xuICBsZXQgeyBtYXRjaGVzLCBsb2FkZXJEYXRhIH0gPSB1c2VEYXRhUm91dGVyU3RhdGUoXG4gICAgXCJ1c2VNYXRjaGVzXCIgLyogVXNlTWF0Y2hlcyAqL1xuICApO1xuICByZXR1cm4gUmVhY3QyLnVzZU1lbW8oXG4gICAgKCkgPT4gbWF0Y2hlcy5tYXAoKG0pID0+IGNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoKG0sIGxvYWRlckRhdGEpKSxcbiAgICBbbWF0Y2hlcywgbG9hZGVyRGF0YV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUxvYWRlckRhdGEoKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZUxvYWRlckRhdGFcIiAvKiBVc2VMb2FkZXJEYXRhICovKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChcInVzZUxvYWRlckRhdGFcIiAvKiBVc2VMb2FkZXJEYXRhICovKTtcbiAgcmV0dXJuIHN0YXRlLmxvYWRlckRhdGFbcm91dGVJZF07XG59XG5mdW5jdGlvbiB1c2VSb3V0ZUxvYWRlckRhdGEocm91dGVJZCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VSb3V0ZUxvYWRlckRhdGFcIiAvKiBVc2VSb3V0ZUxvYWRlckRhdGEgKi8pO1xuICByZXR1cm4gc3RhdGUubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbn1cbmZ1bmN0aW9uIHVzZUFjdGlvbkRhdGEoKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShcInVzZUFjdGlvbkRhdGFcIiAvKiBVc2VBY3Rpb25EYXRhICovKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChcInVzZUxvYWRlckRhdGFcIiAvKiBVc2VMb2FkZXJEYXRhICovKTtcbiAgcmV0dXJuIHN0YXRlLmFjdGlvbkRhdGEgPyBzdGF0ZS5hY3Rpb25EYXRhW3JvdXRlSWRdIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gdXNlUm91dGVFcnJvcigpIHtcbiAgbGV0IGVycm9yID0gUmVhY3QyLnVzZUNvbnRleHQoUm91dGVFcnJvckNvbnRleHQpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoXCJ1c2VSb3V0ZUVycm9yXCIgLyogVXNlUm91dGVFcnJvciAqLyk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoXCJ1c2VSb3V0ZUVycm9yXCIgLyogVXNlUm91dGVFcnJvciAqLyk7XG4gIGlmIChlcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIHJldHVybiBzdGF0ZS5lcnJvcnM/Lltyb3V0ZUlkXTtcbn1cbmZ1bmN0aW9uIHVzZUFzeW5jVmFsdWUoKSB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0Mi51c2VDb250ZXh0KEF3YWl0Q29udGV4dCk7XG4gIHJldHVybiB2YWx1ZT8uX2RhdGE7XG59XG5mdW5jdGlvbiB1c2VBc3luY0Vycm9yKCkge1xuICBsZXQgdmFsdWUgPSBSZWFjdDIudXNlQ29udGV4dChBd2FpdENvbnRleHQpO1xuICByZXR1cm4gdmFsdWU/Ll9lcnJvcjtcbn1cbnZhciBibG9ja2VySWQgPSAwO1xuZnVuY3Rpb24gdXNlQmxvY2tlcihzaG91bGRCbG9jaykge1xuICBsZXQgeyByb3V0ZXIsIGJhc2VuYW1lIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChcInVzZUJsb2NrZXJcIiAvKiBVc2VCbG9ja2VyICovKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKFwidXNlQmxvY2tlclwiIC8qIFVzZUJsb2NrZXIgKi8pO1xuICBsZXQgW2Jsb2NrZXJLZXksIHNldEJsb2NrZXJLZXldID0gUmVhY3QyLnVzZVN0YXRlKFwiXCIpO1xuICBsZXQgYmxvY2tlckZ1bmN0aW9uID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgIChhcmcpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygc2hvdWxkQmxvY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gISFzaG91bGRCbG9jaztcbiAgICAgIH1cbiAgICAgIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHtcbiAgICAgICAgcmV0dXJuIHNob3VsZEJsb2NrKGFyZyk7XG4gICAgICB9XG4gICAgICBsZXQgeyBjdXJyZW50TG9jYXRpb24sIG5leHRMb2NhdGlvbiwgaGlzdG9yeUFjdGlvbiB9ID0gYXJnO1xuICAgICAgcmV0dXJuIHNob3VsZEJsb2NrKHtcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiB7XG4gICAgICAgICAgLi4uY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgICB9LFxuICAgICAgICBuZXh0TG9jYXRpb246IHtcbiAgICAgICAgICAuLi5uZXh0TG9jYXRpb24sXG4gICAgICAgICAgcGF0aG5hbWU6IHN0cmlwQmFzZW5hbWUobmV4dExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbmV4dExvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgIH0sXG4gICAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW2Jhc2VuYW1lLCBzaG91bGRCbG9ja11cbiAgKTtcbiAgUmVhY3QyLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGtleSA9IFN0cmluZygrK2Jsb2NrZXJJZCk7XG4gICAgc2V0QmxvY2tlcktleShrZXkpO1xuICAgIHJldHVybiAoKSA9PiByb3V0ZXIuZGVsZXRlQmxvY2tlcihrZXkpO1xuICB9LCBbcm91dGVyXSk7XG4gIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyS2V5ICE9PSBcIlwiKSB7XG4gICAgICByb3V0ZXIuZ2V0QmxvY2tlcihibG9ja2VyS2V5LCBibG9ja2VyRnVuY3Rpb24pO1xuICAgIH1cbiAgfSwgW3JvdXRlciwgYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uXSk7XG4gIHJldHVybiBibG9ja2VyS2V5ICYmIHN0YXRlLmJsb2NrZXJzLmhhcyhibG9ja2VyS2V5KSA/IHN0YXRlLmJsb2NrZXJzLmdldChibG9ja2VyS2V5KSA6IElETEVfQkxPQ0tFUjtcbn1cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlU3RhYmxlKCkge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KFwidXNlTmF2aWdhdGVcIiAvKiBVc2VOYXZpZ2F0ZVN0YWJsZSAqLyk7XG4gIGxldCBpZCA9IHVzZUN1cnJlbnRSb3V0ZUlkKFwidXNlTmF2aWdhdGVcIiAvKiBVc2VOYXZpZ2F0ZVN0YWJsZSAqLyk7XG4gIGxldCBhY3RpdmVSZWYgPSBSZWFjdDIudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcbiAgbGV0IG5hdmlnYXRlID0gUmVhY3QyLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh0bywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICB3YXJuaW5nKGFjdGl2ZVJlZi5jdXJyZW50LCBuYXZpZ2F0ZUVmZmVjdFdhcm5pbmcpO1xuICAgICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByb3V0ZXIubmF2aWdhdGUodG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgcm91dGVyLm5hdmlnYXRlKHRvLCB7IGZyb21Sb3V0ZUlkOiBpZCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtyb3V0ZXIsIGlkXVxuICApO1xuICByZXR1cm4gbmF2aWdhdGU7XG59XG52YXIgYWxyZWFkeVdhcm5lZCA9IHt9O1xuZnVuY3Rpb24gd2FybmluZ09uY2Uoa2V5LCBjb25kLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZCAmJiAhYWxyZWFkeVdhcm5lZFtrZXldKSB7XG4gICAgYWxyZWFkeVdhcm5lZFtrZXldID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCBtZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvd2FybmluZ3MudHNcbnZhciBhbHJlYWR5V2FybmVkMiA9IHt9O1xuZnVuY3Rpb24gd2Fybk9uY2UoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uICYmICFhbHJlYWR5V2FybmVkMlttZXNzYWdlXSkge1xuICAgIGFscmVhZHlXYXJuZWQyW21lc3NhZ2VdID0gdHJ1ZTtcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gIH1cbn1cblxuLy8gbGliL2NvbXBvbmVudHMudHN4XG5mdW5jdGlvbiBtYXBSb3V0ZVByb3BlcnRpZXMocm91dGUpIHtcbiAgbGV0IHVwZGF0ZXMgPSB7XG4gICAgLy8gTm90ZTogdGhpcyBjaGVjayBhbHNvIG9jY3VycyBpbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4gc28gdXBkYXRlXG4gICAgLy8gdGhlcmUgaWYgeW91IGNoYW5nZSB0aGlzIC0tIHBsZWFzZSBhbmQgdGhhbmsgeW91IVxuICAgIGhhc0Vycm9yQm91bmRhcnk6IHJvdXRlLmhhc0Vycm9yQm91bmRhcnkgfHwgcm91dGUuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IHJvdXRlLmVycm9yRWxlbWVudCAhPSBudWxsXG4gIH07XG4gIGlmIChyb3V0ZS5Db21wb25lbnQpIHtcbiAgICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUykge1xuICAgICAgaWYgKHJvdXRlLmVsZW1lbnQpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgQ29tcG9uZW50YCBhbmQgYGVsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBgQ29tcG9uZW50YCB3aWxsIGJlIHVzZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBlbGVtZW50OiBSZWFjdDMuY3JlYXRlRWxlbWVudChyb3V0ZS5Db21wb25lbnQpLFxuICAgICAgQ29tcG9uZW50OiB2b2lkIDBcbiAgICB9KTtcbiAgfVxuICBpZiAocm91dGUuSHlkcmF0ZUZhbGxiYWNrKSB7XG4gICAgaWYgKEVOQUJMRV9ERVZfV0FSTklOR1MpIHtcbiAgICAgIGlmIChyb3V0ZS5oeWRyYXRlRmFsbGJhY2tFbGVtZW50KSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYEh5ZHJhdGVGYWxsYmFja2AgYW5kIGBoeWRyYXRlRmFsbGJhY2tFbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gYEh5ZHJhdGVGYWxsYmFja2Agd2lsbCBiZSB1c2VkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudDogUmVhY3QzLmNyZWF0ZUVsZW1lbnQocm91dGUuSHlkcmF0ZUZhbGxiYWNrKSxcbiAgICAgIEh5ZHJhdGVGYWxsYmFjazogdm9pZCAwXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJvdXRlLkVycm9yQm91bmRhcnkpIHtcbiAgICBpZiAoRU5BQkxFX0RFVl9XQVJOSU5HUykge1xuICAgICAgaWYgKHJvdXRlLmVycm9yRWxlbWVudCkge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiWW91IHNob3VsZCBub3QgaW5jbHVkZSBib3RoIGBFcnJvckJvdW5kYXJ5YCBhbmQgYGVycm9yRWxlbWVudGAgb24geW91ciByb3V0ZSAtIGBFcnJvckJvdW5kYXJ5YCB3aWxsIGJlIHVzZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih1cGRhdGVzLCB7XG4gICAgICBlcnJvckVsZW1lbnQ6IFJlYWN0My5jcmVhdGVFbGVtZW50KHJvdXRlLkVycm9yQm91bmRhcnkpLFxuICAgICAgRXJyb3JCb3VuZGFyeTogdm9pZCAwXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZXM7XG59XG52YXIgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzID0gW1xuICBcIkh5ZHJhdGVGYWxsYmFja1wiLFxuICBcImh5ZHJhdGVGYWxsYmFja0VsZW1lbnRcIlxuXTtcbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeVJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIHVuc3RhYmxlX2dldENvbnRleHQ6IG9wdHM/LnVuc3RhYmxlX2dldENvbnRleHQsXG4gICAgZnV0dXJlOiBvcHRzPy5mdXR1cmUsXG4gICAgaGlzdG9yeTogY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllczogb3B0cz8uaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsSW5kZXg6IG9wdHM/LmluaXRpYWxJbmRleFxuICAgIH0pLFxuICAgIGh5ZHJhdGlvbkRhdGE6IG9wdHM/Lmh5ZHJhdGlvbkRhdGEsXG4gICAgcm91dGVzLFxuICAgIGh5ZHJhdGlvblJvdXRlUHJvcGVydGllcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgZGF0YVN0cmF0ZWd5OiBvcHRzPy5kYXRhU3RyYXRlZ3ksXG4gICAgcGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb246IG9wdHM/LnBhdGNoUm91dGVzT25OYXZpZ2F0aW9uXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbnZhciBEZWZlcnJlZCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJyZXNvbHZlZFwiO1xuICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5yZWplY3QgPSAocmVhc29uKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIFJvdXRlclByb3ZpZGVyKHtcbiAgcm91dGVyLFxuICBmbHVzaFN5bmM6IHJlYWN0RG9tRmx1c2hTeW5jSW1wbFxufSkge1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QzLnVzZVN0YXRlKHJvdXRlci5zdGF0ZSk7XG4gIGxldCBbcGVuZGluZ1N0YXRlLCBzZXRQZW5kaW5nU3RhdGVdID0gUmVhY3QzLnVzZVN0YXRlKCk7XG4gIGxldCBbdnRDb250ZXh0LCBzZXRWdENvbnRleHRdID0gUmVhY3QzLnVzZVN0YXRlKHtcbiAgICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG4gIH0pO1xuICBsZXQgW3JlbmRlckRmZCwgc2V0UmVuZGVyRGZkXSA9IFJlYWN0My51c2VTdGF0ZSgpO1xuICBsZXQgW3RyYW5zaXRpb24sIHNldFRyYW5zaXRpb25dID0gUmVhY3QzLnVzZVN0YXRlKCk7XG4gIGxldCBbaW50ZXJydXB0aW9uLCBzZXRJbnRlcnJ1cHRpb25dID0gUmVhY3QzLnVzZVN0YXRlKCk7XG4gIGxldCBmZXRjaGVyRGF0YSA9IFJlYWN0My51c2VSZWYoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0My51c2VDYWxsYmFjayhcbiAgICAobmV3U3RhdGUsIHsgZGVsZXRlZEZldGNoZXJzLCBmbHVzaFN5bmMsIHZpZXdUcmFuc2l0aW9uT3B0cyB9KSA9PiB7XG4gICAgICBuZXdTdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChmZXRjaGVyLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGZldGNoZXIuZGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZmV0Y2hlckRhdGEuY3VycmVudC5zZXQoa2V5LCBmZXRjaGVyLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZWRGZXRjaGVycy5mb3JFYWNoKChrZXkpID0+IGZldGNoZXJEYXRhLmN1cnJlbnQuZGVsZXRlKGtleSkpO1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIGZsdXNoU3luYyA9PT0gZmFsc2UgfHwgcmVhY3REb21GbHVzaFN5bmNJbXBsICE9IG51bGwsXG4gICAgICAgICdZb3UgcHJvdmlkZWQgdGhlIGBmbHVzaFN5bmNgIG9wdGlvbiB0byBhIHJvdXRlciB1cGRhdGUsIGJ1dCB5b3UgYXJlIG5vdCB1c2luZyB0aGUgYDxSb3V0ZXJQcm92aWRlcj5gIGZyb20gYHJlYWN0LXJvdXRlci9kb21gIHNvIGBSZWFjdERPTS5mbHVzaFN5bmMoKWAgaXMgdW5hdmFpbGFibGUuICBQbGVhc2UgdXBkYXRlIHlvdXIgYXBwIHRvIGBpbXBvcnQgeyBSb3V0ZXJQcm92aWRlciB9IGZyb20gXCJyZWFjdC1yb3V0ZXIvZG9tXCJgIGFuZCBlbnN1cmUgeW91IGhhdmUgYHJlYWN0LWRvbWAgaW5zdGFsbGVkIGFzIGEgZGVwZW5kZW5jeSB0byB1c2UgdGhlIGBmbHVzaFN5bmNgIG9wdGlvbi4nXG4gICAgICApO1xuICAgICAgbGV0IGlzVmlld1RyYW5zaXRpb25BdmFpbGFibGUgPSByb3V0ZXIud2luZG93ICE9IG51bGwgJiYgcm91dGVyLndpbmRvdy5kb2N1bWVudCAhPSBudWxsICYmIHR5cGVvZiByb3V0ZXIud2luZG93LmRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICB2aWV3VHJhbnNpdGlvbk9wdHMgPT0gbnVsbCB8fCBpc1ZpZXdUcmFuc2l0aW9uQXZhaWxhYmxlLFxuICAgICAgICBcIllvdSBwcm92aWRlZCB0aGUgYHZpZXdUcmFuc2l0aW9uYCBvcHRpb24gdG8gYSByb3V0ZXIgdXBkYXRlLCBidXQgeW91IGRvIG5vdCBhcHBlYXIgdG8gYmUgcnVubmluZyBpbiBhIERPTSBlbnZpcm9ubWVudCBhcyBgd2luZG93LnN0YXJ0Vmlld1RyYW5zaXRpb25gIGlzIG5vdCBhdmFpbGFibGUuXCJcbiAgICAgICk7XG4gICAgICBpZiAoIXZpZXdUcmFuc2l0aW9uT3B0cyB8fCAhaXNWaWV3VHJhbnNpdGlvbkF2YWlsYWJsZSkge1xuICAgICAgICBpZiAocmVhY3REb21GbHVzaFN5bmNJbXBsICYmIGZsdXNoU3luYykge1xuICAgICAgICAgIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSZWFjdDMuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFjdERvbUZsdXNoU3luY0ltcGwgJiYgZmx1c2hTeW5jKSB7XG4gICAgICAgIHJlYWN0RG9tRmx1c2hTeW5jSW1wbCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHJlbmRlckRmZCAmJiByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgdHJhbnNpdGlvbi5za2lwVHJhbnNpdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICAgICAgZmx1c2hTeW5jOiB0cnVlLFxuICAgICAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdCA9IHJvdXRlci53aW5kb3cuZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgcmVhY3REb21GbHVzaFN5bmNJbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdC5maW5pc2hlZC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICByZWFjdERvbUZsdXNoU3luY0ltcGwoKCkgPT4ge1xuICAgICAgICAgICAgc2V0UmVuZGVyRGZkKHZvaWQgMCk7XG4gICAgICAgICAgICBzZXRUcmFuc2l0aW9uKHZvaWQgMCk7XG4gICAgICAgICAgICBzZXRQZW5kaW5nU3RhdGUodm9pZCAwKTtcbiAgICAgICAgICAgIHNldFZ0Q29udGV4dCh7IGlzVHJhbnNpdGlvbmluZzogZmFsc2UgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZWFjdERvbUZsdXNoU3luY0ltcGwoKCkgPT4gc2V0VHJhbnNpdGlvbih0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHJlbmRlckRmZCAmJiByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XG4gICAgICAgIHNldEludGVycnVwdGlvbih7XG4gICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRQZW5kaW5nU3RhdGUobmV3U3RhdGUpO1xuICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgICBmbHVzaFN5bmM6IGZhbHNlLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBuZXh0TG9jYXRpb246IHZpZXdUcmFuc2l0aW9uT3B0cy5uZXh0TG9jYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbcm91dGVyLndpbmRvdywgcmVhY3REb21GbHVzaFN5bmNJbXBsLCB0cmFuc2l0aW9uLCByZW5kZXJEZmRdXG4gICk7XG4gIFJlYWN0My51c2VMYXlvdXRFZmZlY3QoKCkgPT4gcm91dGVyLnN1YnNjcmliZShzZXRTdGF0ZSksIFtyb3V0ZXIsIHNldFN0YXRlXSk7XG4gIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmICF2dENvbnRleHQuZmx1c2hTeW5jKSB7XG4gICAgICBzZXRSZW5kZXJEZmQobmV3IERlZmVycmVkKCkpO1xuICAgIH1cbiAgfSwgW3Z0Q29udGV4dF0pO1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVuZGVyRGZkICYmIHBlbmRpbmdTdGF0ZSAmJiByb3V0ZXIud2luZG93KSB7XG4gICAgICBsZXQgbmV3U3RhdGUgPSBwZW5kaW5nU3RhdGU7XG4gICAgICBsZXQgcmVuZGVyUHJvbWlzZSA9IHJlbmRlckRmZC5wcm9taXNlO1xuICAgICAgbGV0IHRyYW5zaXRpb24yID0gcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgUmVhY3QzLnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgICAgYXdhaXQgcmVuZGVyUHJvbWlzZTtcbiAgICAgIH0pO1xuICAgICAgdHJhbnNpdGlvbjIuZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHNldFJlbmRlckRmZCh2b2lkIDApO1xuICAgICAgICBzZXRUcmFuc2l0aW9uKHZvaWQgMCk7XG4gICAgICAgIHNldFBlbmRpbmdTdGF0ZSh2b2lkIDApO1xuICAgICAgICBzZXRWdENvbnRleHQoeyBpc1RyYW5zaXRpb25pbmc6IGZhbHNlIH0pO1xuICAgICAgfSk7XG4gICAgICBzZXRUcmFuc2l0aW9uKHRyYW5zaXRpb24yKTtcbiAgICB9XG4gIH0sIFtwZW5kaW5nU3RhdGUsIHJlbmRlckRmZCwgcm91dGVyLndpbmRvd10pO1xuICBSZWFjdDMudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocmVuZGVyRGZkICYmIHBlbmRpbmdTdGF0ZSAmJiBzdGF0ZS5sb2NhdGlvbi5rZXkgPT09IHBlbmRpbmdTdGF0ZS5sb2NhdGlvbi5rZXkpIHtcbiAgICAgIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCBbcmVuZGVyRGZkLCB0cmFuc2l0aW9uLCBzdGF0ZS5sb2NhdGlvbiwgcGVuZGluZ1N0YXRlXSk7XG4gIFJlYWN0My51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZyAmJiBpbnRlcnJ1cHRpb24pIHtcbiAgICAgIHNldFBlbmRpbmdTdGF0ZShpbnRlcnJ1cHRpb24uc3RhdGUpO1xuICAgICAgc2V0VnRDb250ZXh0KHtcbiAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiB0cnVlLFxuICAgICAgICBmbHVzaFN5bmM6IGZhbHNlLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IGludGVycnVwdGlvbi5jdXJyZW50TG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogaW50ZXJydXB0aW9uLm5leHRMb2NhdGlvblxuICAgICAgfSk7XG4gICAgICBzZXRJbnRlcnJ1cHRpb24odm9pZCAwKTtcbiAgICB9XG4gIH0sIFt2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nLCBpbnRlcnJ1cHRpb25dKTtcbiAgbGV0IG5hdmlnYXRvciA9IFJlYWN0My51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlSHJlZjogcm91dGVyLmNyZWF0ZUhyZWYsXG4gICAgICBlbmNvZGVMb2NhdGlvbjogcm91dGVyLmVuY29kZUxvY2F0aW9uLFxuICAgICAgZ286IChuKSA9PiByb3V0ZXIubmF2aWdhdGUobiksXG4gICAgICBwdXNoOiAodG8sIHN0YXRlMiwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHN0YXRlOiBzdGF0ZTIsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cz8ucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KSxcbiAgICAgIHJlcGxhY2U6ICh0bywgc3RhdGUyLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgc3RhdGU6IHN0YXRlMixcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzPy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pXG4gICAgfTtcbiAgfSwgW3JvdXRlcl0pO1xuICBsZXQgYmFzZW5hbWUgPSByb3V0ZXIuYmFzZW5hbWUgfHwgXCIvXCI7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0My51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICByb3V0ZXIsXG4gICAgICBuYXZpZ2F0b3IsXG4gICAgICBzdGF0aWM6IGZhbHNlLFxuICAgICAgYmFzZW5hbWVcbiAgICB9KSxcbiAgICBbcm91dGVyLCBuYXZpZ2F0b3IsIGJhc2VuYW1lXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFJlYWN0My5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KERhdGFSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBkYXRhUm91dGVyQ29udGV4dCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogc3RhdGUgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KEZldGNoZXJzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZmV0Y2hlckRhdGEuY3VycmVudCB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoVmlld1RyYW5zaXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2dENvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgICAgbmF2aWdhdG9yXG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBNZW1vaXplZERhdGFSb3V0ZXMsXG4gICAgICB7XG4gICAgICAgIHJvdXRlczogcm91dGVyLnJvdXRlcyxcbiAgICAgICAgZnV0dXJlOiByb3V0ZXIuZnV0dXJlLFxuICAgICAgICBzdGF0ZVxuICAgICAgfVxuICAgIClcbiAgKSkpKSksIG51bGwpO1xufVxudmFyIE1lbW9pemVkRGF0YVJvdXRlcyA9IFJlYWN0My5tZW1vKERhdGFSb3V0ZXMpO1xuZnVuY3Rpb24gRGF0YVJvdXRlcyh7XG4gIHJvdXRlcyxcbiAgZnV0dXJlLFxuICBzdGF0ZVxufSkge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIHZvaWQgMCwgc3RhdGUsIGZ1dHVyZSk7XG59XG5mdW5jdGlvbiBNZW1vcnlSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxFbnRyaWVzLFxuICBpbml0aWFsSW5kZXhcbn0pIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdDMudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnkoe1xuICAgICAgaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsSW5kZXgsXG4gICAgICB2NUNvbXBhdDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QzLnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdDMudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlKSA9PiB7XG4gICAgICBSZWFjdDMuc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgIH0sXG4gICAgW3NldFN0YXRlSW1wbF1cbiAgKTtcbiAgUmVhY3QzLnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIE5hdmlnYXRlKHtcbiAgdG8sXG4gIHJlcGxhY2U6IHJlcGxhY2UyLFxuICBzdGF0ZSxcbiAgcmVsYXRpdmVcbn0pIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gICAgLy8gdGhlIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcbiAgbGV0IHsgc3RhdGljOiBpc1N0YXRpYyB9ID0gUmVhY3QzLnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICB3YXJuaW5nKFxuICAgICFpc1N0YXRpYyxcbiAgICBgPE5hdmlnYXRlPiBtdXN0IG5vdCBiZSB1c2VkIG9uIHRoZSBpbml0aWFsIHJlbmRlciBpbiBhIDxTdGF0aWNSb3V0ZXI+LiBUaGlzIGlzIGEgbm8tb3AsIGJ1dCB5b3Ugc2hvdWxkIG1vZGlmeSB5b3VyIGNvZGUgc28gdGhlIDxOYXZpZ2F0ZT4gaXMgb25seSBldmVyIHJlbmRlcmVkIGluIHJlc3BvbnNlIHRvIHNvbWUgdXNlciBpbnRlcmFjdGlvbiBvciBzdGF0ZSBjaGFuZ2UuYFxuICApO1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdDMudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgdG8sXG4gICAgZ2V0UmVzb2x2ZVRvTWF0Y2hlcyhtYXRjaGVzKSxcbiAgICBsb2NhdGlvblBhdGhuYW1lLFxuICAgIHJlbGF0aXZlID09PSBcInBhdGhcIlxuICApO1xuICBsZXQganNvblBhdGggPSBKU09OLnN0cmluZ2lmeShwYXRoKTtcbiAgUmVhY3QzLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbmF2aWdhdGUoSlNPTi5wYXJzZShqc29uUGF0aCksIHsgcmVwbGFjZTogcmVwbGFjZTIsIHN0YXRlLCByZWxhdGl2ZSB9KTtcbiAgfSwgW25hdmlnYXRlLCBqc29uUGF0aCwgcmVsYXRpdmUsIHJlcGxhY2UyLCBzdGF0ZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIE91dGxldChwcm9wcykge1xuICByZXR1cm4gdXNlT3V0bGV0KHByb3BzLmNvbnRleHQpO1xufVxuZnVuY3Rpb24gUm91dGUoX3Byb3BzKSB7XG4gIGludmFyaWFudChcbiAgICBmYWxzZSxcbiAgICBgQSA8Um91dGU+IGlzIG9ubHkgZXZlciB0byBiZSB1c2VkIGFzIHRoZSBjaGlsZCBvZiA8Um91dGVzPiBlbGVtZW50LCBuZXZlciByZW5kZXJlZCBkaXJlY3RseS4gUGxlYXNlIHdyYXAgeW91ciA8Um91dGU+IGluIGEgPFJvdXRlcz4uYFxuICApO1xufVxuZnVuY3Rpb24gUm91dGVyKHtcbiAgYmFzZW5hbWU6IGJhc2VuYW1lUHJvcCA9IFwiL1wiLFxuICBjaGlsZHJlbiA9IG51bGwsXG4gIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXG4gIG5hdmlnYXRpb25UeXBlID0gXCJQT1BcIiAvKiBQb3AgKi8sXG4gIG5hdmlnYXRvcixcbiAgc3RhdGljOiBzdGF0aWNQcm9wID0gZmFsc2Vcbn0pIHtcbiAgaW52YXJpYW50KFxuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICBgWW91IGNhbm5vdCByZW5kZXIgYSA8Um91dGVyPiBpbnNpZGUgYW5vdGhlciA8Um91dGVyPi4gWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuYFxuICApO1xuICBsZXQgYmFzZW5hbWUgPSBiYXNlbmFtZVByb3AucmVwbGFjZSgvXlxcLyovLCBcIi9cIik7XG4gIGxldCBuYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0My51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIG5hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogc3RhdGljUHJvcCxcbiAgICAgIGZ1dHVyZToge31cbiAgICB9KSxcbiAgICBbYmFzZW5hbWUsIG5hdmlnYXRvciwgc3RhdGljUHJvcF1cbiAgKTtcbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuICBsZXQge1xuICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIixcbiAgICBzdGF0ZSA9IG51bGwsXG4gICAga2V5ID0gXCJkZWZhdWx0XCJcbiAgfSA9IGxvY2F0aW9uUHJvcDtcbiAgbGV0IGxvY2F0aW9uQ29udGV4dCA9IFJlYWN0My51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKTtcbiAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgIHBhdGhuYW1lOiB0cmFpbGluZ1BhdGhuYW1lLFxuICAgICAgICBzZWFyY2gsXG4gICAgICAgIGhhc2gsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBrZXlcbiAgICAgIH0sXG4gICAgICBuYXZpZ2F0aW9uVHlwZVxuICAgIH07XG4gIH0sIFtiYXNlbmFtZSwgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCwgc3RhdGUsIGtleSwgbmF2aWdhdGlvblR5cGVdKTtcbiAgd2FybmluZyhcbiAgICBsb2NhdGlvbkNvbnRleHQgIT0gbnVsbCxcbiAgICBgPFJvdXRlciBiYXNlbmFtZT1cIiR7YmFzZW5hbWV9XCI+IGlzIG5vdCBhYmxlIHRvIG1hdGNoIHRoZSBVUkwgXCIke3BhdGhuYW1lfSR7c2VhcmNofSR7aGFzaH1cIiBiZWNhdXNlIGl0IGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIGJhc2VuYW1lLCBzbyB0aGUgPFJvdXRlcj4gd29uJ3QgcmVuZGVyIGFueXRoaW5nLmBcbiAgKTtcbiAgaWYgKGxvY2F0aW9uQ29udGV4dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChOYXZpZ2F0aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogbmF2aWdhdGlvbkNvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0My5jcmVhdGVFbGVtZW50KExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciwgeyBjaGlsZHJlbiwgdmFsdWU6IGxvY2F0aW9uQ29udGV4dCB9KSk7XG59XG5mdW5jdGlvbiBSb3V0ZXMoe1xuICBjaGlsZHJlbixcbiAgbG9jYXRpb25cbn0pIHtcbiAgcmV0dXJuIHVzZVJvdXRlcyhjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4pLCBsb2NhdGlvbik7XG59XG5mdW5jdGlvbiBBd2FpdCh7XG4gIGNoaWxkcmVuLFxuICBlcnJvckVsZW1lbnQsXG4gIHJlc29sdmVcbn0pIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChBd2FpdEVycm9yQm91bmRhcnksIHsgcmVzb2x2ZSwgZXJyb3JFbGVtZW50IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSZXNvbHZlQXdhaXQsIG51bGwsIGNoaWxkcmVuKSk7XG59XG52YXIgQXdhaXRFcnJvckJvdW5kYXJ5ID0gY2xhc3MgZXh0ZW5kcyBSZWFjdDMuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHsgZXJyb3I6IG51bGwgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiPEF3YWl0PiBjYXVnaHQgdGhlIGZvbGxvd2luZyBlcnJvciBkdXJpbmcgcmVuZGVyXCIsXG4gICAgICBlcnJvcixcbiAgICAgIGVycm9ySW5mb1xuICAgICk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IGNoaWxkcmVuLCBlcnJvckVsZW1lbnQsIHJlc29sdmUgfSA9IHRoaXMucHJvcHM7XG4gICAgbGV0IHByb21pc2UgPSBudWxsO1xuICAgIGxldCBzdGF0dXMgPSAwIC8qIHBlbmRpbmcgKi87XG4gICAgaWYgKCEocmVzb2x2ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICBzdGF0dXMgPSAxIC8qIHN1Y2Nlc3MgKi87XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9kYXRhXCIsIHsgZ2V0OiAoKSA9PiByZXNvbHZlIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgc3RhdHVzID0gMiAvKiBlcnJvciAqLztcbiAgICAgIGxldCByZW5kZXJFcnJvciA9IHRoaXMuc3RhdGUuZXJyb3I7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoKS5jYXRjaCgoKSA9PiB7XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHsgZ2V0OiAoKSA9PiB0cnVlIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHsgZ2V0OiAoKSA9PiByZW5kZXJFcnJvciB9KTtcbiAgICB9IGVsc2UgaWYgKHJlc29sdmUuX3RyYWNrZWQpIHtcbiAgICAgIHByb21pc2UgPSByZXNvbHZlO1xuICAgICAgc3RhdHVzID0gXCJfZXJyb3JcIiBpbiBwcm9taXNlID8gMiAvKiBlcnJvciAqLyA6IFwiX2RhdGFcIiBpbiBwcm9taXNlID8gMSAvKiBzdWNjZXNzICovIDogMCAvKiBwZW5kaW5nICovO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0dXMgPSAwIC8qIHBlbmRpbmcgKi87XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfdHJhY2tlZFwiLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIHByb21pc2UgPSByZXNvbHZlLnRoZW4oXG4gICAgICAgIChkYXRhMikgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2RhdGFcIiwgeyBnZXQ6ICgpID0+IGRhdGEyIH0pLFxuICAgICAgICAoZXJyb3IpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlLCBcIl9lcnJvclwiLCB7IGdldDogKCkgPT4gZXJyb3IgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IDIgLyogZXJyb3IgKi8gJiYgIWVycm9yRWxlbWVudCkge1xuICAgICAgdGhyb3cgcHJvbWlzZS5fZXJyb3I7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IDIgLyogZXJyb3IgKi8pIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoQXdhaXRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwcm9taXNlLCBjaGlsZHJlbjogZXJyb3JFbGVtZW50IH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAxIC8qIHN1Y2Nlc3MgKi8pIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QzLmNyZWF0ZUVsZW1lbnQoQXdhaXRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwcm9taXNlLCBjaGlsZHJlbiB9KTtcbiAgICB9XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufTtcbmZ1bmN0aW9uIFJlc29sdmVBd2FpdCh7XG4gIGNoaWxkcmVuXG59KSB7XG4gIGxldCBkYXRhMiA9IHVzZUFzeW5jVmFsdWUoKTtcbiAgbGV0IHRvUmVuZGVyID0gdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihkYXRhMikgOiBjaGlsZHJlbjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDMuY3JlYXRlRWxlbWVudChSZWFjdDMuRnJhZ21lbnQsIG51bGwsIHRvUmVuZGVyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50UGF0aCA9IFtdKSB7XG4gIGxldCByb3V0ZXMgPSBbXTtcbiAgUmVhY3QzLkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGlmICghUmVhY3QzLmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB0cmVlUGF0aCA9IFsuLi5wYXJlbnRQYXRoLCBpbmRleF07XG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUmVhY3QzLkZyYWdtZW50KSB7XG4gICAgICByb3V0ZXMucHVzaC5hcHBseShcbiAgICAgICAgcm91dGVzLFxuICAgICAgICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgdHJlZVBhdGgpXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBlbGVtZW50LnR5cGUgPT09IFJvdXRlLFxuICAgICAgYFske3R5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50LnR5cGUgOiBlbGVtZW50LnR5cGUubmFtZX1dIGlzIG5vdCBhIDxSb3V0ZT4gY29tcG9uZW50LiBBbGwgY29tcG9uZW50IGNoaWxkcmVuIG9mIDxSb3V0ZXM+IG11c3QgYmUgYSA8Um91dGU+IG9yIDxSZWFjdC5GcmFnbWVudD5gXG4gICAgKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhZWxlbWVudC5wcm9wcy5pbmRleCB8fCAhZWxlbWVudC5wcm9wcy5jaGlsZHJlbixcbiAgICAgIFwiQW4gaW5kZXggcm91dGUgY2Fubm90IGhhdmUgY2hpbGQgcm91dGVzLlwiXG4gICAgKTtcbiAgICBsZXQgcm91dGUgPSB7XG4gICAgICBpZDogZWxlbWVudC5wcm9wcy5pZCB8fCB0cmVlUGF0aC5qb2luKFwiLVwiKSxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGVsZW1lbnQucHJvcHMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZWxlbWVudCxcbiAgICAgIENvbXBvbmVudDogZWxlbWVudC5wcm9wcy5Db21wb25lbnQsXG4gICAgICBpbmRleDogZWxlbWVudC5wcm9wcy5pbmRleCxcbiAgICAgIHBhdGg6IGVsZW1lbnQucHJvcHMucGF0aCxcbiAgICAgIGxvYWRlcjogZWxlbWVudC5wcm9wcy5sb2FkZXIsXG4gICAgICBhY3Rpb246IGVsZW1lbnQucHJvcHMuYWN0aW9uLFxuICAgICAgaHlkcmF0ZUZhbGxiYWNrRWxlbWVudDogZWxlbWVudC5wcm9wcy5oeWRyYXRlRmFsbGJhY2tFbGVtZW50LFxuICAgICAgSHlkcmF0ZUZhbGxiYWNrOiBlbGVtZW50LnByb3BzLkh5ZHJhdGVGYWxsYmFjayxcbiAgICAgIGVycm9yRWxlbWVudDogZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQsXG4gICAgICBFcnJvckJvdW5kYXJ5OiBlbGVtZW50LnByb3BzLkVycm9yQm91bmRhcnksXG4gICAgICBoYXNFcnJvckJvdW5kYXJ5OiBlbGVtZW50LnByb3BzLmhhc0Vycm9yQm91bmRhcnkgPT09IHRydWUgfHwgZWxlbWVudC5wcm9wcy5FcnJvckJvdW5kYXJ5ICE9IG51bGwgfHwgZWxlbWVudC5wcm9wcy5lcnJvckVsZW1lbnQgIT0gbnVsbCxcbiAgICAgIHNob3VsZFJldmFsaWRhdGU6IGVsZW1lbnQucHJvcHMuc2hvdWxkUmV2YWxpZGF0ZSxcbiAgICAgIGhhbmRsZTogZWxlbWVudC5wcm9wcy5oYW5kbGUsXG4gICAgICBsYXp5OiBlbGVtZW50LnByb3BzLmxhenlcbiAgICB9O1xuICAgIGlmIChlbGVtZW50LnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICByb3V0ZS5jaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihcbiAgICAgICAgZWxlbWVudC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgdHJlZVBhdGhcbiAgICAgICk7XG4gICAgfVxuICAgIHJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgfSk7XG4gIHJldHVybiByb3V0ZXM7XG59XG52YXIgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuO1xuZnVuY3Rpb24gcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKTtcbn1cblxuLy8gbGliL2RvbS9saWIudHN4XG52YXIgUmVhY3QxMCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcblxuLy8gbGliL2RvbS9kb20udHNcbnZhciBkZWZhdWx0TWV0aG9kID0gXCJnZXRcIjtcbnZhciBkZWZhdWx0RW5jVHlwZSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5mdW5jdGlvbiBpc0h0bWxFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC50YWdOYW1lID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNCdXR0b25FbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYnV0dG9uXCI7XG59XG5mdW5jdGlvbiBpc0Zvcm1FbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZm9ybVwiO1xufVxuZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBpc0h0bWxFbGVtZW50KG9iamVjdCkgJiYgb2JqZWN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiO1xufVxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cbmZ1bmN0aW9uIHNob3VsZFByb2Nlc3NMaW5rQ2xpY2soZXZlbnQsIHRhcmdldCkge1xuICByZXR1cm4gZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIElnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAoIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiYgLy8gTGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgIWlzTW9kaWZpZWRFdmVudChldmVudCk7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXMoaW5pdCA9IFwiXCIpIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoXG4gICAgdHlwZW9mIGluaXQgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShpbml0KSB8fCBpbml0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zID8gaW5pdCA6IE9iamVjdC5rZXlzKGluaXQpLnJlZHVjZSgobWVtbzIsIGtleSkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gaW5pdFtrZXldO1xuICAgICAgcmV0dXJuIG1lbW8yLmNvbmNhdChcbiAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAoKHYpID0+IFtrZXksIHZdKSA6IFtba2V5LCB2YWx1ZV1dXG4gICAgICApO1xuICAgIH0sIFtdKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24obG9jYXRpb25TZWFyY2gsIGRlZmF1bHRTZWFyY2hQYXJhbXMpIHtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyhsb2NhdGlvblNlYXJjaCk7XG4gIGlmIChkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGlmICghc2VhcmNoUGFyYW1zLmhhcyhrZXkpKSB7XG4gICAgICAgIGRlZmF1bHRTZWFyY2hQYXJhbXMuZ2V0QWxsKGtleSkuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxudmFyIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gbnVsbDtcbmZ1bmN0aW9uIGlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQoKSB7XG4gIGlmIChfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9PT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRm9ybURhdGEoXG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGlmIEZvcm1EYXRhIHN1cHBvcnRzIHRoZSBzdWJtaXR0ZXIgcGFyYW1ldGVyLCB0aGlzIHdpbGwgdGhyb3dcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXI7XG59XG52YXIgc3VwcG9ydGVkRm9ybUVuY1R5cGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICBcIm11bHRpcGFydC9mb3JtLWRhdGFcIixcbiAgXCJ0ZXh0L3BsYWluXCJcbl0pO1xuZnVuY3Rpb24gZ2V0Rm9ybUVuY1R5cGUoZW5jVHlwZSkge1xuICBpZiAoZW5jVHlwZSAhPSBudWxsICYmICFzdXBwb3J0ZWRGb3JtRW5jVHlwZXMuaGFzKGVuY1R5cGUpKSB7XG4gICAgd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgYFwiJHtlbmNUeXBlfVwiIGlzIG5vdCBhIHZhbGlkIFxcYGVuY1R5cGVcXGAgZm9yIFxcYDxGb3JtPlxcYC9cXGA8ZmV0Y2hlci5Gb3JtPlxcYCBhbmQgd2lsbCBkZWZhdWx0IHRvIFwiJHtkZWZhdWx0RW5jVHlwZX1cImBcbiAgICApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBlbmNUeXBlO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKHRhcmdldCwgYmFzZW5hbWUpIHtcbiAgbGV0IG1ldGhvZDtcbiAgbGV0IGFjdGlvbjtcbiAgbGV0IGVuY1R5cGU7XG4gIGxldCBmb3JtRGF0YTtcbiAgbGV0IGJvZHk7XG4gIGlmIChpc0Zvcm1FbGVtZW50KHRhcmdldCkpIHtcbiAgICBsZXQgYXR0ciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgYWN0aW9uID0gYXR0ciA/IHN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcbiAgICBtZXRob2QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IGRlZmF1bHRNZXRob2Q7XG4gICAgZW5jVHlwZSA9IGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpKSB8fCBkZWZhdWx0RW5jVHlwZTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSh0YXJnZXQpO1xuICB9IGVsc2UgaWYgKGlzQnV0dG9uRWxlbWVudCh0YXJnZXQpIHx8IGlzSW5wdXRFbGVtZW50KHRhcmdldCkgJiYgKHRhcmdldC50eXBlID09PSBcInN1Ym1pdFwiIHx8IHRhcmdldC50eXBlID09PSBcImltYWdlXCIpKSB7XG4gICAgbGV0IGZvcm0gPSB0YXJnZXQuZm9ybTtcbiAgICBpZiAoZm9ybSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3Qgc3VibWl0IGEgPGJ1dHRvbj4gb3IgPGlucHV0IHR5cGU9XCJzdWJtaXRcIj4gd2l0aG91dCBhIDxmb3JtPmBcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCBhdHRyID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1hY3Rpb25cIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIik7XG4gICAgYWN0aW9uID0gYXR0ciA/IHN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcbiAgICBtZXRob2QgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xuICAgIGVuY1R5cGUgPSBnZXRGb3JtRW5jVHlwZSh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWVuY3R5cGVcIikpIHx8IGdldEZvcm1FbmNUeXBlKGZvcm0uZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSkgfHwgZGVmYXVsdEVuY1R5cGU7XG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSwgdGFyZ2V0KTtcbiAgICBpZiAoIWlzRm9ybURhdGFTdWJtaXR0ZXJTdXBwb3J0ZWQoKSkge1xuICAgICAgbGV0IHsgbmFtZSwgdHlwZSwgdmFsdWUgfSA9IHRhcmdldDtcbiAgICAgIGlmICh0eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IG5hbWUgPyBgJHtuYW1lfS5gIDogXCJcIjtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke3ByZWZpeH14YCwgXCIwXCIpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7cHJlZml4fXlgLCBcIjBcIik7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBzdWJtaXQgZWxlbWVudCB0aGF0IGlzIG5vdCA8Zm9ybT4sIDxidXR0b24+LCBvciA8aW5wdXQgdHlwZT1cInN1Ym1pdHxpbWFnZVwiPmBcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIG1ldGhvZCA9IGRlZmF1bHRNZXRob2Q7XG4gICAgYWN0aW9uID0gbnVsbDtcbiAgICBlbmNUeXBlID0gZGVmYXVsdEVuY1R5cGU7XG4gICAgYm9keSA9IHRhcmdldDtcbiAgfVxuICBpZiAoZm9ybURhdGEgJiYgZW5jVHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICBib2R5ID0gZm9ybURhdGE7XG4gICAgZm9ybURhdGEgPSB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHsgYWN0aW9uLCBtZXRob2Q6IG1ldGhvZC50b0xvd2VyQ2FzZSgpLCBlbmNUeXBlLCBmb3JtRGF0YSwgYm9keSB9O1xufVxuXG4vLyBsaWIvZG9tL3Nzci9jb21wb25lbnRzLnRzeFxudmFyIFJlYWN0OSA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcblxuLy8gbGliL2RvbS9zc3IvaW52YXJpYW50LnRzXG5mdW5jdGlvbiBpbnZhcmlhbnQyKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vIGxpYi9kb20vc3NyL3JvdXRlTW9kdWxlcy50c1xuYXN5bmMgZnVuY3Rpb24gbG9hZFJvdXRlTW9kdWxlKHJvdXRlLCByb3V0ZU1vZHVsZXNDYWNoZSkge1xuICBpZiAocm91dGUuaWQgaW4gcm91dGVNb2R1bGVzQ2FjaGUpIHtcbiAgICByZXR1cm4gcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdO1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gYXdhaXQgaW1wb3J0KFxuICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICAvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovXG4gICAgICByb3V0ZS5tb2R1bGVcbiAgICApO1xuICAgIHJvdXRlTW9kdWxlc0NhY2hlW3JvdXRlLmlkXSA9IHJvdXRlTW9kdWxlO1xuICAgIHJldHVybiByb3V0ZU1vZHVsZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYEVycm9yIGxvYWRpbmcgcm91dGUgbW9kdWxlIFxcYCR7cm91dGUubW9kdWxlfVxcYCwgcmVsb2FkaW5nIHBhZ2UuLi5gXG4gICAgKTtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICBpZiAod2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0ICYmIHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dC5pc1NwYU1vZGUgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHZvaWQgMCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGxpYi9kb20vc3NyL2xpbmtzLnRzXG5mdW5jdGlvbiBnZXRLZXllZExpbmtzRm9yTWF0Y2hlcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMsIG1hbmlmZXN0KSB7XG4gIGxldCBkZXNjcmlwdG9ycyA9IG1hdGNoZXMubWFwKChtYXRjaCkgPT4ge1xuICAgIGxldCBtb2R1bGUyID0gcm91dGVNb2R1bGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIHJldHVybiBbXG4gICAgICByb3V0ZSAmJiByb3V0ZS5jc3MgPyByb3V0ZS5jc3MubWFwKChocmVmMikgPT4gKHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZjogaHJlZjIgfSkpIDogW10sXG4gICAgICBtb2R1bGUyPy5saW5rcz8uKCkgfHwgW11cbiAgICBdO1xuICB9KS5mbGF0KDIpO1xuICBsZXQgcHJlbG9hZHMgPSBnZXRNb2R1bGVMaW5rSHJlZnMobWF0Y2hlcywgbWFuaWZlc3QpO1xuICByZXR1cm4gZGVkdXBlTGlua0Rlc2NyaXB0b3JzKGRlc2NyaXB0b3JzLCBwcmVsb2Fkcyk7XG59XG5mdW5jdGlvbiBnZXRSb3V0ZUNzc0Rlc2NyaXB0b3JzKHJvdXRlKSB7XG4gIGlmICghcm91dGUuY3NzKSByZXR1cm4gW107XG4gIHJldHVybiByb3V0ZS5jc3MubWFwKChocmVmMikgPT4gKHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZjogaHJlZjIgfSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hSb3V0ZUNzcyhyb3V0ZSkge1xuICBpZiAoIXJvdXRlLmNzcykgcmV0dXJuO1xuICBsZXQgZGVzY3JpcHRvcnMgPSBnZXRSb3V0ZUNzc0Rlc2NyaXB0b3JzKHJvdXRlKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoZGVzY3JpcHRvcnMubWFwKHByZWZldGNoU3R5bGVMaW5rKSk7XG59XG5hc3luYyBmdW5jdGlvbiBwcmVmZXRjaFN0eWxlTGlua3Mocm91dGUsIHJvdXRlTW9kdWxlKSB7XG4gIGlmICghcm91dGUuY3NzICYmICFyb3V0ZU1vZHVsZS5saW5rcyB8fCAhaXNQcmVsb2FkU3VwcG9ydGVkKCkpIHJldHVybjtcbiAgbGV0IGRlc2NyaXB0b3JzID0gW107XG4gIGlmIChyb3V0ZS5jc3MpIHtcbiAgICBkZXNjcmlwdG9ycy5wdXNoKC4uLmdldFJvdXRlQ3NzRGVzY3JpcHRvcnMocm91dGUpKTtcbiAgfVxuICBpZiAocm91dGVNb2R1bGUubGlua3MpIHtcbiAgICBkZXNjcmlwdG9ycy5wdXNoKC4uLnJvdXRlTW9kdWxlLmxpbmtzKCkpO1xuICB9XG4gIGlmIChkZXNjcmlwdG9ycy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgbGV0IHN0eWxlTGlua3MgPSBbXTtcbiAgZm9yIChsZXQgZGVzY3JpcHRvciBvZiBkZXNjcmlwdG9ycykge1xuICAgIGlmICghaXNQYWdlTGlua0Rlc2NyaXB0b3IoZGVzY3JpcHRvcikgJiYgZGVzY3JpcHRvci5yZWwgPT09IFwic3R5bGVzaGVldFwiKSB7XG4gICAgICBzdHlsZUxpbmtzLnB1c2goe1xuICAgICAgICAuLi5kZXNjcmlwdG9yLFxuICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICBhczogXCJzdHlsZVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXdhaXQgUHJvbWlzZS5hbGwoc3R5bGVMaW5rcy5tYXAocHJlZmV0Y2hTdHlsZUxpbmspKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVMaW5rKGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgaWYgKGRlc2NyaXB0b3IubWVkaWEgJiYgIXdpbmRvdy5tYXRjaE1lZGlhKGRlc2NyaXB0b3IubWVkaWEpLm1hdGNoZXMgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgIGBsaW5rW3JlbD1cInN0eWxlc2hlZXRcIl1baHJlZj1cIiR7ZGVzY3JpcHRvci5ocmVmfVwiXWBcbiAgICApKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgIH1cbiAgICBsZXQgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgIE9iamVjdC5hc3NpZ24obGluaywgZGVzY3JpcHRvcik7XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGluaygpIHtcbiAgICAgIGlmIChkb2N1bWVudC5oZWFkLmNvbnRhaW5zKGxpbmspKSB7XG4gICAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgICB9XG4gICAgfVxuICAgIGxpbmsub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVtb3ZlTGluaygpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgbGluay5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgcmVtb3ZlTGluaygpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc1BhZ2VMaW5rRGVzY3JpcHRvcihvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QucGFnZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzSHRtbExpbmtEZXNjcmlwdG9yKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG9iamVjdC5ocmVmID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqZWN0LnJlbCA9PT0gXCJwcmVsb2FkXCIgJiYgdHlwZW9mIG9iamVjdC5pbWFnZVNyY1NldCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqZWN0LmltYWdlU2l6ZXMgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QucmVsID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvYmplY3QuaHJlZiA9PT0gXCJzdHJpbmdcIjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEtleWVkUHJlZmV0Y2hMaW5rcyhtYXRjaGVzLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzKSB7XG4gIGxldCBsaW5rcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIG1hdGNoZXMubWFwKGFzeW5jIChtYXRjaCkgPT4ge1xuICAgICAgbGV0IHJvdXRlID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICBsZXQgbW9kID0gYXdhaXQgbG9hZFJvdXRlTW9kdWxlKHJvdXRlLCByb3V0ZU1vZHVsZXMpO1xuICAgICAgICByZXR1cm4gbW9kLmxpbmtzID8gbW9kLmxpbmtzKCkgOiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9KVxuICApO1xuICByZXR1cm4gZGVkdXBlTGlua0Rlc2NyaXB0b3JzKFxuICAgIGxpbmtzLmZsYXQoMSkuZmlsdGVyKGlzSHRtbExpbmtEZXNjcmlwdG9yKS5maWx0ZXIoKGxpbmspID0+IGxpbmsucmVsID09PSBcInN0eWxlc2hlZXRcIiB8fCBsaW5rLnJlbCA9PT0gXCJwcmVsb2FkXCIpLm1hcChcbiAgICAgIChsaW5rKSA9PiBsaW5rLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgPyB7IC4uLmxpbmssIHJlbDogXCJwcmVmZXRjaFwiLCBhczogXCJzdHlsZVwiIH0gOiB7IC4uLmxpbmssIHJlbDogXCJwcmVmZXRjaFwiIH1cbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBnZXROZXdNYXRjaGVzRm9yTGlua3MocGFnZSwgbmV4dE1hdGNoZXMsIGN1cnJlbnRNYXRjaGVzLCBtYW5pZmVzdCwgbG9jYXRpb24sIG1vZGUpIHtcbiAgbGV0IGlzTmV3ID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmICghY3VycmVudE1hdGNoZXNbaW5kZXhdKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gbWF0Y2gucm91dGUuaWQgIT09IGN1cnJlbnRNYXRjaGVzW2luZGV4XS5yb3V0ZS5pZDtcbiAgfTtcbiAgbGV0IG1hdGNoUGF0aENoYW5nZWQgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIHBhcmFtIGNoYW5nZSwgL3VzZXJzLzEyMyAtPiAvdXNlcnMvNDU2XG4gICAgICBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8IC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAgIC8vIGUuZy4gL2ZpbGVzL2ltYWdlcy9hdmF0YXIuanBnIC0+IGZpbGVzL2ZpbmFuY2VzLnhsc1xuICAgICAgY3VycmVudE1hdGNoZXNbaW5kZXhdLnJvdXRlLnBhdGg/LmVuZHNXaXRoKFwiKlwiKSAmJiBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucGFyYW1zW1wiKlwiXSAhPT0gbWF0Y2gucGFyYW1zW1wiKlwiXVxuICAgICk7XG4gIH07XG4gIGlmIChtb2RlID09PSBcImFzc2V0c1wiKSB7XG4gICAgcmV0dXJuIG5leHRNYXRjaGVzLmZpbHRlcihcbiAgICAgIChtYXRjaCwgaW5kZXgpID0+IGlzTmV3KG1hdGNoLCBpbmRleCkgfHwgbWF0Y2hQYXRoQ2hhbmdlZChtYXRjaCwgaW5kZXgpXG4gICAgKTtcbiAgfVxuICBpZiAobW9kZSA9PT0gXCJkYXRhXCIpIHtcbiAgICByZXR1cm4gbmV4dE1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICAgIGxldCBtYW5pZmVzdFJvdXRlID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGlmICghbWFuaWZlc3RSb3V0ZSB8fCAhbWFuaWZlc3RSb3V0ZS5oYXNMb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTmV3KG1hdGNoLCBpbmRleCkgfHwgbWF0Y2hQYXRoQ2hhbmdlZChtYXRjaCwgaW5kZXgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgICAgbGV0IHJvdXRlQ2hvaWNlID0gbWF0Y2gucm91dGUuc2hvdWxkUmV2YWxpZGF0ZSh7XG4gICAgICAgICAgY3VycmVudFVybDogbmV3IFVSTChcbiAgICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCxcbiAgICAgICAgICAgIHdpbmRvdy5vcmlnaW5cbiAgICAgICAgICApLFxuICAgICAgICAgIGN1cnJlbnRQYXJhbXM6IGN1cnJlbnRNYXRjaGVzWzBdPy5wYXJhbXMgfHwge30sXG4gICAgICAgICAgbmV4dFVybDogbmV3IFVSTChwYWdlLCB3aW5kb3cub3JpZ2luKSxcbiAgICAgICAgICBuZXh0UGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2Ygcm91dGVDaG9pY2UgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgcmV0dXJuIHJvdXRlQ2hvaWNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBnZXRNb2R1bGVMaW5rSHJlZnMobWF0Y2hlcywgbWFuaWZlc3QsIHsgaW5jbHVkZUh5ZHJhdGVGYWxsYmFjayB9ID0ge30pIHtcbiAgcmV0dXJuIGRlZHVwZUhyZWZzKFxuICAgIG1hdGNoZXMubWFwKChtYXRjaCkgPT4ge1xuICAgICAgbGV0IHJvdXRlID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGlmICghcm91dGUpIHJldHVybiBbXTtcbiAgICAgIGxldCBocmVmcyA9IFtyb3V0ZS5tb2R1bGVdO1xuICAgICAgaWYgKHJvdXRlLmNsaWVudEFjdGlvbk1vZHVsZSkge1xuICAgICAgICBocmVmcyA9IGhyZWZzLmNvbmNhdChyb3V0ZS5jbGllbnRBY3Rpb25Nb2R1bGUpO1xuICAgICAgfVxuICAgICAgaWYgKHJvdXRlLmNsaWVudExvYWRlck1vZHVsZSkge1xuICAgICAgICBocmVmcyA9IGhyZWZzLmNvbmNhdChyb3V0ZS5jbGllbnRMb2FkZXJNb2R1bGUpO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVIeWRyYXRlRmFsbGJhY2sgJiYgcm91dGUuaHlkcmF0ZUZhbGxiYWNrTW9kdWxlKSB7XG4gICAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmh5ZHJhdGVGYWxsYmFja01vZHVsZSk7XG4gICAgICB9XG4gICAgICBpZiAocm91dGUuaW1wb3J0cykge1xuICAgICAgICBocmVmcyA9IGhyZWZzLmNvbmNhdChyb3V0ZS5pbXBvcnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBocmVmcztcbiAgICB9KS5mbGF0KDEpXG4gICk7XG59XG5mdW5jdGlvbiBkZWR1cGVIcmVmcyhocmVmcykge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoaHJlZnMpXTtcbn1cbmZ1bmN0aW9uIHNvcnRLZXlzKG9iaikge1xuICBsZXQgc29ydGVkID0ge307XG4gIGxldCBrZXlzID0gT2JqZWN0LmtleXMob2JqKS5zb3J0KCk7XG4gIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgc29ydGVkW2tleV0gPSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gc29ydGVkO1xufVxuZnVuY3Rpb24gZGVkdXBlTGlua0Rlc2NyaXB0b3JzKGRlc2NyaXB0b3JzLCBwcmVsb2Fkcykge1xuICBsZXQgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IHByZWxvYWRzU2V0ID0gbmV3IFNldChwcmVsb2Fkcyk7XG4gIHJldHVybiBkZXNjcmlwdG9ycy5yZWR1Y2UoKGRlZHVwZWQsIGRlc2NyaXB0b3IpID0+IHtcbiAgICBsZXQgYWxyZWFkeU1vZHVsZVByZWxvYWQgPSBwcmVsb2FkcyAmJiAhaXNQYWdlTGlua0Rlc2NyaXB0b3IoZGVzY3JpcHRvcikgJiYgZGVzY3JpcHRvci5hcyA9PT0gXCJzY3JpcHRcIiAmJiBkZXNjcmlwdG9yLmhyZWYgJiYgcHJlbG9hZHNTZXQuaGFzKGRlc2NyaXB0b3IuaHJlZik7XG4gICAgaWYgKGFscmVhZHlNb2R1bGVQcmVsb2FkKSB7XG4gICAgICByZXR1cm4gZGVkdXBlZDtcbiAgICB9XG4gICAgbGV0IGtleSA9IEpTT04uc3RyaW5naWZ5KHNvcnRLZXlzKGRlc2NyaXB0b3IpKTtcbiAgICBpZiAoIXNldC5oYXMoa2V5KSkge1xuICAgICAgc2V0LmFkZChrZXkpO1xuICAgICAgZGVkdXBlZC5wdXNoKHsga2V5LCBsaW5rOiBkZXNjcmlwdG9yIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVkdXBlZDtcbiAgfSwgW10pO1xufVxudmFyIF9pc1ByZWxvYWRTdXBwb3J0ZWQ7XG5mdW5jdGlvbiBpc1ByZWxvYWRTdXBwb3J0ZWQoKSB7XG4gIGlmIChfaXNQcmVsb2FkU3VwcG9ydGVkICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gX2lzUHJlbG9hZFN1cHBvcnRlZDtcbiAgfVxuICBsZXQgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgX2lzUHJlbG9hZFN1cHBvcnRlZCA9IGVsLnJlbExpc3Quc3VwcG9ydHMoXCJwcmVsb2FkXCIpO1xuICBlbCA9IG51bGw7XG4gIHJldHVybiBfaXNQcmVsb2FkU3VwcG9ydGVkO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9tYXJrdXAudHNcbnZhciBFU0NBUEVfTE9PS1VQID0ge1xuICBcIiZcIjogXCJcXFxcdTAwMjZcIixcbiAgXCI+XCI6IFwiXFxcXHUwMDNlXCIsXG4gIFwiPFwiOiBcIlxcXFx1MDAzY1wiLFxuICBcIlxcdTIwMjhcIjogXCJcXFxcdTIwMjhcIixcbiAgXCJcXHUyMDI5XCI6IFwiXFxcXHUyMDI5XCJcbn07XG52YXIgRVNDQVBFX1JFR0VYID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoaHRtbCkge1xuICByZXR1cm4gaHRtbC5yZXBsYWNlKEVTQ0FQRV9SRUdFWCwgKG1hdGNoKSA9PiBFU0NBUEVfTE9PS1VQW21hdGNoXSk7XG59XG5mdW5jdGlvbiBjcmVhdGVIdG1sKGh0bWwpIHtcbiAgcmV0dXJuIHsgX19odG1sOiBodG1sIH07XG59XG5cbi8vIGxpYi9kb20vc3NyL3NpbmdsZS1mZXRjaC50c3hcbnZhciBSZWFjdDQgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbi8vIHZlbmRvci90dXJiby1zdHJlYW0tdjIvdXRpbHMudHNcbnZhciBIT0xFID0gLTE7XG52YXIgTkFOID0gLTI7XG52YXIgTkVHQVRJVkVfSU5GSU5JVFkgPSAtMztcbnZhciBORUdBVElWRV9aRVJPID0gLTQ7XG52YXIgTlVMTCA9IC01O1xudmFyIFBPU0lUSVZFX0lORklOSVRZID0gLTY7XG52YXIgVU5ERUZJTkVEID0gLTc7XG52YXIgVFlQRV9CSUdJTlQgPSBcIkJcIjtcbnZhciBUWVBFX0RBVEUgPSBcIkRcIjtcbnZhciBUWVBFX0VSUk9SID0gXCJFXCI7XG52YXIgVFlQRV9NQVAgPSBcIk1cIjtcbnZhciBUWVBFX05VTExfT0JKRUNUID0gXCJOXCI7XG52YXIgVFlQRV9QUk9NSVNFID0gXCJQXCI7XG52YXIgVFlQRV9SRUdFWFAgPSBcIlJcIjtcbnZhciBUWVBFX1NFVCA9IFwiU1wiO1xudmFyIFRZUEVfU1lNQk9MID0gXCJZXCI7XG52YXIgVFlQRV9VUkwgPSBcIlVcIjtcbnZhciBUWVBFX1BSRVZJT1VTX1JFU09MVkVEID0gXCJaXCI7XG52YXIgRGVmZXJyZWQyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVMaW5lU3BsaXR0aW5nVHJhbnNmb3JtKCkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGxldCBsZWZ0b3ZlciA9IFwiXCI7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHN0ciA9IGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IHBhcnRzID0gKGxlZnRvdmVyICsgc3RyKS5zcGxpdChcIlxcblwiKTtcbiAgICAgIGxlZnRvdmVyID0gcGFydHMucG9wKCkgfHwgXCJcIjtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICBpZiAobGVmdG92ZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGxlZnRvdmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyB2ZW5kb3IvdHVyYm8tc3RyZWFtLXYyL2ZsYXR0ZW4udHNcbmZ1bmN0aW9uIGZsYXR0ZW4oaW5wdXQpIHtcbiAgY29uc3QgeyBpbmRpY2VzIH0gPSB0aGlzO1xuICBjb25zdCBleGlzdGluZyA9IGluZGljZXMuZ2V0KGlucHV0KTtcbiAgaWYgKGV4aXN0aW5nKSByZXR1cm4gW2V4aXN0aW5nXTtcbiAgaWYgKGlucHV0ID09PSB2b2lkIDApIHJldHVybiBVTkRFRklORUQ7XG4gIGlmIChpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIE5VTEw7XG4gIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQpKSByZXR1cm4gTkFOO1xuICBpZiAoaW5wdXQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkgcmV0dXJuIFBPU0lUSVZFX0lORklOSVRZO1xuICBpZiAoaW5wdXQgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkgcmV0dXJuIE5FR0FUSVZFX0lORklOSVRZO1xuICBpZiAoaW5wdXQgPT09IDAgJiYgMSAvIGlucHV0IDwgMCkgcmV0dXJuIE5FR0FUSVZFX1pFUk87XG4gIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICBpbmRpY2VzLnNldChpbnB1dCwgaW5kZXgpO1xuICBzdHJpbmdpZnkuY2FsbCh0aGlzLCBpbnB1dCwgaW5kZXgpO1xuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoaW5wdXQsIGluZGV4KSB7XG4gIGNvbnN0IHsgZGVmZXJyZWQsIHBsdWdpbnMsIHBvc3RQbHVnaW5zIH0gPSB0aGlzO1xuICBjb25zdCBzdHIgPSB0aGlzLnN0cmluZ2lmaWVkO1xuICBjb25zdCBzdGFjayA9IFtbaW5wdXQsIGluZGV4XV07XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgW2lucHV0MiwgaW5kZXgyXSA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IHBhcnRzRm9yT2JqID0gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKS5tYXAoKGspID0+IGBcIl8ke2ZsYXR0ZW4uY2FsbCh0aGlzLCBrKX1cIjoke2ZsYXR0ZW4uY2FsbCh0aGlzLCBvYmpba10pfWApLmpvaW4oXCIsXCIpO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgc3dpdGNoICh0eXBlb2YgaW5wdXQyKSB7XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBzdHJbaW5kZXgyXSA9IEpTT04uc3RyaW5naWZ5KGlucHV0Mik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfQklHSU5UfVwiLFwiJHtpbnB1dDJ9XCJdYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3ltYm9sXCI6IHtcbiAgICAgICAgY29uc3Qga2V5Rm9yID0gU3ltYm9sLmtleUZvcihpbnB1dDIpO1xuICAgICAgICBpZiAoIWtleUZvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJDYW5ub3QgZW5jb2RlIHN5bWJvbCB1bmxlc3MgY3JlYXRlZCB3aXRoIFN5bWJvbC5mb3IoKVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfU1lNQk9MfVwiLCR7SlNPTi5zdHJpbmdpZnkoa2V5Rm9yKX1dYDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICBpZiAoIWlucHV0Mikge1xuICAgICAgICAgIHN0cltpbmRleDJdID0gYCR7TlVMTH1gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGlucHV0Mik7XG4gICAgICAgIGxldCBwbHVnaW5IYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIGlmICghaXNBcnJheSAmJiBwbHVnaW5zKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICAgICAgY29uc3QgcGx1Z2luUmVzdWx0ID0gcGx1Z2luKGlucHV0Mik7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW5SZXN1bHQpKSB7XG4gICAgICAgICAgICAgIHBsdWdpbkhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zdCBbcGx1Z2luSWRlbnRpZmllciwgLi4ucmVzdF0gPSBwbHVnaW5SZXN1bHQ7XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFske0pTT04uc3RyaW5naWZ5KHBsdWdpbklkZW50aWZpZXIpfWA7XG4gICAgICAgICAgICAgIGlmIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBgLCR7cmVzdC5tYXAoKHYpID0+IGZsYXR0ZW4uY2FsbCh0aGlzLCB2KSkuam9pbihcIixcIil9YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHJbaW5kZXgyXSArPSBcIl1cIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGx1Z2luSGFuZGxlZCkge1xuICAgICAgICAgIGxldCByZXN1bHQgPSBpc0FycmF5ID8gXCJbXCIgOiBcIntcIjtcbiAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dDIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgIHJlc3VsdCArPSAoaSA/IFwiLFwiIDogXCJcIikgKyAoaSBpbiBpbnB1dDIgPyBmbGF0dGVuLmNhbGwodGhpcywgaW5wdXQyW2ldKSA6IEhPTEUpO1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgJHtyZXN1bHR9XWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGBbXCIke1RZUEVfREFURX1cIiwke2lucHV0Mi5nZXRUaW1lKCl9XWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9VUkx9XCIsJHtKU09OLnN0cmluZ2lmeShpbnB1dDIuaHJlZil9XWA7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnB1dDIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9SRUdFWFB9XCIsJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgaW5wdXQyLnNvdXJjZVxuICAgICAgICAgICAgKX0sJHtKU09OLnN0cmluZ2lmeShpbnB1dDIuZmxhZ3MpfV1gO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQyIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQyLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9TRVR9XCIsJHtbLi4uaW5wdXQyXS5tYXAoKHZhbCkgPT4gZmxhdHRlbi5jYWxsKHRoaXMsIHZhbCkpLmpvaW4oXCIsXCIpfV1gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1NFVH1cIl1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQyIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQyLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9NQVB9XCIsJHtbLi4uaW5wdXQyXS5mbGF0TWFwKChbaywgdl0pID0+IFtcbiAgICAgICAgICAgICAgICBmbGF0dGVuLmNhbGwodGhpcywgayksXG4gICAgICAgICAgICAgICAgZmxhdHRlbi5jYWxsKHRoaXMsIHYpXG4gICAgICAgICAgICAgIF0pLmpvaW4oXCIsXCIpfV1gO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX01BUH1cIl1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX1BST01JU0V9XCIsJHtpbmRleDJ9XWA7XG4gICAgICAgICAgICBkZWZlcnJlZFtpbmRleDJdID0gaW5wdXQyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFtcIiR7VFlQRV9FUlJPUn1cIiwke0pTT04uc3RyaW5naWZ5KGlucHV0Mi5tZXNzYWdlKX1gO1xuICAgICAgICAgICAgaWYgKGlucHV0Mi5uYW1lICE9PSBcIkVycm9yXCIpIHtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gYCwke0pTT04uc3RyaW5naWZ5KGlucHV0Mi5uYW1lKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gXCJdXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQyKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgW1wiJHtUWVBFX05VTExfT0JKRUNUfVwiLHske3BhcnRzRm9yT2JqKGlucHV0Mil9fV1gO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbnB1dDIpKSB7XG4gICAgICAgICAgICBzdHJbaW5kZXgyXSA9IGB7JHtwYXJ0c0Zvck9iaihpbnB1dDIpfX1gO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCBlbmNvZGUgb2JqZWN0IHdpdGggcHJvdG90eXBlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5wdXQyKTtcbiAgICAgICAgbGV0IHBsdWdpbkhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFpc0FycmF5ICYmIHBsdWdpbnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5SZXN1bHQgPSBwbHVnaW4oaW5wdXQyKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgcGx1Z2luSGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnN0IFtwbHVnaW5JZGVudGlmaWVyLCAuLi5yZXN0XSA9IHBsdWdpblJlc3VsdDtcbiAgICAgICAgICAgICAgc3RyW2luZGV4Ml0gPSBgWyR7SlNPTi5zdHJpbmdpZnkocGx1Z2luSWRlbnRpZmllcil9YDtcbiAgICAgICAgICAgICAgaWYgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IGAsJHtyZXN0Lm1hcCgodikgPT4gZmxhdHRlbi5jYWxsKHRoaXMsIHYpKS5qb2luKFwiLFwiKX1gO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IFwiXVwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwbHVnaW5IYW5kbGVkKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZW5jb2RlIGZ1bmN0aW9uIG9yIHVuZXhwZWN0ZWQgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxldCBwbHVnaW5IYW5kbGVkID0gZmFsc2U7XG4gICAgICBpZiAocG9zdFBsdWdpbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcG9zdFBsdWdpbnMpIHtcbiAgICAgICAgICBjb25zdCBwbHVnaW5SZXN1bHQgPSBwbHVnaW4oaW5wdXQyKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW5SZXN1bHQpKSB7XG4gICAgICAgICAgICBwbHVnaW5IYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IFtwbHVnaW5JZGVudGlmaWVyLCAuLi5yZXN0XSA9IHBsdWdpblJlc3VsdDtcbiAgICAgICAgICAgIHN0cltpbmRleDJdID0gYFske0pTT04uc3RyaW5naWZ5KHBsdWdpbklkZW50aWZpZXIpfWA7XG4gICAgICAgICAgICBpZiAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHN0cltpbmRleDJdICs9IGAsJHtyZXN0Lm1hcCgodikgPT4gZmxhdHRlbi5jYWxsKHRoaXMsIHYpKS5qb2luKFwiLFwiKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyW2luZGV4Ml0gKz0gXCJdXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcGx1Z2luSGFuZGxlZCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnZhciBvYmplY3RQcm90b05hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0LnByb3RvdHlwZSkuc29ydCgpLmpvaW4oXCJcXDBcIik7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHRoaW5nKSB7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaW5nKTtcbiAgcmV0dXJuIHByb3RvID09PSBPYmplY3QucHJvdG90eXBlIHx8IHByb3RvID09PSBudWxsIHx8IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKS5zb3J0KCkuam9pbihcIlxcMFwiKSA9PT0gb2JqZWN0UHJvdG9OYW1lcztcbn1cblxuLy8gdmVuZG9yL3R1cmJvLXN0cmVhbS12Mi91bmZsYXR0ZW4udHNcbnZhciBnbG9iYWxPYmogPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzIDogdm9pZCAwO1xuZnVuY3Rpb24gdW5mbGF0dGVuKHBhcnNlZCkge1xuICBjb25zdCB7IGh5ZHJhdGVkLCB2YWx1ZXMgfSA9IHRoaXM7XG4gIGlmICh0eXBlb2YgcGFyc2VkID09PSBcIm51bWJlclwiKSByZXR1cm4gaHlkcmF0ZS5jYWxsKHRoaXMsIHBhcnNlZCk7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJzZWQpIHx8ICFwYXJzZWQubGVuZ3RoKSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IHZhbHVlcy5sZW5ndGg7XG4gIGZvciAoY29uc3QgdmFsdWUgb2YgcGFyc2VkKSB7XG4gICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG4gIGh5ZHJhdGVkLmxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiBoeWRyYXRlLmNhbGwodGhpcywgc3RhcnRJbmRleCk7XG59XG5mdW5jdGlvbiBoeWRyYXRlKGluZGV4KSB7XG4gIGNvbnN0IHsgaHlkcmF0ZWQsIHZhbHVlcywgZGVmZXJyZWQsIHBsdWdpbnMgfSA9IHRoaXM7XG4gIGxldCByZXN1bHQ7XG4gIGNvbnN0IHN0YWNrID0gW1xuICAgIFtcbiAgICAgIGluZGV4LFxuICAgICAgKHYpID0+IHtcbiAgICAgICAgcmVzdWx0ID0gdjtcbiAgICAgIH1cbiAgICBdXG4gIF07XG4gIGxldCBwb3N0UnVuID0gW107XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgW2luZGV4Miwgc2V0XSA9IHN0YWNrLnBvcCgpO1xuICAgIHN3aXRjaCAoaW5kZXgyKSB7XG4gICAgICBjYXNlIFVOREVGSU5FRDpcbiAgICAgICAgc2V0KHZvaWQgMCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBOVUxMOlxuICAgICAgICBzZXQobnVsbCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBOQU46XG4gICAgICAgIHNldChOYU4pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNhc2UgUE9TSVRJVkVfSU5GSU5JVFk6XG4gICAgICAgIHNldChJbmZpbml0eSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBORUdBVElWRV9JTkZJTklUWTpcbiAgICAgICAgc2V0KC1JbmZpbml0eSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY2FzZSBORUdBVElWRV9aRVJPOlxuICAgICAgICBzZXQoLTApO1xuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGh5ZHJhdGVkW2luZGV4Ml0pIHtcbiAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleDJdO1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBoeWRyYXRlZFtpbmRleDJdID0gdmFsdWU7XG4gICAgICBzZXQodmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZVswXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBbdHlwZSwgYiwgY10gPSB2YWx1ZTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBUWVBFX0RBVEU6XG4gICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IG5ldyBEYXRlKGIpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9VUkw6XG4gICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IG5ldyBVUkwoYikpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX0JJR0lOVDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gQmlnSW50KGIpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgVFlQRV9SRUdFWFA6XG4gICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IG5ldyBSZWdFeHAoYiwgYykpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX1NZTUJPTDpcbiAgICAgICAgICAgIHNldChoeWRyYXRlZFtpbmRleDJdID0gU3ltYm9sLmZvcihiKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfU0VUOlxuICAgICAgICAgICAgY29uc3QgbmV3U2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSBuZXdTZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdmFsdWUubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSlcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgICAgdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgIG5ld1NldC5hZGQodik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHNldChuZXdTZXQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX01BUDpcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBoeWRyYXRlZFtpbmRleDJdID0gbWFwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHZhbHVlLmxlbmd0aCAtIDI7IGkgPiAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpICsgMV0sXG4gICAgICAgICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJbMV0gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgICAgICAgIHZhbHVlW2ldLFxuICAgICAgICAgICAgICAgIChrKSA9PiB7XG4gICAgICAgICAgICAgICAgICByWzBdID0gaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICBwb3N0UnVuLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIG1hcC5zZXQoclswXSwgclsxXSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0KG1hcCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfTlVMTF9PQkpFQ1Q6XG4gICAgICAgICAgICBjb25zdCBvYmogPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSBvYmo7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhiKS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICAgICAgICBiW2tleV0sXG4gICAgICAgICAgICAgICAgKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJbMV0gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goW1xuICAgICAgICAgICAgICAgIE51bWJlcihrZXkuc2xpY2UoMSkpLFxuICAgICAgICAgICAgICAgIChrKSA9PiB7XG4gICAgICAgICAgICAgICAgICByWzBdID0gaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICBwb3N0UnVuLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9ialtyWzBdXSA9IHJbMV07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0KG9iaik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfUFJPTUlTRTpcbiAgICAgICAgICAgIGlmIChoeWRyYXRlZFtiXSkge1xuICAgICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IGh5ZHJhdGVkW2JdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGQgPSBuZXcgRGVmZXJyZWQyKCk7XG4gICAgICAgICAgICAgIGRlZmVycmVkW2JdID0gZDtcbiAgICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSBkLnByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSBUWVBFX0VSUk9SOlxuICAgICAgICAgICAgY29uc3QgWywgbWVzc2FnZSwgZXJyb3JUeXBlXSA9IHZhbHVlO1xuICAgICAgICAgICAgbGV0IGVycm9yID0gZXJyb3JUeXBlICYmIGdsb2JhbE9iaiAmJiBnbG9iYWxPYmpbZXJyb3JUeXBlXSA/IG5ldyBnbG9iYWxPYmpbZXJyb3JUeXBlXShtZXNzYWdlKSA6IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSBlcnJvcjtcbiAgICAgICAgICAgIHNldChlcnJvcik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFRZUEVfUFJFVklPVVNfUkVTT0xWRUQ6XG4gICAgICAgICAgICBzZXQoaHlkcmF0ZWRbaW5kZXgyXSA9IGh5ZHJhdGVkW2JdKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW5zKSkge1xuICAgICAgICAgICAgICBjb25zdCByID0gW107XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHMgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHNbaV07XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgICAgKHYyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJbaV0gPSB2MjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwb3N0UnVuLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBwbHVnaW4odmFsdWVbMF0sIC4uLnIpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0KGh5ZHJhdGVkW2luZGV4Ml0gPSByZXN1bHQyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgICAgIGh5ZHJhdGVkW2luZGV4Ml0gPSBhcnJheTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG4gPSB2YWx1ZVtpXTtcbiAgICAgICAgICBpZiAobiAhPT0gSE9MRSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChbXG4gICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0KGFycmF5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9iamVjdCA9IHt9O1xuICAgICAgaHlkcmF0ZWRbaW5kZXgyXSA9IG9iamVjdDtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlKS5yZXZlcnNlKCkpIHtcbiAgICAgICAgY29uc3QgciA9IFtdO1xuICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICB2YWx1ZVtrZXldLFxuICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICByWzFdID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgIF0pO1xuICAgICAgICBzdGFjay5wdXNoKFtcbiAgICAgICAgICBOdW1iZXIoa2V5LnNsaWNlKDEpKSxcbiAgICAgICAgICAoaykgPT4ge1xuICAgICAgICAgICAgclswXSA9IGs7XG4gICAgICAgICAgfVxuICAgICAgICBdKTtcbiAgICAgICAgcG9zdFJ1bi5wdXNoKCgpID0+IHtcbiAgICAgICAgICBvYmplY3RbclswXV0gPSByWzFdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNldChvYmplY3QpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIHdoaWxlIChwb3N0UnVuLmxlbmd0aCA+IDApIHtcbiAgICBwb3N0UnVuLnBvcCgpKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gdmVuZG9yL3R1cmJvLXN0cmVhbS12Mi90dXJiby1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIGRlY29kZShyZWFkYWJsZSwgb3B0aW9ucykge1xuICBjb25zdCB7IHBsdWdpbnMgfSA9IG9wdGlvbnMgPz8ge307XG4gIGNvbnN0IGRvbmUgPSBuZXcgRGVmZXJyZWQyKCk7XG4gIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlLnBpcGVUaHJvdWdoKGNyZWF0ZUxpbmVTcGxpdHRpbmdUcmFuc2Zvcm0oKSkuZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSB7XG4gICAgdmFsdWVzOiBbXSxcbiAgICBoeWRyYXRlZDogW10sXG4gICAgZGVmZXJyZWQ6IHt9LFxuICAgIHBsdWdpbnNcbiAgfTtcbiAgY29uc3QgZGVjb2RlZCA9IGF3YWl0IGRlY29kZUluaXRpYWwuY2FsbChkZWNvZGVyLCByZWFkZXIpO1xuICBsZXQgZG9uZVByb21pc2UgPSBkb25lLnByb21pc2U7XG4gIGlmIChkZWNvZGVkLmRvbmUpIHtcbiAgICBkb25lLnJlc29sdmUoKTtcbiAgfSBlbHNlIHtcbiAgICBkb25lUHJvbWlzZSA9IGRlY29kZURlZmVycmVkLmNhbGwoZGVjb2RlciwgcmVhZGVyKS50aGVuKGRvbmUucmVzb2x2ZSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgZm9yIChjb25zdCBkZWZlcnJlZCBvZiBPYmplY3QudmFsdWVzKGRlY29kZXIuZGVmZXJyZWQpKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgICAgfVxuICAgICAgZG9uZS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRvbmU6IGRvbmVQcm9taXNlLnRoZW4oKCkgPT4gcmVhZGVyLmNsb3NlZCksXG4gICAgdmFsdWU6IGRlY29kZWQudmFsdWVcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY29kZUluaXRpYWwocmVhZGVyKSB7XG4gIGNvbnN0IHJlYWQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICBpZiAoIXJlYWQudmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgfVxuICBsZXQgbGluZTtcbiAgdHJ5IHtcbiAgICBsaW5lID0gSlNPTi5wYXJzZShyZWFkLnZhbHVlKTtcbiAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkb25lOiByZWFkLmRvbmUsXG4gICAgdmFsdWU6IHVuZmxhdHRlbi5jYWxsKHRoaXMsIGxpbmUpXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBkZWNvZGVEZWZlcnJlZChyZWFkZXIpIHtcbiAgbGV0IHJlYWQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICB3aGlsZSAoIXJlYWQuZG9uZSkge1xuICAgIGlmICghcmVhZC52YWx1ZSkgY29udGludWU7XG4gICAgY29uc3QgbGluZSA9IHJlYWQudmFsdWU7XG4gICAgc3dpdGNoIChsaW5lWzBdKSB7XG4gICAgICBjYXNlIFRZUEVfUFJPTUlTRToge1xuICAgICAgICBjb25zdCBjb2xvbkluZGV4ID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgY29uc3QgZGVmZXJyZWRJZCA9IE51bWJlcihsaW5lLnNsaWNlKDEsIGNvbG9uSW5kZXgpKTtcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLmRlZmVycmVkW2RlZmVycmVkSWRdO1xuICAgICAgICBpZiAoIWRlZmVycmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWZlcnJlZCBJRCAke2RlZmVycmVkSWR9IG5vdCBmb3VuZCBpbiBzdHJlYW1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lRGF0YSA9IGxpbmUuc2xpY2UoY29sb25JbmRleCArIDEpO1xuICAgICAgICBsZXQganNvbkxpbmU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAganNvbkxpbmUgPSBKU09OLnBhcnNlKGxpbmVEYXRhKTtcbiAgICAgICAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB1bmZsYXR0ZW4uY2FsbCh0aGlzLCBqc29uTGluZSk7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgVFlQRV9FUlJPUjoge1xuICAgICAgICBjb25zdCBjb2xvbkluZGV4ID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgY29uc3QgZGVmZXJyZWRJZCA9IE51bWJlcihsaW5lLnNsaWNlKDEsIGNvbG9uSW5kZXgpKTtcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLmRlZmVycmVkW2RlZmVycmVkSWRdO1xuICAgICAgICBpZiAoIWRlZmVycmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWZlcnJlZCBJRCAke2RlZmVycmVkSWR9IG5vdCBmb3VuZCBpbiBzdHJlYW1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lRGF0YSA9IGxpbmUuc2xpY2UoY29sb25JbmRleCArIDEpO1xuICAgICAgICBsZXQganNvbkxpbmU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAganNvbkxpbmUgPSBKU09OLnBhcnNlKGxpbmVEYXRhKTtcbiAgICAgICAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB1bmZsYXR0ZW4uY2FsbCh0aGlzLCBqc29uTGluZSk7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdCh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCk7XG4gICAgfVxuICAgIHJlYWQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICB9XG59XG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBwbHVnaW5zLCBwb3N0UGx1Z2lucywgc2lnbmFsIH0gPSBvcHRpb25zID8/IHt9O1xuICBjb25zdCBlbmNvZGVyMiA9IHtcbiAgICBkZWZlcnJlZDoge30sXG4gICAgaW5kZXg6IDAsXG4gICAgaW5kaWNlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBzdHJpbmdpZmllZDogW10sXG4gICAgcGx1Z2lucyxcbiAgICBwb3N0UGx1Z2lucyxcbiAgICBzaWduYWxcbiAgfTtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGxhc3RTZW50SW5kZXggPSAwO1xuICBjb25zdCByZWFkYWJsZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29uc3QgaWQgPSBmbGF0dGVuLmNhbGwoZW5jb2RlcjIsIGlucHV0KTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHNob3VsZCBuZXZlciBoYXBwZW5cIik7XG4gICAgICB9XG4gICAgICBpZiAoaWQgPCAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUoYCR7aWR9XG5gKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGBbJHtlbmNvZGVyMi5zdHJpbmdpZmllZC5qb2luKFwiLFwiKX1dXG5gKVxuICAgICAgICApO1xuICAgICAgICBsYXN0U2VudEluZGV4ID0gZW5jb2RlcjIuc3RyaW5naWZpZWQubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlZW5Qcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGVuY29kZXIyLmRlZmVycmVkKS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJhY2VEb25lO1xuICAgICAgICBjb25zdCByYWNlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICByYWNlRG9uZSA9IHJlc29sdmU7XG4gICAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgY29uc3QgcmVqZWN0UHJvbWlzZSA9ICgpID0+IHJlamVjdChzaWduYWwucmVhc29uIHx8IG5ldyBFcnJvcihcIlNpZ25hbCB3YXMgYWJvcnRlZC5cIikpO1xuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIHJlamVjdFByb21pc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoT2JqZWN0LmtleXMoZW5jb2RlcjIuZGVmZXJyZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtkZWZlcnJlZElkLCBkZWZlcnJlZF0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgICAgICBlbmNvZGVyMi5kZWZlcnJlZFxuICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIGlmIChzZWVuUHJvbWlzZXMuaGFzKGRlZmVycmVkKSkgY29udGludWU7XG4gICAgICAgICAgICBzZWVuUHJvbWlzZXMuYWRkKFxuICAgICAgICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdXNwaWNpb3VzL25vQXNzaWduSW5FeHByZXNzaW9uczogPGV4cGxhbmF0aW9uPlxuICAgICAgICAgICAgICBlbmNvZGVyMi5kZWZlcnJlZFtOdW1iZXIoZGVmZXJyZWRJZCldID0gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICByYWNlUHJvbWlzZSxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZFxuICAgICAgICAgICAgICBdKS50aGVuKFxuICAgICAgICAgICAgICAgIChyZXNvbHZlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgaWQyID0gZmxhdHRlbi5jYWxsKGVuY29kZXIyLCByZXNvbHZlZCk7XG4gICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpZDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtUWVBFX1BST01JU0V9JHtkZWZlcnJlZElkfTpbW1wiJHtUWVBFX1BSRVZJT1VTX1JFU09MVkVEfVwiLCR7aWQyWzBdfV1dXG5gXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVyMi5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2VudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlkMiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke1RZUEVfUFJPTUlTRX0ke2RlZmVycmVkSWR9OiR7aWQyfVxuYFxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGVuY29kZXIyLnN0cmluZ2lmaWVkLnNsaWNlKGxhc3RTZW50SW5kZXggKyAxKS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke1RZUEVfUFJPTUlTRX0ke2RlZmVycmVkSWR9Olske3ZhbHVlc31dXG5gXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2VudEluZGV4ID0gZW5jb2RlcjIuc3RyaW5naWZpZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChyZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmICghcmVhc29uIHx8IHR5cGVvZiByZWFzb24gIT09IFwib2JqZWN0XCIgfHwgIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gbmV3IEVycm9yKFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZFwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGlkMiA9IGZsYXR0ZW4uY2FsbChlbmNvZGVyMiwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkMikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke1RZUEVfRVJST1J9JHtkZWZlcnJlZElkfTpbW1wiJHtUWVBFX1BSRVZJT1VTX1JFU09MVkVEfVwiLCR7aWQyWzBdfV1dXG5gXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVyMi5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2VudEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlkMiA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShgJHtUWVBFX0VSUk9SfSR7ZGVmZXJyZWRJZH06JHtpZDJ9XG5gKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZW5jb2RlcjIuc3RyaW5naWZpZWQuc2xpY2UobGFzdFNlbnRJbmRleCArIDEpLmpvaW4oXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7VFlQRV9FUlJPUn0ke2RlZmVycmVkSWR9Olske3ZhbHVlc31dXG5gXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U2VudEluZGV4ID0gZW5jb2RlcjIuc3RyaW5naWZpZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVuY29kZXIyLmRlZmVycmVkW051bWJlcihkZWZlcnJlZElkKV07XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoT2JqZWN0LnZhbHVlcyhlbmNvZGVyMi5kZWZlcnJlZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJhY2VEb25lKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKGVuY29kZXIyLmRlZmVycmVkKSk7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlYWRhYmxlO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9kYXRhLnRzXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0SW5pdChyZXF1ZXN0KSB7XG4gIGxldCBpbml0ID0geyBzaWduYWw6IHJlcXVlc3Quc2lnbmFsIH07XG4gIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gXCJHRVRcIikge1xuICAgIGluaXQubWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgbGV0IGNvbnRlbnRUeXBlID0gcmVxdWVzdC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgIGluaXQuaGVhZGVycyA9IHsgXCJDb250ZW50LVR5cGVcIjogY29udGVudFR5cGUgfTtcbiAgICAgIGluaXQuYm9keSA9IEpTT04uc3RyaW5naWZ5KGF3YWl0IHJlcXVlc3QuanNvbigpKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJ0ZXh0XFwvcGxhaW5cXGIvLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICBpbml0LmhlYWRlcnMgPSB7IFwiQ29udGVudC1UeXBlXCI6IGNvbnRlbnRUeXBlIH07XG4gICAgICBpbml0LmJvZHkgPSBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRlbnRUeXBlICYmIC9cXGJhcHBsaWNhdGlvblxcL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgIGluaXQuYm9keSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoYXdhaXQgcmVxdWVzdC50ZXh0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0LmJvZHkgPSBhd2FpdCByZXF1ZXN0LmZvcm1EYXRhKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbml0O1xufVxuXG4vLyBsaWIvZG9tL3Nzci9zaW5nbGUtZmV0Y2gudHN4XG52YXIgU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCA9IFN5bWJvbChcIlNpbmdsZUZldGNoUmVkaXJlY3RcIik7XG52YXIgU2luZ2xlRmV0Y2hOb1Jlc3VsdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG59O1xudmFyIFNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVMgPSAyMDI7XG52YXIgTk9fQk9EWV9TVEFUVVNfQ09ERVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbMTAwLCAxMDEsIDIwNCwgMjA1XSk7XG5mdW5jdGlvbiBTdHJlYW1UcmFuc2Zlcih7XG4gIGNvbnRleHQsXG4gIGlkZW50aWZpZXIsXG4gIHJlYWRlcixcbiAgdGV4dERlY29kZXIsXG4gIG5vbmNlXG59KSB7XG4gIGlmICghY29udGV4dC5yZW5kZXJNZXRhIHx8ICFjb250ZXh0LnJlbmRlck1ldGEuZGlkUmVuZGVyU2NyaXB0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghY29udGV4dC5yZW5kZXJNZXRhLnN0cmVhbUNhY2hlKSB7XG4gICAgY29udGV4dC5yZW5kZXJNZXRhLnN0cmVhbUNhY2hlID0ge307XG4gIH1cbiAgbGV0IHsgc3RyZWFtQ2FjaGUgfSA9IGNvbnRleHQucmVuZGVyTWV0YTtcbiAgbGV0IHByb21pc2UgPSBzdHJlYW1DYWNoZVtpZGVudGlmaWVyXTtcbiAgaWYgKCFwcm9taXNlKSB7XG4gICAgcHJvbWlzZSA9IHN0cmVhbUNhY2hlW2lkZW50aWZpZXJdID0gcmVhZGVyLnJlYWQoKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIHN0cmVhbUNhY2hlW2lkZW50aWZpZXJdLnJlc3VsdCA9IHtcbiAgICAgICAgZG9uZTogcmVzdWx0LmRvbmUsXG4gICAgICAgIHZhbHVlOiB0ZXh0RGVjb2Rlci5kZWNvZGUocmVzdWx0LnZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgICAgfTtcbiAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgc3RyZWFtQ2FjaGVbaWRlbnRpZmllcl0uZXJyb3IgPSBlO1xuICAgIH0pO1xuICB9XG4gIGlmIChwcm9taXNlLmVycm9yKSB7XG4gICAgdGhyb3cgcHJvbWlzZS5lcnJvcjtcbiAgfVxuICBpZiAocHJvbWlzZS5yZXN1bHQgPT09IHZvaWQgMCkge1xuICAgIHRocm93IHByb21pc2U7XG4gIH1cbiAgbGV0IHsgZG9uZSwgdmFsdWUgfSA9IHByb21pc2UucmVzdWx0O1xuICBsZXQgc2NyaXB0VGFnID0gdmFsdWUgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzY3JpcHRcIixcbiAgICB7XG4gICAgICBub25jZSxcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgIF9faHRtbDogYHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dC5zdHJlYW1Db250cm9sbGVyLmVucXVldWUoJHtlc2NhcGVIdG1sKFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgICAgICApfSk7YFxuICAgICAgfVxuICAgIH1cbiAgKSA6IG51bGw7XG4gIGlmIChkb25lKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDQuY3JlYXRlRWxlbWVudChSZWFjdDQuRnJhZ21lbnQsIG51bGwsIHNjcmlwdFRhZywgLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFxuICAgICAgXCJzY3JpcHRcIixcbiAgICAgIHtcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgX19odG1sOiBgd2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LnN0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NC5jcmVhdGVFbGVtZW50KFJlYWN0NC5GcmFnbWVudCwgbnVsbCwgc2NyaXB0VGFnLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoUmVhY3Q0LlN1c3BlbnNlLCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBTdHJlYW1UcmFuc2ZlcixcbiAgICAgIHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllciArIDEsXG4gICAgICAgIHJlYWRlcixcbiAgICAgICAgdGV4dERlY29kZXIsXG4gICAgICAgIG5vbmNlXG4gICAgICB9XG4gICAgKSkpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5KGdldFJvdXRlciwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgc3NyLCBiYXNlbmFtZSkge1xuICBsZXQgZGF0YVN0cmF0ZWd5ID0gZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3lJbXBsKFxuICAgIGdldFJvdXRlcixcbiAgICAobWF0Y2gpID0+IHtcbiAgICAgIGxldCBtYW5pZmVzdFJvdXRlID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGludmFyaWFudDIobWFuaWZlc3RSb3V0ZSwgXCJSb3V0ZSBub3QgZm91bmQgaW4gbWFuaWZlc3RcIik7XG4gICAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZU1vZHVsZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGFzTG9hZGVyOiBtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcixcbiAgICAgICAgaGFzQ2xpZW50TG9hZGVyOiBtYW5pZmVzdFJvdXRlLmhhc0NsaWVudExvYWRlcixcbiAgICAgICAgaGFzU2hvdWxkUmV2YWxpZGF0ZTogQm9vbGVhbihyb3V0ZU1vZHVsZT8uc2hvdWxkUmV2YWxpZGF0ZSlcbiAgICAgIH07XG4gICAgfSxcbiAgICBmZXRjaEFuZERlY29kZVZpYVR1cmJvU3RyZWFtLFxuICAgIHNzcixcbiAgICBiYXNlbmFtZVxuICApO1xuICByZXR1cm4gYXN5bmMgKGFyZ3MpID0+IGFyZ3MudW5zdGFibGVfcnVuQ2xpZW50TWlkZGxld2FyZShkYXRhU3RyYXRlZ3kpO1xufVxuZnVuY3Rpb24gZ2V0U2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3lJbXBsKGdldFJvdXRlciwgZ2V0Um91dGVJbmZvLCBmZXRjaEFuZERlY29kZSwgc3NyLCBiYXNlbmFtZSkge1xuICByZXR1cm4gYXN5bmMgKGFyZ3MpID0+IHtcbiAgICBsZXQgeyByZXF1ZXN0LCBtYXRjaGVzLCBmZXRjaGVyS2V5IH0gPSBhcmdzO1xuICAgIGxldCByb3V0ZXIgPSBnZXRSb3V0ZXIoKTtcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgIHJldHVybiBzaW5nbGVGZXRjaEFjdGlvblN0cmF0ZWd5KGFyZ3MsIGZldGNoQW5kRGVjb2RlLCBiYXNlbmFtZSk7XG4gICAgfVxuICAgIGxldCBmb3VuZFJldmFsaWRhdGluZ1NlcnZlckxvYWRlciA9IG1hdGNoZXMuc29tZSgobSkgPT4ge1xuICAgICAgbGV0IHsgaGFzTG9hZGVyLCBoYXNDbGllbnRMb2FkZXIgfSA9IGdldFJvdXRlSW5mbyhtKTtcbiAgICAgIHJldHVybiBtLnVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyKCkgJiYgaGFzTG9hZGVyICYmICFoYXNDbGllbnRMb2FkZXI7XG4gICAgfSk7XG4gICAgaWYgKCFzc3IgJiYgIWZvdW5kUmV2YWxpZGF0aW5nU2VydmVyTG9hZGVyKSB7XG4gICAgICByZXR1cm4gbm9uU3NyU3RyYXRlZ3koYXJncywgZ2V0Um91dGVJbmZvLCBmZXRjaEFuZERlY29kZSwgYmFzZW5hbWUpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hlcktleSkge1xuICAgICAgcmV0dXJuIHNpbmdsZUZldGNoTG9hZGVyRmV0Y2hlclN0cmF0ZWd5KGFyZ3MsIGZldGNoQW5kRGVjb2RlLCBiYXNlbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGVGZXRjaExvYWRlck5hdmlnYXRpb25TdHJhdGVneShcbiAgICAgIGFyZ3MsXG4gICAgICByb3V0ZXIsXG4gICAgICBnZXRSb3V0ZUluZm8sXG4gICAgICBmZXRjaEFuZERlY29kZSxcbiAgICAgIHNzcixcbiAgICAgIGJhc2VuYW1lXG4gICAgKTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoQWN0aW9uU3RyYXRlZ3koYXJncywgZmV0Y2hBbmREZWNvZGUsIGJhc2VuYW1lKSB7XG4gIGxldCBhY3Rpb25NYXRjaCA9IGFyZ3MubWF0Y2hlcy5maW5kKChtKSA9PiBtLnVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyKCkpO1xuICBpbnZhcmlhbnQyKGFjdGlvbk1hdGNoLCBcIk5vIGFjdGlvbiBtYXRjaCBmb3VuZFwiKTtcbiAgbGV0IGFjdGlvblN0YXR1cyA9IHZvaWQgMDtcbiAgbGV0IHJlc3VsdCA9IGF3YWl0IGFjdGlvbk1hdGNoLnJlc29sdmUoYXN5bmMgKGhhbmRsZXIpID0+IHtcbiAgICBsZXQgcmVzdWx0MiA9IGF3YWl0IGhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHsgZGF0YTogZGF0YTIsIHN0YXR1cyB9ID0gYXdhaXQgZmV0Y2hBbmREZWNvZGUoYXJncywgYmFzZW5hbWUsIFtcbiAgICAgICAgYWN0aW9uTWF0Y2gucm91dGUuaWRcbiAgICAgIF0pO1xuICAgICAgYWN0aW9uU3RhdHVzID0gc3RhdHVzO1xuICAgICAgcmV0dXJuIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KGRhdGEyLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDI7XG4gIH0pO1xuICBpZiAoaXNSZXNwb25zZShyZXN1bHQucmVzdWx0KSB8fCBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQucmVzdWx0KSB8fCBpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHJlc3VsdC5yZXN1bHQpKSB7XG4gICAgcmV0dXJuIHsgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0IH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiB7XG4gICAgICB0eXBlOiByZXN1bHQudHlwZSxcbiAgICAgIHJlc3VsdDogZGF0YShyZXN1bHQucmVzdWx0LCBhY3Rpb25TdGF0dXMpXG4gICAgfVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbm9uU3NyU3RyYXRlZ3koYXJncywgZ2V0Um91dGVJbmZvLCBmZXRjaEFuZERlY29kZSwgYmFzZW5hbWUpIHtcbiAgbGV0IG1hdGNoZXNUb0xvYWQgPSBhcmdzLm1hdGNoZXMuZmlsdGVyKFxuICAgIChtKSA9PiBtLnVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyKClcbiAgKTtcbiAgbGV0IHJlc3VsdHMgPSB7fTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgbWF0Y2hlc1RvTG9hZC5tYXAoXG4gICAgICAobSkgPT4gbS5yZXNvbHZlKGFzeW5jIChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHsgaGFzQ2xpZW50TG9hZGVyIH0gPSBnZXRSb3V0ZUluZm8obSk7XG4gICAgICAgICAgbGV0IHJvdXRlSWQgPSBtLnJvdXRlLmlkO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBoYXNDbGllbnRMb2FkZXIgPyBhd2FpdCBoYW5kbGVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGRhdGE6IGRhdGEyIH0gPSBhd2FpdCBmZXRjaEFuZERlY29kZShhcmdzLCBiYXNlbmFtZSwgW3JvdXRlSWRdKTtcbiAgICAgICAgICAgIHJldHVybiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChkYXRhMiwgcm91dGVJZCk7XG4gICAgICAgICAgfSkgOiBhd2FpdCBoYW5kbGVyKCk7XG4gICAgICAgICAgcmVzdWx0c1ttLnJvdXRlLmlkXSA9IHsgdHlwZTogXCJkYXRhXCIsIHJlc3VsdCB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVzdWx0c1ttLnJvdXRlLmlkXSA9IHsgdHlwZTogXCJlcnJvclwiLCByZXN1bHQ6IGUgfTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gICk7XG4gIHJldHVybiByZXN1bHRzO1xufVxuYXN5bmMgZnVuY3Rpb24gc2luZ2xlRmV0Y2hMb2FkZXJOYXZpZ2F0aW9uU3RyYXRlZ3koYXJncywgcm91dGVyLCBnZXRSb3V0ZUluZm8sIGZldGNoQW5kRGVjb2RlLCBzc3IsIGJhc2VuYW1lKSB7XG4gIGxldCByb3V0ZXNQYXJhbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgZm91bmRPcHRPdXRSb3V0ZSA9IGZhbHNlO1xuICBsZXQgcm91dGVEZmRzID0gYXJncy5tYXRjaGVzLm1hcCgoKSA9PiBjcmVhdGVEZWZlcnJlZDIoKSk7XG4gIGxldCBzaW5nbGVGZXRjaERmZCA9IGNyZWF0ZURlZmVycmVkMigpO1xuICBsZXQgcmVzdWx0cyA9IHt9O1xuICBsZXQgcmVzb2x2ZVByb21pc2UgPSBQcm9taXNlLmFsbChcbiAgICBhcmdzLm1hdGNoZXMubWFwKFxuICAgICAgYXN5bmMgKG0sIGkpID0+IG0ucmVzb2x2ZShhc3luYyAoaGFuZGxlcikgPT4ge1xuICAgICAgICByb3V0ZURmZHNbaV0ucmVzb2x2ZSgpO1xuICAgICAgICBsZXQgcm91dGVJZCA9IG0ucm91dGUuaWQ7XG4gICAgICAgIGxldCB7IGhhc0xvYWRlciwgaGFzQ2xpZW50TG9hZGVyLCBoYXNTaG91bGRSZXZhbGlkYXRlIH0gPSBnZXRSb3V0ZUluZm8obSk7XG4gICAgICAgIGxldCBkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSA9ICFtLnVuc3RhYmxlX3Nob3VsZFJldmFsaWRhdGVBcmdzIHx8IG0udW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MuYWN0aW9uU3RhdHVzID09IG51bGwgfHwgbS51bnN0YWJsZV9zaG91bGRSZXZhbGlkYXRlQXJncy5hY3Rpb25TdGF0dXMgPCA0MDA7XG4gICAgICAgIGxldCBzaG91bGRDYWxsID0gbS51bnN0YWJsZV9zaG91bGRDYWxsSGFuZGxlcihkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSk7XG4gICAgICAgIGlmICghc2hvdWxkQ2FsbCkge1xuICAgICAgICAgIGZvdW5kT3B0T3V0Um91dGUgfHwgKGZvdW5kT3B0T3V0Um91dGUgPSBtLnVuc3RhYmxlX3Nob3VsZFJldmFsaWRhdGVBcmdzICE9IG51bGwgJiYgLy8gVGhpcyBpcyBhIHJldmFsaWRhdGlvbixcbiAgICAgICAgICBoYXNMb2FkZXIgJiYgLy8gZm9yIGEgcm91dGUgd2l0aCBhIHNlcnZlciBsb2FkZXIsXG4gICAgICAgICAgaGFzU2hvdWxkUmV2YWxpZGF0ZSA9PT0gdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNDbGllbnRMb2FkZXIpIHtcbiAgICAgICAgICBpZiAoaGFzTG9hZGVyKSB7XG4gICAgICAgICAgICBmb3VuZE9wdE91dFJvdXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgbGV0IHsgZGF0YTogZGF0YTIgfSA9IGF3YWl0IGZldGNoQW5kRGVjb2RlKGFyZ3MsIGJhc2VuYW1lLCBbcm91dGVJZF0pO1xuICAgICAgICAgICAgICByZXR1cm4gdW53cmFwU2luZ2xlRmV0Y2hSZXN1bHQoZGF0YTIsIHJvdXRlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHRzW3JvdXRlSWRdID0geyB0eXBlOiBcImRhdGFcIiwgcmVzdWx0IH07XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0c1tyb3V0ZUlkXSA9IHsgdHlwZTogXCJlcnJvclwiLCByZXN1bHQ6IGUgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNMb2FkZXIpIHtcbiAgICAgICAgICByb3V0ZXNQYXJhbXMuYWRkKHJvdXRlSWQpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRhdGEyID0gYXdhaXQgc2luZ2xlRmV0Y2hEZmQucHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChkYXRhMiwgcm91dGVJZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVzdWx0c1tyb3V0ZUlkXSA9IHsgdHlwZTogXCJkYXRhXCIsIHJlc3VsdCB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVzdWx0c1tyb3V0ZUlkXSA9IHsgdHlwZTogXCJlcnJvclwiLCByZXN1bHQ6IGUgfTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gICk7XG4gIGF3YWl0IFByb21pc2UuYWxsKHJvdXRlRGZkcy5tYXAoKGQpID0+IGQucHJvbWlzZSkpO1xuICBsZXQgaXNJbml0aWFsTG9hZCA9ICFyb3V0ZXIuc3RhdGUuaW5pdGlhbGl6ZWQgJiYgcm91dGVyLnN0YXRlLm5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiO1xuICBpZiAoKGlzSW5pdGlhbExvYWQgfHwgcm91dGVzUGFyYW1zLnNpemUgPT09IDApICYmICF3aW5kb3cuX19yZWFjdFJvdXRlckhkckFjdGl2ZSkge1xuICAgIHNpbmdsZUZldGNoRGZkLnJlc29sdmUoeyByb3V0ZXM6IHt9IH0pO1xuICB9IGVsc2Uge1xuICAgIGxldCB0YXJnZXRSb3V0ZXMgPSBzc3IgJiYgZm91bmRPcHRPdXRSb3V0ZSAmJiByb3V0ZXNQYXJhbXMuc2l6ZSA+IDAgPyBbLi4ucm91dGVzUGFyYW1zLmtleXMoKV0gOiB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkYXRhMiA9IGF3YWl0IGZldGNoQW5kRGVjb2RlKGFyZ3MsIGJhc2VuYW1lLCB0YXJnZXRSb3V0ZXMpO1xuICAgICAgc2luZ2xlRmV0Y2hEZmQucmVzb2x2ZShkYXRhMi5kYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzaW5nbGVGZXRjaERmZC5yZWplY3QoZSk7XG4gICAgfVxuICB9XG4gIGF3YWl0IHJlc29sdmVQcm9taXNlO1xuICBhd2FpdCBidWJibGVNaWRkbGV3YXJlRXJyb3JzKFxuICAgIHNpbmdsZUZldGNoRGZkLnByb21pc2UsXG4gICAgYXJncy5tYXRjaGVzLFxuICAgIHJvdXRlc1BhcmFtcyxcbiAgICByZXN1bHRzXG4gICk7XG4gIHJldHVybiByZXN1bHRzO1xufVxuYXN5bmMgZnVuY3Rpb24gYnViYmxlTWlkZGxld2FyZUVycm9ycyhzaW5nbGVGZXRjaFByb21pc2UsIG1hdGNoZXMsIHJvdXRlc1BhcmFtcywgcmVzdWx0cykge1xuICB0cnkge1xuICAgIGxldCBtaWRkbGV3YXJlRXJyb3I7XG4gICAgbGV0IGZldGNoZWREYXRhID0gYXdhaXQgc2luZ2xlRmV0Y2hQcm9taXNlO1xuICAgIGlmIChcInJvdXRlc1wiIGluIGZldGNoZWREYXRhKSB7XG4gICAgICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgIGlmIChtYXRjaC5yb3V0ZS5pZCBpbiBmZXRjaGVkRGF0YS5yb3V0ZXMpIHtcbiAgICAgICAgICBsZXQgcm91dGVSZXN1bHQgPSBmZXRjaGVkRGF0YS5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gcm91dGVSZXN1bHQpIHtcbiAgICAgICAgICAgIG1pZGRsZXdhcmVFcnJvciA9IHJvdXRlUmVzdWx0LmVycm9yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaWRkbGV3YXJlRXJyb3IgIT09IHZvaWQgMCkge1xuICAgICAgQXJyYXkuZnJvbShyb3V0ZXNQYXJhbXMudmFsdWVzKCkpLmZvckVhY2goKHJvdXRlSWQpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdHNbcm91dGVJZF0ucmVzdWx0IGluc3RhbmNlb2YgU2luZ2xlRmV0Y2hOb1Jlc3VsdEVycm9yKSB7XG4gICAgICAgICAgcmVzdWx0c1tyb3V0ZUlkXS5yZXN1bHQgPSBtaWRkbGV3YXJlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBzaW5nbGVGZXRjaExvYWRlckZldGNoZXJTdHJhdGVneShhcmdzLCBmZXRjaEFuZERlY29kZSwgYmFzZW5hbWUpIHtcbiAgbGV0IGZldGNoZXJNYXRjaCA9IGFyZ3MubWF0Y2hlcy5maW5kKChtKSA9PiBtLnVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyKCkpO1xuICBpbnZhcmlhbnQyKGZldGNoZXJNYXRjaCwgXCJObyBmZXRjaGVyIG1hdGNoIGZvdW5kXCIpO1xuICBsZXQgcm91dGVJZCA9IGZldGNoZXJNYXRjaC5yb3V0ZS5pZDtcbiAgbGV0IHJlc3VsdCA9IGF3YWl0IGZldGNoZXJNYXRjaC5yZXNvbHZlKFxuICAgIGFzeW5jIChoYW5kbGVyKSA9PiBoYW5kbGVyKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCB7IGRhdGE6IGRhdGEyIH0gPSBhd2FpdCBmZXRjaEFuZERlY29kZShhcmdzLCBiYXNlbmFtZSwgW3JvdXRlSWRdKTtcbiAgICAgIHJldHVybiB1bndyYXBTaW5nbGVGZXRjaFJlc3VsdChkYXRhMiwgcm91dGVJZCk7XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIHsgW2ZldGNoZXJNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdCB9O1xufVxuZnVuY3Rpb24gc3RyaXBJbmRleFBhcmFtKHVybCkge1xuICBsZXQgaW5kZXhWYWx1ZXMgPSB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICBsZXQgaW5kZXhWYWx1ZXNUb0tlZXAgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXhWYWx1ZSBvZiBpbmRleFZhbHVlcykge1xuICAgIGlmIChpbmRleFZhbHVlKSB7XG4gICAgICBpbmRleFZhbHVlc1RvS2VlcC5wdXNoKGluZGV4VmFsdWUpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCB0b0tlZXAgb2YgaW5kZXhWYWx1ZXNUb0tlZXApIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIHRvS2VlcCk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIHNpbmdsZUZldGNoVXJsKHJlcVVybCwgYmFzZW5hbWUpIHtcbiAgbGV0IHVybCA9IHR5cGVvZiByZXFVcmwgPT09IFwic3RyaW5nXCIgPyBuZXcgVVJMKFxuICAgIHJlcVVybCxcbiAgICAvLyBUaGlzIGNhbiBiZSBjYWxsZWQgZHVyaW5nIHRoZSBTU1IgZmxvdyB2aWEgUHJlZmV0Y2hQYWdlTGlua3NJbXBsIHNvXG4gICAgLy8gZG9uJ3QgYXNzdW1lIHdpbmRvdyBpcyBhdmFpbGFibGVcbiAgICB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJzZXJ2ZXI6Ly9zaW5nbGVmZXRjaC9cIiA6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgKSA6IHJlcVVybDtcbiAgaWYgKHVybC5wYXRobmFtZSA9PT0gXCIvXCIpIHtcbiAgICB1cmwucGF0aG5hbWUgPSBcIl9yb290LmRhdGFcIjtcbiAgfSBlbHNlIGlmIChiYXNlbmFtZSAmJiBzdHJpcEJhc2VuYW1lKHVybC5wYXRobmFtZSwgYmFzZW5hbWUpID09PSBcIi9cIikge1xuICAgIHVybC5wYXRobmFtZSA9IGAke2Jhc2VuYW1lLnJlcGxhY2UoL1xcLyQvLCBcIlwiKX0vX3Jvb3QuZGF0YWA7XG4gIH0gZWxzZSB7XG4gICAgdXJsLnBhdGhuYW1lID0gYCR7dXJsLnBhdGhuYW1lLnJlcGxhY2UoL1xcLyQvLCBcIlwiKX0uZGF0YWA7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoQW5kRGVjb2RlVmlhVHVyYm9TdHJlYW0oYXJncywgYmFzZW5hbWUsIHRhcmdldFJvdXRlcykge1xuICBsZXQgeyByZXF1ZXN0IH0gPSBhcmdzO1xuICBsZXQgdXJsID0gc2luZ2xlRmV0Y2hVcmwocmVxdWVzdC51cmwsIGJhc2VuYW1lKTtcbiAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBcIkdFVFwiKSB7XG4gICAgdXJsID0gc3RyaXBJbmRleFBhcmFtKHVybCk7XG4gICAgaWYgKHRhcmdldFJvdXRlcykge1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJfcm91dGVzXCIsIHRhcmdldFJvdXRlcy5qb2luKFwiLFwiKSk7XG4gICAgfVxuICB9XG4gIGxldCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIGF3YWl0IGNyZWF0ZVJlcXVlc3RJbml0KHJlcXVlc3QpKTtcbiAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCAmJiAhcmVzLmhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXNwb25zZVwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlSW1wbCg0MDQsIFwiTm90IEZvdW5kXCIsIHRydWUpO1xuICB9XG4gIGlmIChyZXMuc3RhdHVzID09PSAyMDQgJiYgcmVzLmhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZWRpcmVjdFwiKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IFNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVMsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJlZGlyZWN0OiB7XG4gICAgICAgICAgcmVkaXJlY3Q6IHJlcy5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVkaXJlY3RcIiksXG4gICAgICAgICAgc3RhdHVzOiBOdW1iZXIocmVzLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1TdGF0dXNcIikgfHwgXCIzMDJcIiksXG4gICAgICAgICAgcmV2YWxpZGF0ZTogcmVzLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpID09PSBcInRydWVcIixcbiAgICAgICAgICByZWxvYWQ6IHJlcy5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpID09PSBcInRydWVcIixcbiAgICAgICAgICByZXBsYWNlOiByZXMuaGVhZGVycy5nZXQoXCJYLVJlbWl4LVJlcGxhY2VcIikgPT09IFwidHJ1ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGlmIChOT19CT0RZX1NUQVRVU19DT0RFUy5oYXMocmVzLnN0YXR1cykpIHtcbiAgICBsZXQgcm91dGVzID0ge307XG4gICAgaWYgKHRhcmdldFJvdXRlcyAmJiByZXF1ZXN0Lm1ldGhvZCAhPT0gXCJHRVRcIikge1xuICAgICAgcm91dGVzW3RhcmdldFJvdXRlc1swXV0gPSB7IGRhdGE6IHZvaWQgMCB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgZGF0YTogeyByb3V0ZXMgfVxuICAgIH07XG4gIH1cbiAgaW52YXJpYW50MihyZXMuYm9keSwgXCJObyByZXNwb25zZSBib2R5IHRvIGRlY29kZVwiKTtcbiAgdHJ5IHtcbiAgICBsZXQgZGVjb2RlZCA9IGF3YWl0IGRlY29kZVZpYVR1cmJvU3RyZWFtKHJlcy5ib2R5LCB3aW5kb3cpO1xuICAgIGxldCBkYXRhMjtcbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgIGxldCB0eXBlZCA9IGRlY29kZWQudmFsdWU7XG4gICAgICBpZiAoU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCBpbiB0eXBlZCkge1xuICAgICAgICBkYXRhMiA9IHsgcmVkaXJlY3Q6IHR5cGVkW1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2xdIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhMiA9IHsgcm91dGVzOiB0eXBlZCB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdHlwZWQgPSBkZWNvZGVkLnZhbHVlO1xuICAgICAgbGV0IHJvdXRlSWQgPSB0YXJnZXRSb3V0ZXM/LlswXTtcbiAgICAgIGludmFyaWFudDIocm91dGVJZCwgXCJObyByb3V0ZUlkIGZvdW5kIGZvciBzaW5nbGUgZmV0Y2ggY2FsbCBkZWNvZGluZ1wiKTtcbiAgICAgIGlmIChcInJlZGlyZWN0XCIgaW4gdHlwZWQpIHtcbiAgICAgICAgZGF0YTIgPSB7IHJlZGlyZWN0OiB0eXBlZCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YTIgPSB7IHJvdXRlczogeyBbcm91dGVJZF06IHR5cGVkIH0gfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiByZXMuc3RhdHVzLCBkYXRhOiBkYXRhMiB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGRlY29kZSB0dXJiby1zdHJlYW0gcmVzcG9uc2VcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY29kZVZpYVR1cmJvU3RyZWFtKGJvZHksIGdsb2JhbDIpIHtcbiAgcmV0dXJuIGRlY29kZShib2R5LCB7XG4gICAgcGx1Z2luczogW1xuICAgICAgKHR5cGUsIC4uLnJlc3QpID0+IHtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiU2FuaXRpemVkRXJyb3JcIikge1xuICAgICAgICAgIGxldCBbbmFtZSwgbWVzc2FnZSwgc3RhY2tdID0gcmVzdDtcbiAgICAgICAgICBsZXQgQ29uc3RydWN0b3IgPSBFcnJvcjtcbiAgICAgICAgICBpZiAobmFtZSAmJiBuYW1lIGluIGdsb2JhbDIgJiYgdHlwZW9mIGdsb2JhbDJbbmFtZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgQ29uc3RydWN0b3IgPSBnbG9iYWwyW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgQ29uc3RydWN0b3IobWVzc2FnZSk7XG4gICAgICAgICAgZXJyb3Iuc3RhY2sgPSBzdGFjaztcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJFcnJvclJlc3BvbnNlXCIpIHtcbiAgICAgICAgICBsZXQgW2RhdGEyLCBzdGF0dXMsIHN0YXR1c1RleHRdID0gcmVzdDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IG5ldyBFcnJvclJlc3BvbnNlSW1wbChzdGF0dXMsIHN0YXR1c1RleHQsIGRhdGEyKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiU2luZ2xlRmV0Y2hSZWRpcmVjdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHsgW1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2xdOiByZXN0WzBdIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJTaW5nbGVGZXRjaENsYXNzSW5zdGFuY2VcIikge1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXN0WzBdIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiU2luZ2xlRmV0Y2hGYWxsYmFja1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVud3JhcFNpbmdsZUZldGNoUmVzdWx0KHJlc3VsdCwgcm91dGVJZCkge1xuICBpZiAoXCJyZWRpcmVjdFwiIGluIHJlc3VsdCkge1xuICAgIGxldCB7XG4gICAgICByZWRpcmVjdDogbG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRlLFxuICAgICAgcmVsb2FkLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgICBzdGF0dXNcbiAgICB9ID0gcmVzdWx0LnJlZGlyZWN0O1xuICAgIHRocm93IHJlZGlyZWN0KGxvY2F0aW9uLCB7XG4gICAgICBzdGF0dXMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC8vIFRocmVlIFIncyBvZiByZWRpcmVjdGluZyAobG9sIFZlZXApXG4gICAgICAgIC4uLnJldmFsaWRhdGUgPyB7IFwiWC1SZW1peC1SZXZhbGlkYXRlXCI6IFwieWVzXCIgfSA6IG51bGwsXG4gICAgICAgIC4uLnJlbG9hZCA/IHsgXCJYLVJlbWl4LVJlbG9hZC1Eb2N1bWVudFwiOiBcInllc1wiIH0gOiBudWxsLFxuICAgICAgICAuLi5yZXBsYWNlMiA/IHsgXCJYLVJlbWl4LVJlcGxhY2VcIjogXCJ5ZXNcIiB9IDogbnVsbFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxldCByb3V0ZVJlc3VsdCA9IHJlc3VsdC5yb3V0ZXNbcm91dGVJZF07XG4gIGlmIChyb3V0ZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFNpbmdsZUZldGNoTm9SZXN1bHRFcnJvcihcbiAgICAgIGBObyByZXN1bHQgZm91bmQgZm9yIHJvdXRlSWQgXCIke3JvdXRlSWR9XCJgXG4gICAgKTtcbiAgfSBlbHNlIGlmIChcImVycm9yXCIgaW4gcm91dGVSZXN1bHQpIHtcbiAgICB0aHJvdyByb3V0ZVJlc3VsdC5lcnJvcjtcbiAgfSBlbHNlIGlmIChcImRhdGFcIiBpbiByb3V0ZVJlc3VsdCkge1xuICAgIHJldHVybiByb3V0ZVJlc3VsdC5kYXRhO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNwb25zZSBmb3VuZCBmb3Igcm91dGVJZCBcIiR7cm91dGVJZH1cImApO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVEZWZlcnJlZDIoKSB7XG4gIGxldCByZXNvbHZlO1xuICBsZXQgcmVqZWN0O1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSBhc3luYyAodmFsKSA9PiB7XG4gICAgICByZXModmFsKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWplY3QgPSBhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgIHJlaihlcnJvcik7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgLy9AdHMtaWdub3JlXG4gICAgcmVzb2x2ZSxcbiAgICAvL0B0cy1pZ25vcmVcbiAgICByZWplY3RcbiAgfTtcbn1cblxuLy8gbGliL2RvbS9zc3IvZm9nLW9mLXdhci50c1xudmFyIFJlYWN0OCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcblxuLy8gbGliL2RvbS9zc3Ivcm91dGVzLnRzeFxudmFyIFJlYWN0NyA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcblxuLy8gbGliL2RvbS9zc3IvZXJyb3JCb3VuZGFyaWVzLnRzeFxudmFyIFJlYWN0NSA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBSZW1peEVycm9yQm91bmRhcnkgPSBjbGFzcyBleHRlbmRzIFJlYWN0NS5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0geyBlcnJvcjogcHJvcHMuZXJyb3IgfHwgbnVsbCwgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUubG9jYXRpb24gIT09IHByb3BzLmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4geyBlcnJvcjogcHJvcHMuZXJyb3IgfHwgbnVsbCwgbG9jYXRpb246IHByb3BzLmxvY2F0aW9uIH07XG4gICAgfVxuICAgIHJldHVybiB7IGVycm9yOiBwcm9wcy5lcnJvciB8fCBzdGF0ZS5lcnJvciwgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uIH07XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSxcbiAgICAgICAge1xuICAgICAgICAgIGVycm9yOiB0aGlzLnN0YXRlLmVycm9yLFxuICAgICAgICAgIGlzT3V0c2lkZVJlbWl4QXBwOiB0cnVlXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIFJlbWl4Um9vdERlZmF1bHRFcnJvckJvdW5kYXJ5KHtcbiAgZXJyb3IsXG4gIGlzT3V0c2lkZVJlbWl4QXBwXG59KSB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICBsZXQgaGV5RGV2ZWxvcGVyID0gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFxuICAgIFwic2NyaXB0XCIsXG4gICAge1xuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBgXG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwiXFx1ezFGNEJGfSBIZXkgZGV2ZWxvcGVyIFxcdXsxRjQ0Qn0uIFlvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIHdoZW4geW91ciBhcHAgdGhyb3dzIGVycm9ycy4gQ2hlY2sgb3V0IGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvdy10by9lcnJvci1ib3VuZGFyeSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICApO1xuICAgICAgYFxuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgaWYgKGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSkge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoQm91bmRhcnlTaGVsbCwgeyB0aXRsZTogXCJVbmhhbmRsZWQgVGhyb3duIFJlc3BvbnNlIVwiIH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImgxXCIsIHsgc3R5bGU6IHsgZm9udFNpemU6IFwiMjRweFwiIH0gfSwgZXJyb3Iuc3RhdHVzLCBcIiBcIiwgZXJyb3Iuc3RhdHVzVGV4dCksIEVOQUJMRV9ERVZfV0FSTklOR1MgPyBoZXlEZXZlbG9wZXIgOiBudWxsKTtcbiAgfVxuICBsZXQgZXJyb3JJbnN0YW5jZTtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBlcnJvckluc3RhbmNlID0gZXJyb3I7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGVycm9yU3RyaW5nID0gZXJyb3IgPT0gbnVsbCA/IFwiVW5rbm93biBFcnJvclwiIDogdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIFwidG9TdHJpbmdcIiBpbiBlcnJvciA/IGVycm9yLnRvU3RyaW5nKCkgOiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG4gICAgZXJyb3JJbnN0YW5jZSA9IG5ldyBFcnJvcihlcnJvclN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICBCb3VuZGFyeVNoZWxsLFxuICAgIHtcbiAgICAgIHRpdGxlOiBcIkFwcGxpY2F0aW9uIEVycm9yIVwiLFxuICAgICAgaXNPdXRzaWRlUmVtaXhBcHBcbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImgxXCIsIHsgc3R5bGU6IHsgZm9udFNpemU6IFwiMjRweFwiIH0gfSwgXCJBcHBsaWNhdGlvbiBFcnJvclwiKSxcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInByZVwiLFxuICAgICAge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBhZGRpbmc6IFwiMnJlbVwiLFxuICAgICAgICAgIGJhY2tncm91bmQ6IFwiaHNsYSgxMCwgNTAlLCA1MCUsIDAuMSlcIixcbiAgICAgICAgICBjb2xvcjogXCJyZWRcIixcbiAgICAgICAgICBvdmVyZmxvdzogXCJhdXRvXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVycm9ySW5zdGFuY2Uuc3RhY2tcbiAgICApLFxuICAgIGhleURldmVsb3BlclxuICApO1xufVxuZnVuY3Rpb24gQm91bmRhcnlTaGVsbCh7XG4gIHRpdGxlLFxuICByZW5kZXJTY3JpcHRzLFxuICBpc091dHNpZGVSZW1peEFwcCxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgbGV0IHsgcm91dGVNb2R1bGVzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGlmIChyb3V0ZU1vZHVsZXMucm9vdD8uTGF5b3V0ICYmICFpc091dHNpZGVSZW1peEFwcCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwiaHRtbFwiLCB7IGxhbmc6IFwiZW5cIiB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoXCJoZWFkXCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwgeyBjaGFyU2V0OiBcInV0Zi04XCIgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcbiAgICBcIm1ldGFcIixcbiAgICB7XG4gICAgICBuYW1lOiBcInZpZXdwb3J0XCIsXG4gICAgICBjb250ZW50OiBcIndpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTEsdmlld3BvcnQtZml0PWNvdmVyXCJcbiAgICB9XG4gICksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIG51bGwsIHRpdGxlKSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDUuY3JlYXRlRWxlbWVudChcImJvZHlcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0NS5jcmVhdGVFbGVtZW50KFwibWFpblwiLCB7IHN0eWxlOiB7IGZvbnRGYW1pbHk6IFwic3lzdGVtLXVpLCBzYW5zLXNlcmlmXCIsIHBhZGRpbmc6IFwiMnJlbVwiIH0gfSwgY2hpbGRyZW4sIHJlbmRlclNjcmlwdHMgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q1LmNyZWF0ZUVsZW1lbnQoU2NyaXB0cywgbnVsbCkgOiBudWxsKSkpO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9mYWxsYmFjay50c3hcbnZhciBSZWFjdDYgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBSZW1peFJvb3REZWZhdWx0SHlkcmF0ZUZhbGxiYWNrKCkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0Ni5jcmVhdGVFbGVtZW50KEJvdW5kYXJ5U2hlbGwsIHsgdGl0bGU6IFwiTG9hZGluZy4uLlwiLCByZW5kZXJTY3JpcHRzOiB0cnVlIH0sIEVOQUJMRV9ERVZfV0FSTklOR1MgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q2LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzY3JpcHRcIixcbiAgICB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICBfX2h0bWw6IGBcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgXCJcXHV7MUY0QkZ9IEhleSBkZXZlbG9wZXIgXFx1ezFGNDRCfS4gWW91IGNhbiBwcm92aWRlIGEgd2F5IGJldHRlciBVWCB0aGFuIHRoaXMgXCIgK1xuICAgICAgICAgICAgICAgIFwid2hlbiB5b3VyIGFwcCBpcyBsb2FkaW5nIEpTIG1vZHVsZXMgYW5kL29yIHJ1bm5pbmcgXFxgY2xpZW50TG9hZGVyXFxgIFwiICtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9ucy4gQ2hlY2sgb3V0IGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3N0YXJ0L2ZyYW1ld29yay9yb3V0ZS1tb2R1bGUjaHlkcmF0ZWZhbGxiYWNrIFwiICtcbiAgICAgICAgICAgICAgICBcImZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBgXG4gICAgICB9XG4gICAgfVxuICApIDogbnVsbCk7XG59XG5cbi8vIGxpYi9kb20vc3NyL3JvdXRlcy50c3hcbmZ1bmN0aW9uIGdyb3VwUm91dGVzQnlQYXJlbnRJZChtYW5pZmVzdCkge1xuICBsZXQgcm91dGVzID0ge307XG4gIE9iamVjdC52YWx1ZXMobWFuaWZlc3QpLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgaWYgKHJvdXRlKSB7XG4gICAgICBsZXQgcGFyZW50SWQgPSByb3V0ZS5wYXJlbnRJZCB8fCBcIlwiO1xuICAgICAgaWYgKCFyb3V0ZXNbcGFyZW50SWRdKSB7XG4gICAgICAgIHJvdXRlc1twYXJlbnRJZF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHJvdXRlc1twYXJlbnRJZF0ucHVzaChyb3V0ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvdXRlcztcbn1cbmZ1bmN0aW9uIGdldFJvdXRlQ29tcG9uZW50cyhyb3V0ZSwgcm91dGVNb2R1bGUsIGlzU3BhTW9kZSkge1xuICBsZXQgQ29tcG9uZW50NCA9IGdldFJvdXRlTW9kdWxlQ29tcG9uZW50KHJvdXRlTW9kdWxlKTtcbiAgbGV0IEh5ZHJhdGVGYWxsYmFjayA9IHJvdXRlTW9kdWxlLkh5ZHJhdGVGYWxsYmFjayAmJiAoIWlzU3BhTW9kZSB8fCByb3V0ZS5pZCA9PT0gXCJyb290XCIpID8gcm91dGVNb2R1bGUuSHlkcmF0ZUZhbGxiYWNrIDogcm91dGUuaWQgPT09IFwicm9vdFwiID8gUmVtaXhSb290RGVmYXVsdEh5ZHJhdGVGYWxsYmFjayA6IHZvaWQgMDtcbiAgbGV0IEVycm9yQm91bmRhcnkgPSByb3V0ZU1vZHVsZS5FcnJvckJvdW5kYXJ5ID8gcm91dGVNb2R1bGUuRXJyb3JCb3VuZGFyeSA6IHJvdXRlLmlkID09PSBcInJvb3RcIiA/ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDcuY3JlYXRlRWxlbWVudChSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSwgeyBlcnJvcjogdXNlUm91dGVFcnJvcigpIH0pIDogdm9pZCAwO1xuICBpZiAocm91dGUuaWQgPT09IFwicm9vdFwiICYmIHJvdXRlTW9kdWxlLkxheW91dCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5Db21wb25lbnQ0ID8ge1xuICAgICAgICBlbGVtZW50OiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQocm91dGVNb2R1bGUuTGF5b3V0LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50NCwgbnVsbCkpXG4gICAgICB9IDogeyBDb21wb25lbnQ6IENvbXBvbmVudDQgfSxcbiAgICAgIC4uLkVycm9yQm91bmRhcnkgPyB7XG4gICAgICAgIGVycm9yRWxlbWVudDogLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KHJvdXRlTW9kdWxlLkxheW91dCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0Ny5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIG51bGwpKVxuICAgICAgfSA6IHsgRXJyb3JCb3VuZGFyeSB9LFxuICAgICAgLi4uSHlkcmF0ZUZhbGxiYWNrID8ge1xuICAgICAgICBoeWRyYXRlRmFsbGJhY2tFbGVtZW50OiAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQocm91dGVNb2R1bGUuTGF5b3V0LCBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q3LmNyZWF0ZUVsZW1lbnQoSHlkcmF0ZUZhbGxiYWNrLCBudWxsKSlcbiAgICAgIH0gOiB7IEh5ZHJhdGVGYWxsYmFjayB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4geyBDb21wb25lbnQ6IENvbXBvbmVudDQsIEVycm9yQm91bmRhcnksIEh5ZHJhdGVGYWxsYmFjayB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VydmVyUm91dGVzKG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIGZ1dHVyZSwgaXNTcGFNb2RlLCBwYXJlbnRJZCA9IFwiXCIsIHJvdXRlc0J5UGFyZW50SWQgPSBncm91cFJvdXRlc0J5UGFyZW50SWQobWFuaWZlc3QpLCBzcGFNb2RlTGF6eVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoeyBDb21wb25lbnQ6ICgpID0+IG51bGwgfSkpIHtcbiAgcmV0dXJuIChyb3V0ZXNCeVBhcmVudElkW3BhcmVudElkXSB8fCBbXSkubWFwKChyb3V0ZSkgPT4ge1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IHJvdXRlTW9kdWxlc1tyb3V0ZS5pZF07XG4gICAgaW52YXJpYW50MihcbiAgICAgIHJvdXRlTW9kdWxlLFxuICAgICAgXCJObyBgcm91dGVNb2R1bGVgIGF2YWlsYWJsZSB0byBjcmVhdGUgc2VydmVyIHJvdXRlc1wiXG4gICAgKTtcbiAgICBsZXQgZGF0YVJvdXRlID0ge1xuICAgICAgLi4uZ2V0Um91dGVDb21wb25lbnRzKHJvdXRlLCByb3V0ZU1vZHVsZSwgaXNTcGFNb2RlKSxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUsXG4gICAgICBpZDogcm91dGUuaWQsXG4gICAgICBpbmRleDogcm91dGUuaW5kZXgsXG4gICAgICBwYXRoOiByb3V0ZS5wYXRoLFxuICAgICAgaGFuZGxlOiByb3V0ZU1vZHVsZS5oYW5kbGUsXG4gICAgICAvLyBGb3IgU1BBIE1vZGUsIGFsbCByb3V0ZXMgYXJlIGxhenkgZXhjZXB0IHJvb3QuICBIb3dldmVyIHdlIHRlbGwgdGhlXG4gICAgICAvLyByb3V0ZXIgcm9vdCBpcyBhbHNvIGxhenkgaGVyZSB0b28gc2luY2Ugd2UgZG9uJ3QgbmVlZCBhIGZ1bGxcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uIC0gd2UganVzdCBuZWVkIGEgYGxhenlgIHByb3AgdG8gdGVsbCB0aGUgUlIgcmVuZGVyaW5nXG4gICAgICAvLyB3aGVyZSB0byBzdG9wIHdoaWNoIGlzIGFsd2F5cyBhdCB0aGUgcm9vdCByb3V0ZSBpbiBTUEEgbW9kZVxuICAgICAgbGF6eTogaXNTcGFNb2RlID8gKCkgPT4gc3BhTW9kZUxhenlQcm9taXNlIDogdm9pZCAwLFxuICAgICAgLy8gRm9yIHBhcnRpYWwgaHlkcmF0aW9uIHJlbmRlcmluZywgd2UgbmVlZCB0byBpbmRpY2F0ZSB3aGVuIHRoZSByb3V0ZVxuICAgICAgLy8gaGFzIGEgbG9hZGVyL2NsaWVudExvYWRlciwgYnV0IGl0IHdvbid0IGV2ZXIgYmUgY2FsbGVkIGR1cmluZyB0aGUgc3RhdGljXG4gICAgICAvLyByZW5kZXIsIHNvIGp1c3QgZ2l2ZSBpdCBhIG5vLW9wIGZ1bmN0aW9uIHNvIHdlIGNhbiByZW5kZXIgZG93biB0byB0aGVcbiAgICAgIC8vIHByb3BlciBmYWxsYmFja1xuICAgICAgbG9hZGVyOiByb3V0ZS5oYXNMb2FkZXIgfHwgcm91dGUuaGFzQ2xpZW50TG9hZGVyID8gKCkgPT4gbnVsbCA6IHZvaWQgMFxuICAgICAgLy8gV2UgZG9uJ3QgbmVlZCBtaWRkbGV3YXJlL2FjdGlvbi9zaG91bGRSZXZhbGlkYXRlIG9uIHRoZXNlIHJvdXRlcyBzaW5jZVxuICAgICAgLy8gdGhleSdyZSBmb3IgYSBzdGF0aWMgcmVuZGVyXG4gICAgfTtcbiAgICBsZXQgY2hpbGRyZW4gPSBjcmVhdGVTZXJ2ZXJSb3V0ZXMoXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIHJvdXRlTW9kdWxlcyxcbiAgICAgIGZ1dHVyZSxcbiAgICAgIGlzU3BhTW9kZSxcbiAgICAgIHJvdXRlLmlkLFxuICAgICAgcm91dGVzQnlQYXJlbnRJZCxcbiAgICAgIHNwYU1vZGVMYXp5UHJvbWlzZVxuICAgICk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIGRhdGFSb3V0ZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHJldHVybiBkYXRhUm91dGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dChuZWVkc1JldmFsaWRhdGlvbiwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlc0NhY2hlLCBpbml0aWFsU3RhdGUsIHNzciwgaXNTcGFNb2RlKSB7XG4gIHJldHVybiBjcmVhdGVDbGllbnRSb3V0ZXMoXG4gICAgbWFuaWZlc3QsXG4gICAgcm91dGVNb2R1bGVzQ2FjaGUsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIHNzcixcbiAgICBpc1NwYU1vZGUsXG4gICAgXCJcIixcbiAgICBncm91cFJvdXRlc0J5UGFyZW50SWQobWFuaWZlc3QpLFxuICAgIG5lZWRzUmV2YWxpZGF0aW9uXG4gICk7XG59XG5mdW5jdGlvbiBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKHR5cGUsIHJvdXRlKSB7XG4gIGlmICh0eXBlID09PSBcImxvYWRlclwiICYmICFyb3V0ZS5oYXNMb2FkZXIgfHwgdHlwZSA9PT0gXCJhY3Rpb25cIiAmJiAhcm91dGUuaGFzQWN0aW9uKSB7XG4gICAgbGV0IGZuID0gdHlwZSA9PT0gXCJhY3Rpb25cIiA/IFwic2VydmVyQWN0aW9uKClcIiA6IFwic2VydmVyTG9hZGVyKClcIjtcbiAgICBsZXQgbXNnID0gYFlvdSBhcmUgdHJ5aW5nIHRvIGNhbGwgJHtmbn0gb24gYSByb3V0ZSB0aGF0IGRvZXMgbm90IGhhdmUgYSBzZXJ2ZXIgJHt0eXBlfSAocm91dGVJZDogXCIke3JvdXRlLmlkfVwiKWA7XG4gICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgIHRocm93IG5ldyBFcnJvclJlc3BvbnNlSW1wbCg0MDAsIFwiQmFkIFJlcXVlc3RcIiwgbmV3IEVycm9yKG1zZyksIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBub0FjdGlvbkRlZmluZWRFcnJvcih0eXBlLCByb3V0ZUlkKSB7XG4gIGxldCBhcnRpY2xlID0gdHlwZSA9PT0gXCJjbGllbnRBY3Rpb25cIiA/IFwiYVwiIDogXCJhblwiO1xuICBsZXQgbXNnID0gYFJvdXRlIFwiJHtyb3V0ZUlkfVwiIGRvZXMgbm90IGhhdmUgJHthcnRpY2xlfSAke3R5cGV9LCBidXQgeW91IGFyZSB0cnlpbmcgdG8gc3VibWl0IHRvIGl0LiBUbyBmaXggdGhpcywgcGxlYXNlIGFkZCAke2FydGljbGV9IFxcYCR7dHlwZX1cXGAgZnVuY3Rpb24gdG8gdGhlIHJvdXRlYDtcbiAgY29uc29sZS5lcnJvcihtc2cpO1xuICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZUltcGwoNDA1LCBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLCBuZXcgRXJyb3IobXNnKSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnRSb3V0ZXMobWFuaWZlc3QsIHJvdXRlTW9kdWxlc0NhY2hlLCBpbml0aWFsU3RhdGUsIHNzciwgaXNTcGFNb2RlLCBwYXJlbnRJZCA9IFwiXCIsIHJvdXRlc0J5UGFyZW50SWQgPSBncm91cFJvdXRlc0J5UGFyZW50SWQobWFuaWZlc3QpLCBuZWVkc1JldmFsaWRhdGlvbikge1xuICByZXR1cm4gKHJvdXRlc0J5UGFyZW50SWRbcGFyZW50SWRdIHx8IFtdKS5tYXAoKHJvdXRlKSA9PiB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdO1xuICAgIGZ1bmN0aW9uIGZldGNoU2VydmVySGFuZGxlcihzaW5nbGVGZXRjaCkge1xuICAgICAgaW52YXJpYW50MihcbiAgICAgICAgdHlwZW9mIHNpbmdsZUZldGNoID09PSBcImZ1bmN0aW9uXCIsXG4gICAgICAgIFwiTm8gc2luZ2xlIGZldGNoIGZ1bmN0aW9uIGF2YWlsYWJsZSBmb3Igcm91dGUgaGFuZGxlclwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIHNpbmdsZUZldGNoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZldGNoU2VydmVyTG9hZGVyKHNpbmdsZUZldGNoKSB7XG4gICAgICBpZiAoIXJvdXRlLmhhc0xvYWRlcikgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgIHJldHVybiBmZXRjaFNlcnZlckhhbmRsZXIoc2luZ2xlRmV0Y2gpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmZXRjaFNlcnZlckFjdGlvbihzaW5nbGVGZXRjaCkge1xuICAgICAgaWYgKCFyb3V0ZS5oYXNBY3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbm9BY3Rpb25EZWZpbmVkRXJyb3IoXCJhY3Rpb25cIiwgcm91dGUuaWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZldGNoU2VydmVySGFuZGxlcihzaW5nbGVGZXRjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWZldGNoTW9kdWxlKG1vZHVsZVBhdGgpIHtcbiAgICAgIGltcG9ydChcbiAgICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICAgIC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi9cbiAgICAgICAgbW9kdWxlUGF0aFxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlZmV0Y2hSb3V0ZU1vZHVsZUNodW5rcyhyb3V0ZTIpIHtcbiAgICAgIGlmIChyb3V0ZTIuY2xpZW50QWN0aW9uTW9kdWxlKSB7XG4gICAgICAgIHByZWZldGNoTW9kdWxlKHJvdXRlMi5jbGllbnRBY3Rpb25Nb2R1bGUpO1xuICAgICAgfVxuICAgICAgaWYgKHJvdXRlMi5jbGllbnRMb2FkZXJNb2R1bGUpIHtcbiAgICAgICAgcHJlZmV0Y2hNb2R1bGUocm91dGUyLmNsaWVudExvYWRlck1vZHVsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgbGV0IGNhY2hlZE1vZHVsZSA9IHJvdXRlTW9kdWxlc0NhY2hlW3JvdXRlLmlkXTtcbiAgICAgIGxldCBsaW5rUHJlZmV0Y2hQcm9taXNlID0gY2FjaGVkTW9kdWxlID8gcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlLCBjYWNoZWRNb2R1bGUpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaGFuZGxlcigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYXdhaXQgbGlua1ByZWZldGNoUHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRhdGFSb3V0ZSA9IHtcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGhcbiAgICB9O1xuICAgIGlmIChyb3V0ZU1vZHVsZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihkYXRhUm91dGUsIHtcbiAgICAgICAgLi4uZGF0YVJvdXRlLFxuICAgICAgICAuLi5nZXRSb3V0ZUNvbXBvbmVudHMocm91dGUsIHJvdXRlTW9kdWxlLCBpc1NwYU1vZGUpLFxuICAgICAgICB1bnN0YWJsZV9taWRkbGV3YXJlOiByb3V0ZU1vZHVsZS51bnN0YWJsZV9jbGllbnRNaWRkbGV3YXJlLFxuICAgICAgICBoYW5kbGU6IHJvdXRlTW9kdWxlLmhhbmRsZSxcbiAgICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogZ2V0U2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uKFxuICAgICAgICAgIGRhdGFSb3V0ZS5wYXRoLFxuICAgICAgICAgIHJvdXRlTW9kdWxlLFxuICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgIHNzcixcbiAgICAgICAgICBuZWVkc1JldmFsaWRhdGlvblxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGxldCBoYXNJbml0aWFsRGF0YSA9IGluaXRpYWxTdGF0ZSAmJiBpbml0aWFsU3RhdGUubG9hZGVyRGF0YSAmJiByb3V0ZS5pZCBpbiBpbml0aWFsU3RhdGUubG9hZGVyRGF0YTtcbiAgICAgIGxldCBpbml0aWFsRGF0YSA9IGhhc0luaXRpYWxEYXRhID8gaW5pdGlhbFN0YXRlPy5sb2FkZXJEYXRhPy5bcm91dGUuaWRdIDogdm9pZCAwO1xuICAgICAgbGV0IGhhc0luaXRpYWxFcnJvciA9IGluaXRpYWxTdGF0ZSAmJiBpbml0aWFsU3RhdGUuZXJyb3JzICYmIHJvdXRlLmlkIGluIGluaXRpYWxTdGF0ZS5lcnJvcnM7XG4gICAgICBsZXQgaW5pdGlhbEVycm9yID0gaGFzSW5pdGlhbEVycm9yID8gaW5pdGlhbFN0YXRlPy5lcnJvcnM/Lltyb3V0ZS5pZF0gOiB2b2lkIDA7XG4gICAgICBsZXQgaXNIeWRyYXRpb25SZXF1ZXN0ID0gbmVlZHNSZXZhbGlkYXRpb24gPT0gbnVsbCAmJiAocm91dGVNb2R1bGUuY2xpZW50TG9hZGVyPy5oeWRyYXRlID09PSB0cnVlIHx8ICFyb3V0ZS5oYXNMb2FkZXIpO1xuICAgICAgZGF0YVJvdXRlLmxvYWRlciA9IGFzeW5jICh7IHJlcXVlc3QsIHBhcmFtcywgY29udGV4dCB9LCBzaW5nbGVGZXRjaCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBwcmVmZXRjaFN0eWxlc0FuZENhbGxIYW5kbGVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGludmFyaWFudDIoXG4gICAgICAgICAgICAgIHJvdXRlTW9kdWxlLFxuICAgICAgICAgICAgICBcIk5vIGByb3V0ZU1vZHVsZWAgYXZhaWxhYmxlIGZvciBjcml0aWNhbC1yb3V0ZSBsb2FkZXJcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghcm91dGVNb2R1bGUuY2xpZW50TG9hZGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm91dGVNb2R1bGUuY2xpZW50TG9hZGVyKHtcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICBhc3luYyBzZXJ2ZXJMb2FkZXIoKSB7XG4gICAgICAgICAgICAgICAgcHJldmVudEludmFsaWRTZXJ2ZXJIYW5kbGVyQ2FsbChcImxvYWRlclwiLCByb3V0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzSHlkcmF0aW9uUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhc0luaXRpYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWFsRGF0YTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChoYXNJbml0aWFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaW5pdGlhbEVycm9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJMb2FkZXIoc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlzSHlkcmF0aW9uUmVxdWVzdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZGF0YVJvdXRlLmxvYWRlci5oeWRyYXRlID0gc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyKFxuICAgICAgICByb3V0ZS5pZCxcbiAgICAgICAgcm91dGVNb2R1bGUuY2xpZW50TG9hZGVyLFxuICAgICAgICByb3V0ZS5oYXNMb2FkZXIsXG4gICAgICAgIGlzU3BhTW9kZVxuICAgICAgKTtcbiAgICAgIGRhdGFSb3V0ZS5hY3Rpb24gPSAoeyByZXF1ZXN0LCBwYXJhbXMsIGNvbnRleHQgfSwgc2luZ2xlRmV0Y2gpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGludmFyaWFudDIoXG4gICAgICAgICAgICByb3V0ZU1vZHVsZSxcbiAgICAgICAgICAgIFwiTm8gYHJvdXRlTW9kdWxlYCBhdmFpbGFibGUgZm9yIGNyaXRpY2FsLXJvdXRlIGFjdGlvblwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIXJvdXRlTW9kdWxlLmNsaWVudEFjdGlvbikge1xuICAgICAgICAgICAgaWYgKGlzU3BhTW9kZSkge1xuICAgICAgICAgICAgICB0aHJvdyBub0FjdGlvbkRlZmluZWRFcnJvcihcImNsaWVudEFjdGlvblwiLCByb3V0ZS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJBY3Rpb24oc2luZ2xlRmV0Y2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcm91dGVNb2R1bGUuY2xpZW50QWN0aW9uKHtcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgYXN5bmMgc2VydmVyQWN0aW9uKCkge1xuICAgICAgICAgICAgICBwcmV2ZW50SW52YWxpZFNlcnZlckhhbmRsZXJDYWxsKFwiYWN0aW9uXCIsIHJvdXRlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyQWN0aW9uKHNpbmdsZUZldGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJvdXRlLmhhc0NsaWVudExvYWRlcikge1xuICAgICAgICBkYXRhUm91dGUubG9hZGVyID0gKF8sIHNpbmdsZUZldGNoKSA9PiBwcmVmZXRjaFN0eWxlc0FuZENhbGxIYW5kbGVyKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gZmV0Y2hTZXJ2ZXJMb2FkZXIoc2luZ2xlRmV0Y2gpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghcm91dGUuaGFzQ2xpZW50QWN0aW9uKSB7XG4gICAgICAgIGRhdGFSb3V0ZS5hY3Rpb24gPSAoXywgc2luZ2xlRmV0Y2gpID0+IHByZWZldGNoU3R5bGVzQW5kQ2FsbEhhbmRsZXIoKCkgPT4ge1xuICAgICAgICAgIGlmIChpc1NwYU1vZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5vQWN0aW9uRGVmaW5lZEVycm9yKFwiY2xpZW50QWN0aW9uXCIsIHJvdXRlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZldGNoU2VydmVyQWN0aW9uKHNpbmdsZUZldGNoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZXQgbGF6eVJvdXRlUHJvbWlzZTtcbiAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldExhenlSb3V0ZSgpIHtcbiAgICAgICAgaWYgKGxhenlSb3V0ZVByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgbGF6eVJvdXRlUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBsYXp5Um91dGVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBpZiAocm91dGUuY2xpZW50TG9hZGVyTW9kdWxlIHx8IHJvdXRlLmNsaWVudEFjdGlvbk1vZHVsZSkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcm91dGVNb2R1bGVQcm9taXNlID0gbG9hZFJvdXRlTW9kdWxlV2l0aEJsb2NraW5nTGlua3MoXG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHJvdXRlTW9kdWxlc0NhY2hlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwcmVmZXRjaFJvdXRlTW9kdWxlQ2h1bmtzKHJvdXRlKTtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgcm91dGVNb2R1bGVQcm9taXNlO1xuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgbGF6eVJvdXRlUHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIGRhdGFSb3V0ZS5sYXp5ID0ge1xuICAgICAgICBsb2FkZXI6IHJvdXRlLmhhc0NsaWVudExvYWRlciA/IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBsZXQgeyBjbGllbnRMb2FkZXIgfSA9IHJvdXRlLmNsaWVudExvYWRlck1vZHVsZSA/IGF3YWl0IGltcG9ydChcbiAgICAgICAgICAgIC8qIEB2aXRlLWlnbm9yZSAqL1xuICAgICAgICAgICAgLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqL1xuICAgICAgICAgICAgcm91dGUuY2xpZW50TG9hZGVyTW9kdWxlXG4gICAgICAgICAgKSA6IGF3YWl0IGdldExhenlSb3V0ZSgpO1xuICAgICAgICAgIGludmFyaWFudDIoY2xpZW50TG9hZGVyLCBcIk5vIGBjbGllbnRMb2FkZXJgIGV4cG9ydCBmb3VuZFwiKTtcbiAgICAgICAgICByZXR1cm4gKGFyZ3MsIHNpbmdsZUZldGNoKSA9PiBjbGllbnRMb2FkZXIoe1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgIGFzeW5jIHNlcnZlckxvYWRlcigpIHtcbiAgICAgICAgICAgICAgcHJldmVudEludmFsaWRTZXJ2ZXJIYW5kbGVyQ2FsbChcImxvYWRlclwiLCByb3V0ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckxvYWRlcihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gOiB2b2lkIDAsXG4gICAgICAgIGFjdGlvbjogcm91dGUuaGFzQ2xpZW50QWN0aW9uID8gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGxldCBjbGllbnRBY3Rpb25Qcm9taXNlID0gcm91dGUuY2xpZW50QWN0aW9uTW9kdWxlID8gaW1wb3J0KFxuICAgICAgICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICAgICAgICAvKiB3ZWJwYWNrSWdub3JlOiB0cnVlICovXG4gICAgICAgICAgICByb3V0ZS5jbGllbnRBY3Rpb25Nb2R1bGVcbiAgICAgICAgICApIDogZ2V0TGF6eVJvdXRlKCk7XG4gICAgICAgICAgcHJlZmV0Y2hSb3V0ZU1vZHVsZUNodW5rcyhyb3V0ZSk7XG4gICAgICAgICAgbGV0IHsgY2xpZW50QWN0aW9uIH0gPSBhd2FpdCBjbGllbnRBY3Rpb25Qcm9taXNlO1xuICAgICAgICAgIGludmFyaWFudDIoY2xpZW50QWN0aW9uLCBcIk5vIGBjbGllbnRBY3Rpb25gIGV4cG9ydCBmb3VuZFwiKTtcbiAgICAgICAgICByZXR1cm4gKGFyZ3MsIHNpbmdsZUZldGNoKSA9PiBjbGllbnRBY3Rpb24oe1xuICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgIGFzeW5jIHNlcnZlckFjdGlvbigpIHtcbiAgICAgICAgICAgICAgcHJldmVudEludmFsaWRTZXJ2ZXJIYW5kbGVyQ2FsbChcImFjdGlvblwiLCByb3V0ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBmZXRjaFNlcnZlckFjdGlvbihzaW5nbGVGZXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gOiB2b2lkIDAsXG4gICAgICAgIHVuc3RhYmxlX21pZGRsZXdhcmU6IHJvdXRlLmhhc0NsaWVudE1pZGRsZXdhcmUgPyBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgbGV0IHsgdW5zdGFibGVfY2xpZW50TWlkZGxld2FyZSB9ID0gcm91dGUuY2xpZW50TWlkZGxld2FyZU1vZHVsZSA/IGF3YWl0IGltcG9ydChcbiAgICAgICAgICAgIC8qIEB2aXRlLWlnbm9yZSAqL1xuICAgICAgICAgICAgLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqL1xuICAgICAgICAgICAgcm91dGUuY2xpZW50TWlkZGxld2FyZU1vZHVsZVxuICAgICAgICAgICkgOiBhd2FpdCBnZXRMYXp5Um91dGUoKTtcbiAgICAgICAgICBpbnZhcmlhbnQyKFxuICAgICAgICAgICAgdW5zdGFibGVfY2xpZW50TWlkZGxld2FyZSxcbiAgICAgICAgICAgIFwiTm8gYHVuc3RhYmxlX2NsaWVudE1pZGRsZXdhcmVgIGV4cG9ydCBmb3VuZFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gdW5zdGFibGVfY2xpZW50TWlkZGxld2FyZTtcbiAgICAgICAgfSA6IHZvaWQgMCxcbiAgICAgICAgc2hvdWxkUmV2YWxpZGF0ZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGxldCBsYXp5Um91dGUgPSBhd2FpdCBnZXRMYXp5Um91dGUoKTtcbiAgICAgICAgICByZXR1cm4gZ2V0U2hvdWxkUmV2YWxpZGF0ZUZ1bmN0aW9uKFxuICAgICAgICAgICAgZGF0YVJvdXRlLnBhdGgsXG4gICAgICAgICAgICBsYXp5Um91dGUsXG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHNzcixcbiAgICAgICAgICAgIG5lZWRzUmV2YWxpZGF0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlOiBhc3luYyAoKSA9PiAoYXdhaXQgZ2V0TGF6eVJvdXRlKCkpLmhhbmRsZSxcbiAgICAgICAgLy8gTm8gbmVlZCB0byB3cmFwIHRoZXNlIGluIGxheW91dCBzaW5jZSB0aGUgcm9vdCByb3V0ZSBpcyBuZXZlclxuICAgICAgICAvLyBsb2FkZWQgdmlhIHJvdXRlLmxhenkoKVxuICAgICAgICBDb21wb25lbnQ6IGFzeW5jICgpID0+IChhd2FpdCBnZXRMYXp5Um91dGUoKSkuQ29tcG9uZW50LFxuICAgICAgICBFcnJvckJvdW5kYXJ5OiByb3V0ZS5oYXNFcnJvckJvdW5kYXJ5ID8gYXN5bmMgKCkgPT4gKGF3YWl0IGdldExhenlSb3V0ZSgpKS5FcnJvckJvdW5kYXJ5IDogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSBjcmVhdGVDbGllbnRSb3V0ZXMoXG4gICAgICBtYW5pZmVzdCxcbiAgICAgIHJvdXRlTW9kdWxlc0NhY2hlLFxuICAgICAgaW5pdGlhbFN0YXRlLFxuICAgICAgc3NyLFxuICAgICAgaXNTcGFNb2RlLFxuICAgICAgcm91dGUuaWQsXG4gICAgICByb3V0ZXNCeVBhcmVudElkLFxuICAgICAgbmVlZHNSZXZhbGlkYXRpb25cbiAgICApO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSBkYXRhUm91dGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICByZXR1cm4gZGF0YVJvdXRlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNob3VsZFJldmFsaWRhdGVGdW5jdGlvbihwYXRoLCByb3V0ZSwgbWFuaWZlc3RSb3V0ZSwgc3NyLCBuZWVkc1JldmFsaWRhdGlvbikge1xuICBpZiAobmVlZHNSZXZhbGlkYXRpb24pIHtcbiAgICByZXR1cm4gd3JhcFNob3VsZFJldmFsaWRhdGVGb3JIZHIoXG4gICAgICBtYW5pZmVzdFJvdXRlLmlkLFxuICAgICAgcm91dGUuc2hvdWxkUmV2YWxpZGF0ZSxcbiAgICAgIG5lZWRzUmV2YWxpZGF0aW9uXG4gICAgKTtcbiAgfVxuICBpZiAoIXNzciAmJiBtYW5pZmVzdFJvdXRlLmhhc0xvYWRlciAmJiAhbWFuaWZlc3RSb3V0ZS5oYXNDbGllbnRMb2FkZXIpIHtcbiAgICBsZXQgbXlQYXJhbXMgPSBwYXRoID8gY29tcGlsZVBhdGgocGF0aClbMV0ubWFwKChwKSA9PiBwLnBhcmFtTmFtZSkgOiBbXTtcbiAgICBjb25zdCBkaWRQYXJhbXNDaGFuZ2UgPSAob3B0cykgPT4gbXlQYXJhbXMuc29tZSgocCkgPT4gb3B0cy5jdXJyZW50UGFyYW1zW3BdICE9PSBvcHRzLm5leHRQYXJhbXNbcF0pO1xuICAgIGlmIChyb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICBsZXQgZm4gPSByb3V0ZS5zaG91bGRSZXZhbGlkYXRlO1xuICAgICAgcmV0dXJuIChvcHRzKSA9PiBmbih7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOiBkaWRQYXJhbXNDaGFuZ2Uob3B0cylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKG9wdHMpID0+IGRpZFBhcmFtc0NoYW5nZShvcHRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNzciAmJiByb3V0ZS5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgbGV0IGZuID0gcm91dGUuc2hvdWxkUmV2YWxpZGF0ZTtcbiAgICByZXR1cm4gKG9wdHMpID0+IGZuKHsgLi4ub3B0cywgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHJvdXRlLnNob3VsZFJldmFsaWRhdGU7XG59XG5mdW5jdGlvbiB3cmFwU2hvdWxkUmV2YWxpZGF0ZUZvckhkcihyb3V0ZUlkLCByb3V0ZVNob3VsZFJldmFsaWRhdGUsIG5lZWRzUmV2YWxpZGF0aW9uKSB7XG4gIGxldCBoYW5kbGVkUmV2YWxpZGF0aW9uID0gZmFsc2U7XG4gIHJldHVybiAoYXJnKSA9PiB7XG4gICAgaWYgKCFoYW5kbGVkUmV2YWxpZGF0aW9uKSB7XG4gICAgICBoYW5kbGVkUmV2YWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZWVkc1JldmFsaWRhdGlvbi5oYXMocm91dGVJZCk7XG4gICAgfVxuICAgIHJldHVybiByb3V0ZVNob3VsZFJldmFsaWRhdGUgPyByb3V0ZVNob3VsZFJldmFsaWRhdGUoYXJnKSA6IGFyZy5kZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZU1vZHVsZVdpdGhCbG9ja2luZ0xpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IHJvdXRlTW9kdWxlUHJvbWlzZSA9IGxvYWRSb3V0ZU1vZHVsZShyb3V0ZSwgcm91dGVNb2R1bGVzKTtcbiAgbGV0IHByZWZldGNoUm91dGVDc3NQcm9taXNlID0gcHJlZmV0Y2hSb3V0ZUNzcyhyb3V0ZSk7XG4gIGxldCByb3V0ZU1vZHVsZSA9IGF3YWl0IHJvdXRlTW9kdWxlUHJvbWlzZTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgIHByZWZldGNoUm91dGVDc3NQcm9taXNlLFxuICAgIHByZWZldGNoU3R5bGVMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGUpXG4gIF0pO1xuICByZXR1cm4ge1xuICAgIENvbXBvbmVudDogZ2V0Um91dGVNb2R1bGVDb21wb25lbnQocm91dGVNb2R1bGUpLFxuICAgIEVycm9yQm91bmRhcnk6IHJvdXRlTW9kdWxlLkVycm9yQm91bmRhcnksXG4gICAgdW5zdGFibGVfY2xpZW50TWlkZGxld2FyZTogcm91dGVNb2R1bGUudW5zdGFibGVfY2xpZW50TWlkZGxld2FyZSxcbiAgICBjbGllbnRBY3Rpb246IHJvdXRlTW9kdWxlLmNsaWVudEFjdGlvbixcbiAgICBjbGllbnRMb2FkZXI6IHJvdXRlTW9kdWxlLmNsaWVudExvYWRlcixcbiAgICBoYW5kbGU6IHJvdXRlTW9kdWxlLmhhbmRsZSxcbiAgICBsaW5rczogcm91dGVNb2R1bGUubGlua3MsXG4gICAgbWV0YTogcm91dGVNb2R1bGUubWV0YSxcbiAgICBzaG91bGRSZXZhbGlkYXRlOiByb3V0ZU1vZHVsZS5zaG91bGRSZXZhbGlkYXRlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRSb3V0ZU1vZHVsZUNvbXBvbmVudChyb3V0ZU1vZHVsZSkge1xuICBpZiAocm91dGVNb2R1bGUuZGVmYXVsdCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICBsZXQgaXNFbXB0eU9iamVjdCA9IHR5cGVvZiByb3V0ZU1vZHVsZS5kZWZhdWx0ID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKHJvdXRlTW9kdWxlLmRlZmF1bHQpLmxlbmd0aCA9PT0gMDtcbiAgaWYgKCFpc0VtcHR5T2JqZWN0KSB7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlLmRlZmF1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlcihyb3V0ZUlkLCBjbGllbnRMb2FkZXIsIGhhc0xvYWRlciwgaXNTcGFNb2RlKSB7XG4gIHJldHVybiBpc1NwYU1vZGUgJiYgcm91dGVJZCAhPT0gXCJyb290XCIgfHwgY2xpZW50TG9hZGVyICE9IG51bGwgJiYgKGNsaWVudExvYWRlci5oeWRyYXRlID09PSB0cnVlIHx8IGhhc0xvYWRlciAhPT0gdHJ1ZSk7XG59XG5cbi8vIGxpYi9kb20vc3NyL2ZvZy1vZi13YXIudHNcbnZhciBuZXh0UGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xudmFyIGRpc2NvdmVyZWRQYXRoc01heFNpemUgPSAxZTM7XG52YXIgZGlzY292ZXJlZFBhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbnZhciBVUkxfTElNSVQgPSA3NjgwO1xuZnVuY3Rpb24gaXNGb2dPZldhckVuYWJsZWQocm91dGVEaXNjb3ZlcnksIHNzcikge1xuICByZXR1cm4gcm91dGVEaXNjb3ZlcnkubW9kZSA9PT0gXCJsYXp5XCIgJiYgc3NyID09PSB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0UGFydGlhbE1hbmlmZXN0KHsgc3JpLCAuLi5tYW5pZmVzdCB9LCByb3V0ZXIpIHtcbiAgbGV0IHJvdXRlSWRzID0gbmV3IFNldChyb3V0ZXIuc3RhdGUubWF0Y2hlcy5tYXAoKG0pID0+IG0ucm91dGUuaWQpKTtcbiAgbGV0IHNlZ21lbnRzID0gcm91dGVyLnN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lLnNwbGl0KFwiL1wiKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBwYXRocyA9IFtcIi9cIl07XG4gIHNlZ21lbnRzLnBvcCgpO1xuICB3aGlsZSAoc2VnbWVudHMubGVuZ3RoID4gMCkge1xuICAgIHBhdGhzLnB1c2goYC8ke3NlZ21lbnRzLmpvaW4oXCIvXCIpfWApO1xuICAgIHNlZ21lbnRzLnBvcCgpO1xuICB9XG4gIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlci5yb3V0ZXMsIHBhdGgsIHJvdXRlci5iYXNlbmFtZSk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgIG1hdGNoZXMuZm9yRWFjaCgobSkgPT4gcm91dGVJZHMuYWRkKG0ucm91dGUuaWQpKTtcbiAgICB9XG4gIH0pO1xuICBsZXQgaW5pdGlhbFJvdXRlcyA9IFsuLi5yb3V0ZUlkc10ucmVkdWNlKFxuICAgIChhY2MsIGlkKSA9PiBPYmplY3QuYXNzaWduKGFjYywgeyBbaWRdOiBtYW5pZmVzdC5yb3V0ZXNbaWRdIH0pLFxuICAgIHt9XG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4ubWFuaWZlc3QsXG4gICAgcm91dGVzOiBpbml0aWFsUm91dGVzLFxuICAgIHNyaTogc3JpID8gdHJ1ZSA6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25GdW5jdGlvbihtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCBzc3IsIHJvdXRlRGlzY292ZXJ5LCBpc1NwYU1vZGUsIGJhc2VuYW1lKSB7XG4gIGlmICghaXNGb2dPZldhckVuYWJsZWQocm91dGVEaXNjb3ZlcnksIHNzcikpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBhc3luYyAoeyBwYXRoLCBwYXRjaCwgc2lnbmFsLCBmZXRjaGVyS2V5IH0pID0+IHtcbiAgICBpZiAoZGlzY292ZXJlZFBhdGhzLmhhcyhwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCBmZXRjaEFuZEFwcGx5TWFuaWZlc3RQYXRjaGVzKFxuICAgICAgW3BhdGhdLFxuICAgICAgZmV0Y2hlcktleSA/IHdpbmRvdy5sb2NhdGlvbi5ocmVmIDogcGF0aCxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgcm91dGVNb2R1bGVzLFxuICAgICAgc3NyLFxuICAgICAgaXNTcGFNb2RlLFxuICAgICAgYmFzZW5hbWUsXG4gICAgICByb3V0ZURpc2NvdmVyeS5tYW5pZmVzdFBhdGgsXG4gICAgICBwYXRjaCxcbiAgICAgIHNpZ25hbFxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiB1c2VGb2dPRldhckRpc2NvdmVyeShyb3V0ZXIsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHNzciwgcm91dGVEaXNjb3ZlcnksIGlzU3BhTW9kZSkge1xuICBSZWFjdDgudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzRm9nT2ZXYXJFbmFibGVkKHJvdXRlRGlzY292ZXJ5LCBzc3IpIHx8IC8vIEB0cy1leHBlY3QtZXJyb3IgLSBUUyBkb2Vzbid0IGtub3cgYWJvdXQgdGhpcyB5ZXRcbiAgICB3aW5kb3cubmF2aWdhdG9yPy5jb25uZWN0aW9uPy5zYXZlRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWdpc3RlckVsZW1lbnQoZWwpIHtcbiAgICAgIGxldCBwYXRoID0gZWwudGFnTmFtZSA9PT0gXCJGT1JNXCIgPyBlbC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIikgOiBlbC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBwYXRobmFtZSA9IGVsLnRhZ05hbWUgPT09IFwiQVwiID8gZWwucGF0aG5hbWUgOiBuZXcgVVJMKHBhdGgsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pLnBhdGhuYW1lO1xuICAgICAgaWYgKCFkaXNjb3ZlcmVkUGF0aHMuaGFzKHBhdGhuYW1lKSkge1xuICAgICAgICBuZXh0UGF0aHMuYWRkKHBhdGhuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQYXRjaGVzKCkge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImFbZGF0YS1kaXNjb3Zlcl0sIGZvcm1bZGF0YS1kaXNjb3Zlcl1cIikuZm9yRWFjaChyZWdpc3RlckVsZW1lbnQpO1xuICAgICAgbGV0IGxhenlQYXRocyA9IEFycmF5LmZyb20obmV4dFBhdGhzLmtleXMoKSkuZmlsdGVyKChwYXRoKSA9PiB7XG4gICAgICAgIGlmIChkaXNjb3ZlcmVkUGF0aHMuaGFzKHBhdGgpKSB7XG4gICAgICAgICAgbmV4dFBhdGhzLmRlbGV0ZShwYXRoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICAgIGlmIChsYXp5UGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZldGNoQW5kQXBwbHlNYW5pZmVzdFBhdGNoZXMoXG4gICAgICAgICAgbGF6eVBhdGhzLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgICAgcm91dGVNb2R1bGVzLFxuICAgICAgICAgIHNzcixcbiAgICAgICAgICBpc1NwYU1vZGUsXG4gICAgICAgICAgcm91dGVyLmJhc2VuYW1lLFxuICAgICAgICAgIHJvdXRlRGlzY292ZXJ5Lm1hbmlmZXN0UGF0aCxcbiAgICAgICAgICByb3V0ZXIucGF0Y2hSb3V0ZXNcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBtYW5pZmVzdCBwYXRjaGVzXCIsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGVib3VuY2VkRmV0Y2hQYXRjaGVzID0gZGVib3VuY2UoZmV0Y2hQYXRjaGVzLCAxMDApO1xuICAgIGZldGNoUGF0Y2hlcygpO1xuICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IGRlYm91bmNlZEZldGNoUGF0Y2hlcygpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwge1xuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcImRhdGEtZGlzY292ZXJcIiwgXCJocmVmXCIsIFwiYWN0aW9uXCJdXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfSwgW3NzciwgaXNTcGFNb2RlLCBtYW5pZmVzdCwgcm91dGVNb2R1bGVzLCByb3V0ZXIsIHJvdXRlRGlzY292ZXJ5XSk7XG59XG5mdW5jdGlvbiBnZXRNYW5pZmVzdFBhdGgoX21hbmlmZXN0UGF0aCwgYmFzZW5hbWUpIHtcbiAgbGV0IG1hbmlmZXN0UGF0aCA9IF9tYW5pZmVzdFBhdGggfHwgXCIvX19tYW5pZmVzdFwiO1xuICBpZiAoYmFzZW5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBtYW5pZmVzdFBhdGg7XG4gIH1cbiAgcmV0dXJuIGAke2Jhc2VuYW1lfSR7bWFuaWZlc3RQYXRofWAucmVwbGFjZSgvXFwvKy9nLCBcIi9cIik7XG59XG52YXIgTUFOSUZFU1RfVkVSU0lPTl9TVE9SQUdFX0tFWSA9IFwicmVhY3Qtcm91dGVyLW1hbmlmZXN0LXZlcnNpb25cIjtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoQW5kQXBwbHlNYW5pZmVzdFBhdGNoZXMocGF0aHMsIGVycm9yUmVsb2FkUGF0aCwgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcywgc3NyLCBpc1NwYU1vZGUsIGJhc2VuYW1lLCBtYW5pZmVzdFBhdGgsIHBhdGNoUm91dGVzLCBzaWduYWwpIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwoXG4gICAgZ2V0TWFuaWZlc3RQYXRoKG1hbmlmZXN0UGF0aCwgYmFzZW5hbWUpLFxuICAgIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgKTtcbiAgcGF0aHMuc29ydCgpLmZvckVhY2goKHBhdGgpID0+IHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwicFwiLCBwYXRoKSk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwidmVyc2lvblwiLCBtYW5pZmVzdC52ZXJzaW9uKTtcbiAgaWYgKHVybC50b1N0cmluZygpLmxlbmd0aCA+IFVSTF9MSU1JVCkge1xuICAgIG5leHRQYXRocy5jbGVhcigpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc2VydmVyUGF0Y2hlcztcbiAgdHJ5IHtcbiAgICBsZXQgcmVzID0gYXdhaXQgZmV0Y2godXJsLCB7IHNpZ25hbCB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9YCk7XG4gICAgfSBlbHNlIGlmIChyZXMuc3RhdHVzID09PSAyMDQgJiYgcmVzLmhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIikpIHtcbiAgICAgIGlmICghZXJyb3JSZWxvYWRQYXRoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIkRldGVjdGVkIGEgbWFuaWZlc3QgdmVyc2lvbiBtaXNtYXRjaCBkdXJpbmcgZWFnZXIgcm91dGUgZGlzY292ZXJ5LiBUaGUgbmV4dCBuYXZpZ2F0aW9uL2ZldGNoIHRvIGFuIHVuZGlzY292ZXJlZCByb3V0ZSB3aWxsIHJlc3VsdCBpbiBhIG5ldyBkb2N1bWVudCBuYXZpZ2F0aW9uIHRvIHN5bmMgdXAgd2l0aCB0aGUgbGF0ZXN0IG1hbmlmZXN0LlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKE1BTklGRVNUX1ZFUlNJT05fU1RPUkFHRV9LRVkpID09PSBtYW5pZmVzdC52ZXJzaW9uKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJVbmFibGUgdG8gZGlzY292ZXIgcm91dGVzIGR1ZSB0byBtYW5pZmVzdCB2ZXJzaW9uIG1pc21hdGNoLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oTUFOSUZFU1RfVkVSU0lPTl9TVE9SQUdFX0tFWSwgbWFuaWZlc3QudmVyc2lvbik7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGVycm9yUmVsb2FkUGF0aDtcbiAgICAgIGNvbnNvbGUud2FybihcIkRldGVjdGVkIG1hbmlmZXN0IHZlcnNpb24gbWlzbWF0Y2gsIHJlbG9hZGluZy4uLlwiKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKCgpID0+IHtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocmVzLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihhd2FpdCByZXMudGV4dCgpKTtcbiAgICB9XG4gICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShNQU5JRkVTVF9WRVJTSU9OX1NUT1JBR0VfS0VZKTtcbiAgICBzZXJ2ZXJQYXRjaGVzID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChzaWduYWw/LmFib3J0ZWQpIHJldHVybjtcbiAgICB0aHJvdyBlO1xuICB9XG4gIGxldCBrbm93blJvdXRlcyA9IG5ldyBTZXQoT2JqZWN0LmtleXMobWFuaWZlc3Qucm91dGVzKSk7XG4gIGxldCBwYXRjaGVzID0gT2JqZWN0LnZhbHVlcyhzZXJ2ZXJQYXRjaGVzKS5yZWR1Y2UoKGFjYywgcm91dGUpID0+IHtcbiAgICBpZiAocm91dGUgJiYgIWtub3duUm91dGVzLmhhcyhyb3V0ZS5pZCkpIHtcbiAgICAgIGFjY1tyb3V0ZS5pZF0gPSByb3V0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICBPYmplY3QuYXNzaWduKG1hbmlmZXN0LnJvdXRlcywgcGF0Y2hlcyk7XG4gIHBhdGhzLmZvckVhY2goKHApID0+IGFkZFRvRmlmb1F1ZXVlKHAsIGRpc2NvdmVyZWRQYXRocykpO1xuICBsZXQgcGFyZW50SWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgT2JqZWN0LnZhbHVlcyhwYXRjaGVzKS5mb3JFYWNoKChwYXRjaCkgPT4ge1xuICAgIGlmIChwYXRjaCAmJiAoIXBhdGNoLnBhcmVudElkIHx8ICFwYXRjaGVzW3BhdGNoLnBhcmVudElkXSkpIHtcbiAgICAgIHBhcmVudElkcy5hZGQocGF0Y2gucGFyZW50SWQpO1xuICAgIH1cbiAgfSk7XG4gIHBhcmVudElkcy5mb3JFYWNoKFxuICAgIChwYXJlbnRJZCkgPT4gcGF0Y2hSb3V0ZXMoXG4gICAgICBwYXJlbnRJZCB8fCBudWxsLFxuICAgICAgY3JlYXRlQ2xpZW50Um91dGVzKHBhdGNoZXMsIHJvdXRlTW9kdWxlcywgbnVsbCwgc3NyLCBpc1NwYU1vZGUsIHBhcmVudElkKVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGFkZFRvRmlmb1F1ZXVlKHBhdGgsIHF1ZXVlKSB7XG4gIGlmIChxdWV1ZS5zaXplID49IGRpc2NvdmVyZWRQYXRoc01heFNpemUpIHtcbiAgICBsZXQgZmlyc3QgPSBxdWV1ZS52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gICAgcXVldWUuZGVsZXRlKGZpcnN0KTtcbiAgfVxuICBxdWV1ZS5hZGQocGF0aCk7XG59XG5mdW5jdGlvbiBkZWJvdW5jZShjYWxsYmFjaywgd2FpdCkge1xuICBsZXQgdGltZW91dElkO1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgdGltZW91dElkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soLi4uYXJncyksIHdhaXQpO1xuICB9O1xufVxuXG4vLyBsaWIvZG9tL3Nzci9jb21wb25lbnRzLnRzeFxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQyKCkge1xuICBsZXQgY29udGV4dCA9IFJlYWN0OS51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaW52YXJpYW50MihcbiAgICBjb250ZXh0LFxuICAgIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbnNpZGUgYSA8RGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXI+IGVsZW1lbnRcIlxuICApO1xuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZUNvbnRleHQoKSB7XG4gIGxldCBjb250ZXh0ID0gUmVhY3Q5LnVzZUNvbnRleHQoRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gIGludmFyaWFudDIoXG4gICAgY29udGV4dCxcbiAgICBcIllvdSBtdXN0IHJlbmRlciB0aGlzIGVsZW1lbnQgaW5zaWRlIGEgPERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXI+IGVsZW1lbnRcIlxuICApO1xuICByZXR1cm4gY29udGV4dDtcbn1cbnZhciBGcmFtZXdvcmtDb250ZXh0ID0gUmVhY3Q5LmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbkZyYW1ld29ya0NvbnRleHQuZGlzcGxheU5hbWUgPSBcIkZyYW1ld29ya0NvbnRleHRcIjtcbmZ1bmN0aW9uIHVzZUZyYW1ld29ya0NvbnRleHQoKSB7XG4gIGxldCBjb250ZXh0ID0gUmVhY3Q5LnVzZUNvbnRleHQoRnJhbWV3b3JrQ29udGV4dCk7XG4gIGludmFyaWFudDIoXG4gICAgY29udGV4dCxcbiAgICBcIllvdSBtdXN0IHJlbmRlciB0aGlzIGVsZW1lbnQgaW5zaWRlIGEgPEh5ZHJhdGVkUm91dGVyPiBlbGVtZW50XCJcbiAgKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiB1c2VQcmVmZXRjaEJlaGF2aW9yKHByZWZldGNoLCB0aGVpckVsZW1lbnRQcm9wcykge1xuICBsZXQgZnJhbWV3b3JrQ29udGV4dCA9IFJlYWN0OS51c2VDb250ZXh0KEZyYW1ld29ya0NvbnRleHQpO1xuICBsZXQgW21heWJlUHJlZmV0Y2gsIHNldE1heWJlUHJlZmV0Y2hdID0gUmVhY3Q5LnVzZVN0YXRlKGZhbHNlKTtcbiAgbGV0IFtzaG91bGRQcmVmZXRjaCwgc2V0U2hvdWxkUHJlZmV0Y2hdID0gUmVhY3Q5LnVzZVN0YXRlKGZhbHNlKTtcbiAgbGV0IHsgb25Gb2N1cywgb25CbHVyLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSwgb25Ub3VjaFN0YXJ0IH0gPSB0aGVpckVsZW1lbnRQcm9wcztcbiAgbGV0IHJlZiA9IFJlYWN0OS51c2VSZWYobnVsbCk7XG4gIFJlYWN0OS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJyZW5kZXJcIikge1xuICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgfVxuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJ2aWV3cG9ydFwiKSB7XG4gICAgICBsZXQgY2FsbGJhY2sgPSAoZW50cmllcykgPT4ge1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgc2V0U2hvdWxkUHJlZmV0Y2goZW50cnkuaXNJbnRlcnNlY3RpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoY2FsbGJhY2ssIHsgdGhyZXNob2xkOiAwLjUgfSk7XG4gICAgICBpZiAocmVmLmN1cnJlbnQpIG9ic2VydmVyLm9ic2VydmUocmVmLmN1cnJlbnQpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtwcmVmZXRjaF0pO1xuICBSZWFjdDkudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWF5YmVQcmVmZXRjaCkge1xuICAgICAgbGV0IGlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNldFNob3VsZFByZWZldGNoKHRydWUpO1xuICAgICAgfSwgMTAwKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW21heWJlUHJlZmV0Y2hdKTtcbiAgbGV0IHNldEludGVudCA9ICgpID0+IHtcbiAgICBzZXRNYXliZVByZWZldGNoKHRydWUpO1xuICB9O1xuICBsZXQgY2FuY2VsSW50ZW50ID0gKCkgPT4ge1xuICAgIHNldE1heWJlUHJlZmV0Y2goZmFsc2UpO1xuICAgIHNldFNob3VsZFByZWZldGNoKGZhbHNlKTtcbiAgfTtcbiAgaWYgKCFmcmFtZXdvcmtDb250ZXh0KSB7XG4gICAgcmV0dXJuIFtmYWxzZSwgcmVmLCB7fV07XG4gIH1cbiAgaWYgKHByZWZldGNoICE9PSBcImludGVudFwiKSB7XG4gICAgcmV0dXJuIFtzaG91bGRQcmVmZXRjaCwgcmVmLCB7fV07XG4gIH1cbiAgcmV0dXJuIFtcbiAgICBzaG91bGRQcmVmZXRjaCxcbiAgICByZWYsXG4gICAge1xuICAgICAgb25Gb2N1czogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Gb2N1cywgc2V0SW50ZW50KSxcbiAgICAgIG9uQmx1cjogY29tcG9zZUV2ZW50SGFuZGxlcnMob25CbHVyLCBjYW5jZWxJbnRlbnQpLFxuICAgICAgb25Nb3VzZUVudGVyOiBjb21wb3NlRXZlbnRIYW5kbGVycyhvbk1vdXNlRW50ZXIsIHNldEludGVudCksXG4gICAgICBvbk1vdXNlTGVhdmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VMZWF2ZSwgY2FuY2VsSW50ZW50KSxcbiAgICAgIG9uVG91Y2hTdGFydDogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Ub3VjaFN0YXJ0LCBzZXRJbnRlbnQpXG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gY29tcG9zZUV2ZW50SGFuZGxlcnModGhlaXJIYW5kbGVyLCBvdXJIYW5kbGVyKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICB0aGVpckhhbmRsZXIgJiYgdGhlaXJIYW5kbGVyKGV2ZW50KTtcbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIG91ckhhbmRsZXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZU1hdGNoZXMobWF0Y2hlcywgZXJyb3JzLCBpc1NwYU1vZGUpIHtcbiAgaWYgKGlzU3BhTW9kZSAmJiAhaXNIeWRyYXRlZCkge1xuICAgIHJldHVybiBbbWF0Y2hlc1swXV07XG4gIH1cbiAgaWYgKGVycm9ycykge1xuICAgIGxldCBlcnJvcklkeCA9IG1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBlcnJvcnNbbS5yb3V0ZS5pZF0gIT09IHZvaWQgMCk7XG4gICAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoMCwgZXJyb3JJZHggKyAxKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cbmZ1bmN0aW9uIExpbmtzKCkge1xuICBsZXQgeyBpc1NwYU1vZGUsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIGNyaXRpY2FsQ3NzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCB7IGVycm9ycywgbWF0Y2hlczogcm91dGVyTWF0Y2hlcyB9ID0gdXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCgpO1xuICBsZXQgbWF0Y2hlcyA9IGdldEFjdGl2ZU1hdGNoZXMocm91dGVyTWF0Y2hlcywgZXJyb3JzLCBpc1NwYU1vZGUpO1xuICBsZXQga2V5ZWRMaW5rcyA9IFJlYWN0OS51c2VNZW1vKFxuICAgICgpID0+IGdldEtleWVkTGlua3NGb3JNYXRjaGVzKG1hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3QpLFxuICAgIFttYXRjaGVzLCByb3V0ZU1vZHVsZXMsIG1hbmlmZXN0XVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgdHlwZW9mIGNyaXRpY2FsQ3NzID09PSBcInN0cmluZ1wiID8gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiwgeyBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IGNyaXRpY2FsQ3NzIH0gfSkgOiBudWxsLCB0eXBlb2YgY3JpdGljYWxDc3MgPT09IFwib2JqZWN0XCIgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZjogY3JpdGljYWxDc3MuaHJlZiB9KSA6IG51bGwsIGtleWVkTGlua3MubWFwKFxuICAgICh7IGtleSwgbGluayB9KSA9PiBpc1BhZ2VMaW5rRGVzY3JpcHRvcihsaW5rKSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rcywgeyBrZXksIC4uLmxpbmsgfSkgOiAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHsga2V5LCAuLi5saW5rIH0pXG4gICkpO1xufVxuZnVuY3Rpb24gUHJlZmV0Y2hQYWdlTGlua3Moe1xuICBwYWdlLFxuICAuLi5kYXRhTGlua1Byb3BzXG59KSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQyKCk7XG4gIGxldCBtYXRjaGVzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gbWF0Y2hSb3V0ZXMocm91dGVyLnJvdXRlcywgcGFnZSwgcm91dGVyLmJhc2VuYW1lKSxcbiAgICBbcm91dGVyLnJvdXRlcywgcGFnZSwgcm91dGVyLmJhc2VuYW1lXVxuICApO1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzSW1wbCwgeyBwYWdlLCBtYXRjaGVzLCAuLi5kYXRhTGlua1Byb3BzIH0pO1xufVxuZnVuY3Rpb24gdXNlS2V5ZWRQcmVmZXRjaExpbmtzKG1hdGNoZXMpIHtcbiAgbGV0IHsgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcyB9ID0gdXNlRnJhbWV3b3JrQ29udGV4dCgpO1xuICBsZXQgW2tleWVkUHJlZmV0Y2hMaW5rcywgc2V0S2V5ZWRQcmVmZXRjaExpbmtzXSA9IFJlYWN0OS51c2VTdGF0ZShbXSk7XG4gIFJlYWN0OS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBpbnRlcnJ1cHRlZCA9IGZhbHNlO1xuICAgIHZvaWQgZ2V0S2V5ZWRQcmVmZXRjaExpbmtzKG1hdGNoZXMsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMpLnRoZW4oXG4gICAgICAobGlua3MpID0+IHtcbiAgICAgICAgaWYgKCFpbnRlcnJ1cHRlZCkge1xuICAgICAgICAgIHNldEtleWVkUHJlZmV0Y2hMaW5rcyhsaW5rcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpbnRlcnJ1cHRlZCA9IHRydWU7XG4gICAgfTtcbiAgfSwgW21hdGNoZXMsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXNdKTtcbiAgcmV0dXJuIGtleWVkUHJlZmV0Y2hMaW5rcztcbn1cbmZ1bmN0aW9uIFByZWZldGNoUGFnZUxpbmtzSW1wbCh7XG4gIHBhZ2UsXG4gIG1hdGNoZXM6IG5leHRNYXRjaGVzLFxuICAuLi5saW5rUHJvcHNcbn0pIHtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHsgbWFuaWZlc3QsIHJvdXRlTW9kdWxlcyB9ID0gdXNlRnJhbWV3b3JrQ29udGV4dCgpO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQyKCk7XG4gIGxldCB7IGxvYWRlckRhdGEsIG1hdGNoZXMgfSA9IHVzZURhdGFSb3V0ZXJTdGF0ZUNvbnRleHQoKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JEYXRhID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzKFxuICAgICAgcGFnZSxcbiAgICAgIG5leHRNYXRjaGVzLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBcImRhdGFcIlxuICAgICksXG4gICAgW3BhZ2UsIG5leHRNYXRjaGVzLCBtYXRjaGVzLCBtYW5pZmVzdCwgbG9jYXRpb25dXG4gICk7XG4gIGxldCBuZXdNYXRjaGVzRm9yQXNzZXRzID0gUmVhY3Q5LnVzZU1lbW8oXG4gICAgKCkgPT4gZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzKFxuICAgICAgcGFnZSxcbiAgICAgIG5leHRNYXRjaGVzLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIG1hbmlmZXN0LFxuICAgICAgbG9jYXRpb24sXG4gICAgICBcImFzc2V0c1wiXG4gICAgKSxcbiAgICBbcGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIG1hbmlmZXN0LCBsb2NhdGlvbl1cbiAgKTtcbiAgbGV0IGRhdGFIcmVmcyA9IFJlYWN0OS51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocGFnZSA9PT0gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCByb3V0ZXNQYXJhbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBmb3VuZE9wdE91dFJvdXRlID0gZmFsc2U7XG4gICAgbmV4dE1hdGNoZXMuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgbGV0IG1hbmlmZXN0Um91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbS5yb3V0ZS5pZF07XG4gICAgICBpZiAoIW1hbmlmZXN0Um91dGUgfHwgIW1hbmlmZXN0Um91dGUuaGFzTG9hZGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghbmV3TWF0Y2hlc0ZvckRhdGEuc29tZSgobTIpID0+IG0yLnJvdXRlLmlkID09PSBtLnJvdXRlLmlkKSAmJiBtLnJvdXRlLmlkIGluIGxvYWRlckRhdGEgJiYgcm91dGVNb2R1bGVzW20ucm91dGUuaWRdPy5zaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICAgIGZvdW5kT3B0T3V0Um91dGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChtYW5pZmVzdFJvdXRlLmhhc0NsaWVudExvYWRlcikge1xuICAgICAgICBmb3VuZE9wdE91dFJvdXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlc1BhcmFtcy5hZGQobS5yb3V0ZS5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHJvdXRlc1BhcmFtcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCB1cmwgPSBzaW5nbGVGZXRjaFVybChwYWdlLCBiYXNlbmFtZSk7XG4gICAgaWYgKGZvdW5kT3B0T3V0Um91dGUgJiYgcm91dGVzUGFyYW1zLnNpemUgPiAwKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcbiAgICAgICAgXCJfcm91dGVzXCIsXG4gICAgICAgIG5leHRNYXRjaGVzLmZpbHRlcigobSkgPT4gcm91dGVzUGFyYW1zLmhhcyhtLnJvdXRlLmlkKSkubWFwKChtKSA9PiBtLnJvdXRlLmlkKS5qb2luKFwiLFwiKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFt1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoXTtcbiAgfSwgW1xuICAgIGJhc2VuYW1lLFxuICAgIGxvYWRlckRhdGEsXG4gICAgbG9jYXRpb24sXG4gICAgbWFuaWZlc3QsXG4gICAgbmV3TWF0Y2hlc0ZvckRhdGEsXG4gICAgbmV4dE1hdGNoZXMsXG4gICAgcGFnZSxcbiAgICByb3V0ZU1vZHVsZXNcbiAgXSk7XG4gIGxldCBtb2R1bGVIcmVmcyA9IFJlYWN0OS51c2VNZW1vKFxuICAgICgpID0+IGdldE1vZHVsZUxpbmtIcmVmcyhuZXdNYXRjaGVzRm9yQXNzZXRzLCBtYW5pZmVzdCksXG4gICAgW25ld01hdGNoZXNGb3JBc3NldHMsIG1hbmlmZXN0XVxuICApO1xuICBsZXQga2V5ZWRQcmVmZXRjaExpbmtzID0gdXNlS2V5ZWRQcmVmZXRjaExpbmtzKG5ld01hdGNoZXNGb3JBc3NldHMpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgZGF0YUhyZWZzLm1hcCgoaHJlZjIpID0+IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyBrZXk6IGhyZWYyLCByZWw6IFwicHJlZmV0Y2hcIiwgYXM6IFwiZmV0Y2hcIiwgaHJlZjogaHJlZjIsIC4uLmxpbmtQcm9wcyB9KSksIG1vZHVsZUhyZWZzLm1hcCgoaHJlZjIpID0+IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgeyBrZXk6IGhyZWYyLCByZWw6IFwibW9kdWxlcHJlbG9hZFwiLCBocmVmOiBocmVmMiwgLi4ubGlua1Byb3BzIH0pKSwga2V5ZWRQcmVmZXRjaExpbmtzLm1hcCgoeyBrZXksIGxpbmsgfSkgPT4gKFxuICAgIC8vIHRoZXNlIGRvbid0IHNwcmVhZCBgbGlua1Byb3BzYCBiZWNhdXNlIHRoZXkgYXJlIGZ1bGwgbGluayBkZXNjcmlwdG9yc1xuICAgIC8vIGFscmVhZHkgd2l0aCB0aGVpciBvd24gcHJvcHNcbiAgICAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIHsga2V5LCAuLi5saW5rIH0pXG4gICkpKTtcbn1cbmZ1bmN0aW9uIE1ldGEoKSB7XG4gIGxldCB7IGlzU3BhTW9kZSwgcm91dGVNb2R1bGVzIH0gPSB1c2VGcmFtZXdvcmtDb250ZXh0KCk7XG4gIGxldCB7XG4gICAgZXJyb3JzLFxuICAgIG1hdGNoZXM6IHJvdXRlck1hdGNoZXMsXG4gICAgbG9hZGVyRGF0YVxuICB9ID0gdXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgX21hdGNoZXMgPSBnZXRBY3RpdmVNYXRjaGVzKHJvdXRlck1hdGNoZXMsIGVycm9ycywgaXNTcGFNb2RlKTtcbiAgbGV0IGVycm9yID0gbnVsbDtcbiAgaWYgKGVycm9ycykge1xuICAgIGVycm9yID0gZXJyb3JzW19tYXRjaGVzW19tYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmlkXTtcbiAgfVxuICBsZXQgbWV0YSA9IFtdO1xuICBsZXQgbGVhZk1ldGEgPSBudWxsO1xuICBsZXQgbWF0Y2hlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IF9tYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IF9tYXRjaCA9IF9tYXRjaGVzW2ldO1xuICAgIGxldCByb3V0ZUlkID0gX21hdGNoLnJvdXRlLmlkO1xuICAgIGxldCBkYXRhMiA9IGxvYWRlckRhdGFbcm91dGVJZF07XG4gICAgbGV0IHBhcmFtcyA9IF9tYXRjaC5wYXJhbXM7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gcm91dGVNb2R1bGVzW3JvdXRlSWRdO1xuICAgIGxldCByb3V0ZU1ldGEgPSBbXTtcbiAgICBsZXQgbWF0Y2ggPSB7XG4gICAgICBpZDogcm91dGVJZCxcbiAgICAgIGRhdGE6IGRhdGEyLFxuICAgICAgbWV0YTogW10sXG4gICAgICBwYXJhbXM6IF9tYXRjaC5wYXJhbXMsXG4gICAgICBwYXRobmFtZTogX21hdGNoLnBhdGhuYW1lLFxuICAgICAgaGFuZGxlOiBfbWF0Y2gucm91dGUuaGFuZGxlLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICAgIG1hdGNoZXNbaV0gPSBtYXRjaDtcbiAgICBpZiAocm91dGVNb2R1bGU/Lm1ldGEpIHtcbiAgICAgIHJvdXRlTWV0YSA9IHR5cGVvZiByb3V0ZU1vZHVsZS5tZXRhID09PSBcImZ1bmN0aW9uXCIgPyByb3V0ZU1vZHVsZS5tZXRhKHtcbiAgICAgICAgZGF0YTogZGF0YTIsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGVycm9yXG4gICAgICB9KSA6IEFycmF5LmlzQXJyYXkocm91dGVNb2R1bGUubWV0YSkgPyBbLi4ucm91dGVNb2R1bGUubWV0YV0gOiByb3V0ZU1vZHVsZS5tZXRhO1xuICAgIH0gZWxzZSBpZiAobGVhZk1ldGEpIHtcbiAgICAgIHJvdXRlTWV0YSA9IFsuLi5sZWFmTWV0YV07XG4gICAgfVxuICAgIHJvdXRlTWV0YSA9IHJvdXRlTWV0YSB8fCBbXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocm91dGVNZXRhKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRoZSByb3V0ZSBhdCBcIiArIF9tYXRjaC5yb3V0ZS5wYXRoICsgXCIgcmV0dXJucyBhbiBpbnZhbGlkIHZhbHVlLiBBbGwgcm91dGUgbWV0YSBmdW5jdGlvbnMgbXVzdCByZXR1cm4gYW4gYXJyYXkgb2YgbWV0YSBvYmplY3RzLlxcblxcblRvIHJlZmVyZW5jZSB0aGUgbWV0YSBmdW5jdGlvbiBBUEksIHNlZSBodHRwczovL3JlbWl4LnJ1bi9yb3V0ZS9tZXRhXCJcbiAgICAgICk7XG4gICAgfVxuICAgIG1hdGNoLm1ldGEgPSByb3V0ZU1ldGE7XG4gICAgbWF0Y2hlc1tpXSA9IG1hdGNoO1xuICAgIG1ldGEgPSBbLi4ucm91dGVNZXRhXTtcbiAgICBsZWFmTWV0YSA9IG1ldGE7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChSZWFjdDkuRnJhZ21lbnQsIG51bGwsIG1ldGEuZmxhdCgpLm1hcCgobWV0YVByb3BzKSA9PiB7XG4gICAgaWYgKCFtZXRhUHJvcHMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoXCJ0YWdOYW1lXCIgaW4gbWV0YVByb3BzKSB7XG4gICAgICBsZXQgeyB0YWdOYW1lLCAuLi5yZXN0IH0gPSBtZXRhUHJvcHM7XG4gICAgICBpZiAoIWlzVmFsaWRNZXRhVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgQSBtZXRhIG9iamVjdCB1c2VzIGFuIGludmFsaWQgdGFnTmFtZTogJHt0YWdOYW1lfS4gRXhwZWN0ZWQgZWl0aGVyICdsaW5rJyBvciAnbWV0YSdgXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbGV0IENvbXAgPSB0YWdOYW1lO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChDb21wLCB7IGtleTogSlNPTi5zdHJpbmdpZnkocmVzdCksIC4uLnJlc3QgfSk7XG4gICAgfVxuICAgIGlmIChcInRpdGxlXCIgaW4gbWV0YVByb3BzKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgeyBrZXk6IFwidGl0bGVcIiB9LCBTdHJpbmcobWV0YVByb3BzLnRpdGxlKSk7XG4gICAgfVxuICAgIGlmIChcImNoYXJzZXRcIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIG1ldGFQcm9wcy5jaGFyU2V0ID8/IChtZXRhUHJvcHMuY2hhclNldCA9IG1ldGFQcm9wcy5jaGFyc2V0KTtcbiAgICAgIGRlbGV0ZSBtZXRhUHJvcHMuY2hhcnNldDtcbiAgICB9XG4gICAgaWYgKFwiY2hhclNldFwiIGluIG1ldGFQcm9wcyAmJiBtZXRhUHJvcHMuY2hhclNldCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG1ldGFQcm9wcy5jaGFyU2V0ID09PSBcInN0cmluZ1wiID8gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7IGtleTogXCJjaGFyU2V0XCIsIGNoYXJTZXQ6IG1ldGFQcm9wcy5jaGFyU2V0IH0pIDogbnVsbDtcbiAgICB9XG4gICAgaWYgKFwic2NyaXB0OmxkK2pzb25cIiBpbiBtZXRhUHJvcHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBqc29uID0gSlNPTi5zdHJpbmdpZnkobWV0YVByb3BzW1wic2NyaXB0OmxkK2pzb25cIl0pO1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwic2NyaXB0XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5OiBgc2NyaXB0OmxkK2pzb246JHtqc29ufWAsXG4gICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2xkK2pzb25cIixcbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDoganNvbiB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7IGtleTogSlNPTi5zdHJpbmdpZnkobWV0YVByb3BzKSwgLi4ubWV0YVByb3BzIH0pO1xuICB9KSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkTWV0YVRhZyh0YWdOYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgdGFnTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiAvXihtZXRhfGxpbmspJC8udGVzdCh0YWdOYW1lKTtcbn1cbnZhciBpc0h5ZHJhdGVkID0gZmFsc2U7XG5mdW5jdGlvbiBTY3JpcHRzKHByb3BzKSB7XG4gIGxldCB7XG4gICAgbWFuaWZlc3QsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZyxcbiAgICBpc1NwYU1vZGUsXG4gICAgcmVuZGVyTWV0YSxcbiAgICByb3V0ZURpc2NvdmVyeSxcbiAgICBzc3JcbiAgfSA9IHVzZUZyYW1ld29ya0NvbnRleHQoKTtcbiAgbGV0IHsgcm91dGVyLCBzdGF0aWM6IGlzU3RhdGljLCBzdGF0aWNDb250ZXh0IH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDIoKTtcbiAgbGV0IHsgbWF0Y2hlczogcm91dGVyTWF0Y2hlcyB9ID0gdXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCgpO1xuICBsZXQgZW5hYmxlRm9nT2ZXYXIgPSBpc0ZvZ09mV2FyRW5hYmxlZChyb3V0ZURpc2NvdmVyeSwgc3NyKTtcbiAgaWYgKHJlbmRlck1ldGEpIHtcbiAgICByZW5kZXJNZXRhLmRpZFJlbmRlclNjcmlwdHMgPSB0cnVlO1xuICB9XG4gIGxldCBtYXRjaGVzID0gZ2V0QWN0aXZlTWF0Y2hlcyhyb3V0ZXJNYXRjaGVzLCBudWxsLCBpc1NwYU1vZGUpO1xuICBSZWFjdDkudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgfSwgW10pO1xuICBsZXQgaW5pdGlhbFNjcmlwdHMgPSBSZWFjdDkudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHN0cmVhbVNjcmlwdCA9IFwid2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LnN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7c3RhcnQoY29udHJvbGxlcil7d2luZG93Ll9fcmVhY3RSb3V0ZXJDb250ZXh0LnN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO319KS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XCI7XG4gICAgbGV0IGNvbnRleHRTY3JpcHQgPSBzdGF0aWNDb250ZXh0ID8gYHdpbmRvdy5fX3JlYWN0Um91dGVyQ29udGV4dCA9ICR7c2VydmVySGFuZG9mZlN0cmluZ307JHtzdHJlYW1TY3JpcHR9YCA6IFwiIFwiO1xuICAgIGxldCByb3V0ZU1vZHVsZXNTY3JpcHQgPSAhaXNTdGF0aWMgPyBcIiBcIiA6IGAke21hbmlmZXN0Lmhtcj8ucnVudGltZSA/IGBpbXBvcnQgJHtKU09OLnN0cmluZ2lmeShtYW5pZmVzdC5obXIucnVudGltZSl9O2AgOiBcIlwifSR7IWVuYWJsZUZvZ09mV2FyID8gYGltcG9ydCAke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0LnVybCl9YCA6IFwiXCJ9O1xuJHttYXRjaGVzLm1hcCgobWF0Y2gsIHJvdXRlSW5kZXgpID0+IHtcbiAgICAgIGxldCByb3V0ZVZhck5hbWUgPSBgcm91dGUke3JvdXRlSW5kZXh9YDtcbiAgICAgIGxldCBtYW5pZmVzdEVudHJ5ID0gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIGludmFyaWFudDIobWFuaWZlc3RFbnRyeSwgYFJvdXRlICR7bWF0Y2gucm91dGUuaWR9IG5vdCBmb3VuZCBpbiBtYW5pZmVzdGApO1xuICAgICAgbGV0IHtcbiAgICAgICAgY2xpZW50QWN0aW9uTW9kdWxlLFxuICAgICAgICBjbGllbnRMb2FkZXJNb2R1bGUsXG4gICAgICAgIGNsaWVudE1pZGRsZXdhcmVNb2R1bGUsXG4gICAgICAgIGh5ZHJhdGVGYWxsYmFja01vZHVsZSxcbiAgICAgICAgbW9kdWxlOiBtb2R1bGUyXG4gICAgICB9ID0gbWFuaWZlc3RFbnRyeTtcbiAgICAgIGxldCBjaHVua3MgPSBbXG4gICAgICAgIC4uLmNsaWVudEFjdGlvbk1vZHVsZSA/IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtb2R1bGU6IGNsaWVudEFjdGlvbk1vZHVsZSxcbiAgICAgICAgICAgIHZhck5hbWU6IGAke3JvdXRlVmFyTmFtZX1fY2xpZW50QWN0aW9uYFxuICAgICAgICAgIH1cbiAgICAgICAgXSA6IFtdLFxuICAgICAgICAuLi5jbGllbnRMb2FkZXJNb2R1bGUgPyBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbW9kdWxlOiBjbGllbnRMb2FkZXJNb2R1bGUsXG4gICAgICAgICAgICB2YXJOYW1lOiBgJHtyb3V0ZVZhck5hbWV9X2NsaWVudExvYWRlcmBcbiAgICAgICAgICB9XG4gICAgICAgIF0gOiBbXSxcbiAgICAgICAgLi4uY2xpZW50TWlkZGxld2FyZU1vZHVsZSA/IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtb2R1bGU6IGNsaWVudE1pZGRsZXdhcmVNb2R1bGUsXG4gICAgICAgICAgICB2YXJOYW1lOiBgJHtyb3V0ZVZhck5hbWV9X2NsaWVudE1pZGRsZXdhcmVgXG4gICAgICAgICAgfVxuICAgICAgICBdIDogW10sXG4gICAgICAgIC4uLmh5ZHJhdGVGYWxsYmFja01vZHVsZSA/IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtb2R1bGU6IGh5ZHJhdGVGYWxsYmFja01vZHVsZSxcbiAgICAgICAgICAgIHZhck5hbWU6IGAke3JvdXRlVmFyTmFtZX1fSHlkcmF0ZUZhbGxiYWNrYFxuICAgICAgICAgIH1cbiAgICAgICAgXSA6IFtdLFxuICAgICAgICB7IG1vZHVsZTogbW9kdWxlMiwgdmFyTmFtZTogYCR7cm91dGVWYXJOYW1lfV9tYWluYCB9XG4gICAgICBdO1xuICAgICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGBpbXBvcnQgKiBhcyAke3JvdXRlVmFyTmFtZX0gZnJvbSAke0pTT04uc3RyaW5naWZ5KG1vZHVsZTIpfTtgO1xuICAgICAgfVxuICAgICAgbGV0IGNodW5rSW1wb3J0c1NuaXBwZXQgPSBjaHVua3MubWFwKChjaHVuaykgPT4gYGltcG9ydCAqIGFzICR7Y2h1bmsudmFyTmFtZX0gZnJvbSBcIiR7Y2h1bmsubW9kdWxlfVwiO2ApLmpvaW4oXCJcXG5cIik7XG4gICAgICBsZXQgbWVyZ2VkQ2h1bmtzU25pcHBldCA9IGBjb25zdCAke3JvdXRlVmFyTmFtZX0gPSB7JHtjaHVua3MubWFwKChjaHVuaykgPT4gYC4uLiR7Y2h1bmsudmFyTmFtZX1gKS5qb2luKFwiLFwiKX19O2A7XG4gICAgICByZXR1cm4gW2NodW5rSW1wb3J0c1NuaXBwZXQsIG1lcmdlZENodW5rc1NuaXBwZXRdLmpvaW4oXCJcXG5cIik7XG4gICAgfSkuam9pbihcIlxcblwiKX1cbiAgJHtlbmFibGVGb2dPZldhciA/IChcbiAgICAgIC8vIElubGluZSBhIG1pbmltYWwgbWFuaWZlc3Qgd2l0aCB0aGUgU1NSIG1hdGNoZXNcbiAgICAgIGB3aW5kb3cuX19yZWFjdFJvdXRlck1hbmlmZXN0ID0gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgZ2V0UGFydGlhbE1hbmlmZXN0KG1hbmlmZXN0LCByb3V0ZXIpLFxuICAgICAgICBudWxsLFxuICAgICAgICAyXG4gICAgICApfTtgXG4gICAgKSA6IFwiXCJ9XG4gIHdpbmRvdy5fX3JlYWN0Um91dGVyUm91dGVNb2R1bGVzID0geyR7bWF0Y2hlcy5tYXAoKG1hdGNoLCBpbmRleCkgPT4gYCR7SlNPTi5zdHJpbmdpZnkobWF0Y2gucm91dGUuaWQpfTpyb3V0ZSR7aW5kZXh9YCkuam9pbihcIixcIil9fTtcblxuaW1wb3J0KCR7SlNPTi5zdHJpbmdpZnkobWFuaWZlc3QuZW50cnkubW9kdWxlKX0pO2A7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChSZWFjdDkuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICAgIFwic2NyaXB0XCIsXG4gICAgICB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBjcmVhdGVIdG1sKGNvbnRleHRTY3JpcHQpLFxuICAgICAgICB0eXBlOiB2b2lkIDBcbiAgICAgIH1cbiAgICApLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcInNjcmlwdFwiLFxuICAgICAge1xuICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogY3JlYXRlSHRtbChyb3V0ZU1vZHVsZXNTY3JpcHQpLFxuICAgICAgICB0eXBlOiBcIm1vZHVsZVwiLFxuICAgICAgICBhc3luYzogdHJ1ZVxuICAgICAgfVxuICAgICkpO1xuICB9LCBbXSk7XG4gIGxldCBwcmVsb2FkcyA9IGlzSHlkcmF0ZWQgPyBbXSA6IGRlZHVwZShcbiAgICBtYW5pZmVzdC5lbnRyeS5pbXBvcnRzLmNvbmNhdChcbiAgICAgIGdldE1vZHVsZUxpbmtIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCwge1xuICAgICAgICBpbmNsdWRlSHlkcmF0ZUZhbGxiYWNrOiB0cnVlXG4gICAgICB9KVxuICAgIClcbiAgKTtcbiAgbGV0IHNyaSA9IHR5cGVvZiBtYW5pZmVzdC5zcmkgPT09IFwib2JqZWN0XCIgPyBtYW5pZmVzdC5zcmkgOiB7fTtcbiAgcmV0dXJuIGlzSHlkcmF0ZWQgPyBudWxsIDogLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFJlYWN0OS5GcmFnbWVudCwgbnVsbCwgdHlwZW9mIG1hbmlmZXN0LnNyaSA9PT0gXCJvYmplY3RcIiA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDkuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIFwicnItaW1wb3J0bWFwXCI6IFwiXCIsXG4gICAgICB0eXBlOiBcImltcG9ydG1hcFwiLFxuICAgICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaW50ZWdyaXR5OiBzcmlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICkgOiBudWxsLCAhZW5hYmxlRm9nT2ZXYXIgPyAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJsaW5rXCIsXG4gICAge1xuICAgICAgcmVsOiBcIm1vZHVsZXByZWxvYWRcIixcbiAgICAgIGhyZWY6IG1hbmlmZXN0LnVybCxcbiAgICAgIGNyb3NzT3JpZ2luOiBwcm9wcy5jcm9zc09yaWdpbixcbiAgICAgIGludGVncml0eTogc3JpW21hbmlmZXN0LnVybF0sXG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWVcbiAgICB9XG4gICkgOiBudWxsLCAvKiBAX19QVVJFX18gKi8gUmVhY3Q5LmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJsaW5rXCIsXG4gICAge1xuICAgICAgcmVsOiBcIm1vZHVsZXByZWxvYWRcIixcbiAgICAgIGhyZWY6IG1hbmlmZXN0LmVudHJ5Lm1vZHVsZSxcbiAgICAgIGNyb3NzT3JpZ2luOiBwcm9wcy5jcm9zc09yaWdpbixcbiAgICAgIGludGVncml0eTogc3JpW21hbmlmZXN0LmVudHJ5Lm1vZHVsZV0sXG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWVcbiAgICB9XG4gICksIHByZWxvYWRzLm1hcCgocGF0aCkgPT4gLyogQF9fUFVSRV9fICovIFJlYWN0OS5jcmVhdGVFbGVtZW50KFxuICAgIFwibGlua1wiLFxuICAgIHtcbiAgICAgIGtleTogcGF0aCxcbiAgICAgIHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsXG4gICAgICBocmVmOiBwYXRoLFxuICAgICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luLFxuICAgICAgaW50ZWdyaXR5OiBzcmlbcGF0aF0sXG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWVcbiAgICB9XG4gICkpLCBpbml0aWFsU2NyaXB0cyk7XG59XG5mdW5jdGlvbiBkZWR1cGUoYXJyYXkpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGFycmF5KV07XG59XG5mdW5jdGlvbiBtZXJnZVJlZnMoLi4ucmVmcykge1xuICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgcmVmcy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cblxuLy8gbGliL2RvbS9saWIudHN4XG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbnRyeSB7XG4gIGlmIChpc0Jyb3dzZXIpIHtcbiAgICB3aW5kb3cuX19yZWFjdFJvdXRlclZlcnNpb24gPSBcIjcuNi4xXCI7XG4gIH1cbn0gY2F0Y2ggKGUpIHtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzPy5iYXNlbmFtZSxcbiAgICB1bnN0YWJsZV9nZXRDb250ZXh0OiBvcHRzPy51bnN0YWJsZV9nZXRDb250ZXh0LFxuICAgIGZ1dHVyZTogb3B0cz8uZnV0dXJlLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHsgd2luZG93OiBvcHRzPy53aW5kb3cgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogb3B0cz8uaHlkcmF0aW9uRGF0YSB8fCBwYXJzZUh5ZHJhdGlvbkRhdGEoKSxcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgIGh5ZHJhdGlvblJvdXRlUHJvcGVydGllcyxcbiAgICBkYXRhU3RyYXRlZ3k6IG9wdHM/LmRhdGFTdHJhdGVneSxcbiAgICBwYXRjaFJvdXRlc09uTmF2aWdhdGlvbjogb3B0cz8ucGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb24sXG4gICAgd2luZG93OiBvcHRzPy53aW5kb3dcbiAgfSkuaW5pdGlhbGl6ZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzaFJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHM/LmJhc2VuYW1lLFxuICAgIHVuc3RhYmxlX2dldENvbnRleHQ6IG9wdHM/LnVuc3RhYmxlX2dldENvbnRleHQsXG4gICAgZnV0dXJlOiBvcHRzPy5mdXR1cmUsXG4gICAgaGlzdG9yeTogY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3c6IG9wdHM/LndpbmRvdyB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzPy5oeWRyYXRpb25EYXRhIHx8IHBhcnNlSHlkcmF0aW9uRGF0YSgpLFxuICAgIHJvdXRlcyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMsXG4gICAgaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzLFxuICAgIGRhdGFTdHJhdGVneTogb3B0cz8uZGF0YVN0cmF0ZWd5LFxuICAgIHBhdGNoUm91dGVzT25OYXZpZ2F0aW9uOiBvcHRzPy5wYXRjaFJvdXRlc09uTmF2aWdhdGlvbixcbiAgICB3aW5kb3c6IG9wdHM/LndpbmRvd1xuICB9KS5pbml0aWFsaXplKCk7XG59XG5mdW5jdGlvbiBwYXJzZUh5ZHJhdGlvbkRhdGEoKSB7XG4gIGxldCBzdGF0ZSA9IHdpbmRvdz8uX19zdGF0aWNSb3V0ZXJIeWRyYXRpb25EYXRhO1xuICBpZiAoc3RhdGUgJiYgc3RhdGUuZXJyb3JzKSB7XG4gICAgc3RhdGUgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGVycm9yczogZGVzZXJpYWxpemVFcnJvcnMoc3RhdGUuZXJyb3JzKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVFcnJvcnMoZXJyb3JzKSB7XG4gIGlmICghZXJyb3JzKSByZXR1cm4gbnVsbDtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xuICBsZXQgc2VyaWFsaXplZCA9IHt9O1xuICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGVudHJpZXMpIHtcbiAgICBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiUm91dGVFcnJvclJlc3BvbnNlXCIpIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IG5ldyBFcnJvclJlc3BvbnNlSW1wbChcbiAgICAgICAgdmFsLnN0YXR1cyxcbiAgICAgICAgdmFsLnN0YXR1c1RleHQsXG4gICAgICAgIHZhbC5kYXRhLFxuICAgICAgICB2YWwuaW50ZXJuYWwgPT09IHRydWVcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJFcnJvclwiKSB7XG4gICAgICBpZiAodmFsLl9fc3ViVHlwZSkge1xuICAgICAgICBsZXQgRXJyb3JDb25zdHJ1Y3RvciA9IHdpbmRvd1t2YWwuX19zdWJUeXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvckNvbnN0cnVjdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yQ29uc3RydWN0b3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBcIlwiO1xuICAgICAgICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlcmlhbGl6ZWRba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcih2YWwubWVzc2FnZSk7XG4gICAgICAgIGVycm9yLnN0YWNrID0gXCJcIjtcbiAgICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5mdW5jdGlvbiBCcm93c2VyUm91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICB3aW5kb3c6IHdpbmRvdzJcbn0pIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdDEwLnVzZVJlZigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVCcm93c2VySGlzdG9yeSh7IHdpbmRvdzogd2luZG93MiwgdjVDb21wYXQ6IHRydWUgfSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdDEwLnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgUmVhY3QxMC5zdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgfSxcbiAgICBbc2V0U3RhdGVJbXBsXVxuICApO1xuICBSZWFjdDEwLnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICBSb3V0ZXIsXG4gICAge1xuICAgICAgYmFzZW5hbWUsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBIYXNoUm91dGVyKHsgYmFzZW5hbWUsIGNoaWxkcmVuLCB3aW5kb3c6IHdpbmRvdzIgfSkge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0MTAudXNlUmVmKCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUhhc2hIaXN0b3J5KHsgd2luZG93OiB3aW5kb3cyLCB2NUNvbXBhdDogdHJ1ZSB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0MTAudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlKSA9PiB7XG4gICAgICBSZWFjdDEwLnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICB9LFxuICAgIFtzZXRTdGF0ZUltcGxdXG4gICk7XG4gIFJlYWN0MTAudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIEhpc3RvcnlSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGhpc3Rvcnlcbn0pIHtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0MTAudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0MTAudXNlQ2FsbGJhY2soXG4gICAgKG5ld1N0YXRlKSA9PiB7XG4gICAgICBSZWFjdDEwLnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICB9LFxuICAgIFtzZXRTdGF0ZUltcGxdXG4gICk7XG4gIFJlYWN0MTAudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICAgIH1cbiAgKTtcbn1cbkhpc3RvcnlSb3V0ZXIuZGlzcGxheU5hbWUgPSBcInVuc3RhYmxlX0hpc3RvcnlSb3V0ZXJcIjtcbnZhciBBQlNPTFVURV9VUkxfUkVHRVgyID0gL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKS9pO1xudmFyIExpbmsgPSBSZWFjdDEwLmZvcndhcmRSZWYoXG4gIGZ1bmN0aW9uIExpbmtXaXRoUmVmKHtcbiAgICBvbkNsaWNrLFxuICAgIGRpc2NvdmVyID0gXCJyZW5kZXJcIixcbiAgICBwcmVmZXRjaCA9IFwibm9uZVwiLFxuICAgIHJlbGF0aXZlLFxuICAgIHJlbG9hZERvY3VtZW50LFxuICAgIHJlcGxhY2U6IHJlcGxhY2UyLFxuICAgIHN0YXRlLFxuICAgIHRhcmdldCxcbiAgICB0byxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgdmlld1RyYW5zaXRpb24sXG4gICAgLi4ucmVzdFxuICB9LCBmb3J3YXJkZWRSZWYpIHtcbiAgICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgICBsZXQgaXNBYnNvbHV0ZSA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiAmJiBBQlNPTFVURV9VUkxfUkVHRVgyLnRlc3QodG8pO1xuICAgIGxldCBhYnNvbHV0ZUhyZWY7XG4gICAgbGV0IGlzRXh0ZXJuYWwgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiICYmIGlzQWJzb2x1dGUpIHtcbiAgICAgIGFic29sdXRlSHJlZiA9IHRvO1xuICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgbGV0IHRhcmdldFVybCA9IHRvLnN0YXJ0c1dpdGgoXCIvL1wiKSA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIHRvKSA6IG5ldyBVUkwodG8pO1xuICAgICAgICAgIGxldCBwYXRoID0gc3RyaXBCYXNlbmFtZSh0YXJnZXRVcmwucGF0aG5hbWUsIGJhc2VuYW1lKTtcbiAgICAgICAgICBpZiAodGFyZ2V0VXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgcGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0byA9IHBhdGggKyB0YXJnZXRVcmwuc2VhcmNoICsgdGFyZ2V0VXJsLmhhc2g7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzRXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIGA8TGluayB0bz1cIiR7dG99XCI+IGNvbnRhaW5zIGFuIGludmFsaWQgVVJMIHdoaWNoIHdpbGwgcHJvYmFibHkgYnJlYWsgd2hlbiBjbGlja2VkIC0gcGxlYXNlIHVwZGF0ZSB0byBhIHZhbGlkIFVSTCBwYXRoLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBocmVmMiA9IHVzZUhyZWYodG8sIHsgcmVsYXRpdmUgfSk7XG4gICAgbGV0IFtzaG91bGRQcmVmZXRjaCwgcHJlZmV0Y2hSZWYsIHByZWZldGNoSGFuZGxlcnNdID0gdXNlUHJlZmV0Y2hCZWhhdmlvcihcbiAgICAgIHByZWZldGNoLFxuICAgICAgcmVzdFxuICAgICk7XG4gICAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UyLFxuICAgICAgc3RhdGUsXG4gICAgICB0YXJnZXQsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHZpZXdUcmFuc2l0aW9uXG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAgIGlmIChvbkNsaWNrKSBvbkNsaWNrKGV2ZW50KTtcbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBpbnRlcm5hbE9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbGluayA9IChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaGFzLWNvbnRlbnRcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFwiYVwiLFxuICAgICAgICB7XG4gICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAuLi5wcmVmZXRjaEhhbmRsZXJzLFxuICAgICAgICAgIGhyZWY6IGFic29sdXRlSHJlZiB8fCBocmVmMixcbiAgICAgICAgICBvbkNsaWNrOiBpc0V4dGVybmFsIHx8IHJlbG9hZERvY3VtZW50ID8gb25DbGljayA6IGhhbmRsZUNsaWNrLFxuICAgICAgICAgIHJlZjogbWVyZ2VSZWZzKGZvcndhcmRlZFJlZiwgcHJlZmV0Y2hSZWYpLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBcImRhdGEtZGlzY292ZXJcIjogIWlzQWJzb2x1dGUgJiYgZGlzY292ZXIgPT09IFwicmVuZGVyXCIgPyBcInRydWVcIiA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4gc2hvdWxkUHJlZmV0Y2ggJiYgIWlzQWJzb2x1dGUgPyAvKiBAX19QVVJFX18gKi8gUmVhY3QxMC5jcmVhdGVFbGVtZW50KFJlYWN0MTAuRnJhZ21lbnQsIG51bGwsIGxpbmssIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3MsIHsgcGFnZTogaHJlZjIgfSkpIDogbGluaztcbiAgfVxuKTtcbkxpbmsuZGlzcGxheU5hbWUgPSBcIkxpbmtcIjtcbnZhciBOYXZMaW5rID0gUmVhY3QxMC5mb3J3YXJkUmVmKFxuICBmdW5jdGlvbiBOYXZMaW5rV2l0aFJlZih7XG4gICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnRQcm9wID0gXCJwYWdlXCIsXG4gICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lUHJvcCA9IFwiXCIsXG4gICAgZW5kID0gZmFsc2UsXG4gICAgc3R5bGU6IHN0eWxlUHJvcCxcbiAgICB0byxcbiAgICB2aWV3VHJhbnNpdGlvbixcbiAgICBjaGlsZHJlbixcbiAgICAuLi5yZXN0XG4gIH0sIHJlZikge1xuICAgIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7IHJlbGF0aXZlOiByZXN0LnJlbGF0aXZlIH0pO1xuICAgIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gICAgbGV0IHJvdXRlclN0YXRlID0gUmVhY3QxMC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICAgIGxldCB7IG5hdmlnYXRvciwgYmFzZW5hbWUgfSA9IFJlYWN0MTAudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gICAgbGV0IGlzVHJhbnNpdGlvbmluZyA9IHJvdXRlclN0YXRlICE9IG51bGwgJiYgLy8gQ29uZGl0aW9uYWwgdXNhZ2UgaXMgT0sgaGVyZSBiZWNhdXNlIHRoZSB1c2FnZSBvZiBhIGRhdGEgcm91dGVyIGlzIHN0YXRpY1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUocGF0aCkgJiYgdmlld1RyYW5zaXRpb24gPT09IHRydWU7XG4gICAgbGV0IHRvUGF0aG5hbWUgPSBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24ocGF0aCkucGF0aG5hbWUgOiBwYXRoLnBhdGhuYW1lO1xuICAgIGxldCBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgbGV0IG5leHRMb2NhdGlvblBhdGhuYW1lID0gcm91dGVyU3RhdGUgJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbiAmJiByb3V0ZXJTdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uID8gcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbi5wYXRobmFtZSA6IG51bGw7XG4gICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSBuZXh0TG9jYXRpb25QYXRobmFtZSA/IG5leHRMb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKG5leHRMb2NhdGlvblBhdGhuYW1lICYmIGJhc2VuYW1lKSB7XG4gICAgICBuZXh0TG9jYXRpb25QYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobmV4dExvY2F0aW9uUGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBuZXh0TG9jYXRpb25QYXRobmFtZTtcbiAgICB9XG4gICAgY29uc3QgZW5kU2xhc2hQb3NpdGlvbiA9IHRvUGF0aG5hbWUgIT09IFwiL1wiICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpID8gdG9QYXRobmFtZS5sZW5ndGggLSAxIDogdG9QYXRobmFtZS5sZW5ndGg7XG4gICAgbGV0IGlzQWN0aXZlID0gbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIGxvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBsb2NhdGlvblBhdGhuYW1lLmNoYXJBdChlbmRTbGFzaFBvc2l0aW9uKSA9PT0gXCIvXCI7XG4gICAgbGV0IGlzUGVuZGluZyA9IG5leHRMb2NhdGlvblBhdGhuYW1lICE9IG51bGwgJiYgKG5leHRMb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBuZXh0TG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIik7XG4gICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgaXNBY3RpdmUsXG4gICAgICBpc1BlbmRpbmcsXG4gICAgICBpc1RyYW5zaXRpb25pbmdcbiAgICB9O1xuICAgIGxldCBhcmlhQ3VycmVudCA9IGlzQWN0aXZlID8gYXJpYUN1cnJlbnRQcm9wIDogdm9pZCAwO1xuICAgIGxldCBjbGFzc05hbWU7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3AocmVuZGVyUHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc05hbWUgPSBbXG4gICAgICAgIGNsYXNzTmFtZVByb3AsXG4gICAgICAgIGlzQWN0aXZlID8gXCJhY3RpdmVcIiA6IG51bGwsXG4gICAgICAgIGlzUGVuZGluZyA/IFwicGVuZGluZ1wiIDogbnVsbCxcbiAgICAgICAgaXNUcmFuc2l0aW9uaW5nID8gXCJ0cmFuc2l0aW9uaW5nXCIgOiBudWxsXG4gICAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgbGV0IHN0eWxlID0gdHlwZW9mIHN0eWxlUHJvcCA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVQcm9wKHJlbmRlclByb3BzKSA6IHN0eWxlUHJvcDtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICAgIExpbmssXG4gICAgICB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50LFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHJlZixcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIHRvLFxuICAgICAgICB2aWV3VHJhbnNpdGlvblxuICAgICAgfSxcbiAgICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4ocmVuZGVyUHJvcHMpIDogY2hpbGRyZW5cbiAgICApO1xuICB9XG4pO1xuTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xudmFyIEZvcm0gPSBSZWFjdDEwLmZvcndhcmRSZWYoXG4gICh7XG4gICAgZGlzY292ZXIgPSBcInJlbmRlclwiLFxuICAgIGZldGNoZXJLZXksXG4gICAgbmF2aWdhdGUsXG4gICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgc3RhdGUsXG4gICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZCxcbiAgICBhY3Rpb24sXG4gICAgb25TdWJtaXQsXG4gICAgcmVsYXRpdmUsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHZpZXdUcmFuc2l0aW9uLFxuICAgIC4uLnByb3BzXG4gIH0sIGZvcndhcmRlZFJlZikgPT4ge1xuICAgIGxldCBzdWJtaXQgPSB1c2VTdWJtaXQoKTtcbiAgICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCB7IHJlbGF0aXZlIH0pO1xuICAgIGxldCBmb3JtTWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiZ2V0XCIgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gICAgbGV0IGlzQWJzb2x1dGUgPSB0eXBlb2YgYWN0aW9uID09PSBcInN0cmluZ1wiICYmIEFCU09MVVRFX1VSTF9SRUdFWDIudGVzdChhY3Rpb24pO1xuICAgIGxldCBzdWJtaXRIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICBvblN1Ym1pdCAmJiBvblN1Ym1pdChldmVudCk7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGxldCBzdWJtaXR0ZXIgPSBldmVudC5uYXRpdmVFdmVudC5zdWJtaXR0ZXI7XG4gICAgICBsZXQgc3VibWl0TWV0aG9kID0gc3VibWl0dGVyPy5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8IG1ldGhvZDtcbiAgICAgIHN1Ym1pdChzdWJtaXR0ZXIgfHwgZXZlbnQuY3VycmVudFRhcmdldCwge1xuICAgICAgICBmZXRjaGVyS2V5LFxuICAgICAgICBtZXRob2Q6IHN1Ym1pdE1ldGhvZCxcbiAgICAgICAgbmF2aWdhdGUsXG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2UyLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgdmlld1RyYW5zaXRpb25cbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBcImZvcm1cIixcbiAgICAgIHtcbiAgICAgICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgICAgIG1ldGhvZDogZm9ybU1ldGhvZCxcbiAgICAgICAgYWN0aW9uOiBmb3JtQWN0aW9uLFxuICAgICAgICBvblN1Ym1pdDogcmVsb2FkRG9jdW1lbnQgPyBvblN1Ym1pdCA6IHN1Ym1pdEhhbmRsZXIsXG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBcImRhdGEtZGlzY292ZXJcIjogIWlzQWJzb2x1dGUgJiYgZGlzY292ZXIgPT09IFwicmVuZGVyXCIgPyBcInRydWVcIiA6IHZvaWQgMFxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5Gb3JtLmRpc3BsYXlOYW1lID0gXCJGb3JtXCI7XG5mdW5jdGlvbiBTY3JvbGxSZXN0b3JhdGlvbih7XG4gIGdldEtleSxcbiAgc3RvcmFnZUtleSxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgbGV0IHJlbWl4Q29udGV4dCA9IFJlYWN0MTAudXNlQ29udGV4dChGcmFtZXdvcmtDb250ZXh0KTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0MTAudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBtYXRjaGVzID0gdXNlTWF0Y2hlcygpO1xuICB1c2VTY3JvbGxSZXN0b3JhdGlvbih7IGdldEtleSwgc3RvcmFnZUtleSB9KTtcbiAgbGV0IHNzcktleSA9IFJlYWN0MTAudXNlTWVtbyhcbiAgICAoKSA9PiB7XG4gICAgICBpZiAoIXJlbWl4Q29udGV4dCB8fCAhZ2V0S2V5KSByZXR1cm4gbnVsbDtcbiAgICAgIGxldCB1c2VyS2V5ID0gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkoXG4gICAgICAgIGxvY2F0aW9uLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBiYXNlbmFtZSxcbiAgICAgICAgZ2V0S2V5XG4gICAgICApO1xuICAgICAgcmV0dXJuIHVzZXJLZXkgIT09IGxvY2F0aW9uLmtleSA/IHVzZXJLZXkgOiBudWxsO1xuICAgIH0sXG4gICAgLy8gTmFoLCB3ZSBvbmx5IG5lZWQgdGhpcyB0aGUgZmlyc3QgdGltZSBmb3IgdGhlIFNTUiByZW5kZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW11cbiAgKTtcbiAgaWYgKCFyZW1peENvbnRleHQgfHwgcmVtaXhDb250ZXh0LmlzU3BhTW9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCByZXN0b3JlU2Nyb2xsID0gKChzdG9yYWdlS2V5MiwgcmVzdG9yZUtleSkgPT4ge1xuICAgIGlmICghd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwgIXdpbmRvdy5oaXN0b3J5LnN0YXRlLmtleSkge1xuICAgICAgbGV0IGtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzIpLnNsaWNlKDIpO1xuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5IH0sIFwiXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IHBvc2l0aW9ucyA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5MikgfHwgXCJ7fVwiKTtcbiAgICAgIGxldCBzdG9yZWRZID0gcG9zaXRpb25zW3Jlc3RvcmVLZXkgfHwgd2luZG93Lmhpc3Rvcnkuc3RhdGUua2V5XTtcbiAgICAgIGlmICh0eXBlb2Ygc3RvcmVkWSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc3RvcmVkWSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5Mik7XG4gICAgfVxuICB9KS50b1N0cmluZygpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0MTAuY3JlYXRlRWxlbWVudChcbiAgICBcInNjcmlwdFwiLFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgX19odG1sOiBgKCR7cmVzdG9yZVNjcm9sbH0pKCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVlcbiAgICAgICAgKX0sICR7SlNPTi5zdHJpbmdpZnkoc3NyS2V5KX0pYFxuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblNjcm9sbFJlc3RvcmF0aW9uLmRpc3BsYXlOYW1lID0gXCJTY3JvbGxSZXN0b3JhdGlvblwiO1xuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcjIoaG9va05hbWUpIHtcbiAgcmV0dXJuIGAke2hvb2tOYW1lfSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZW4vbWFpbi9yb3V0ZXJzL3BpY2tpbmctYS1yb3V0ZXIuYDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJDb250ZXh0Myhob29rTmFtZSkge1xuICBsZXQgY3R4ID0gUmVhY3QxMC51c2VDb250ZXh0KERhdGFSb3V0ZXJDb250ZXh0KTtcbiAgaW52YXJpYW50KGN0eCwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcjIoaG9va05hbWUpKTtcbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIHVzZURhdGFSb3V0ZXJTdGF0ZTIoaG9va05hbWUpIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QxMC51c2VDb250ZXh0KERhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQoc3RhdGUsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IyKGhvb2tOYW1lKSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgdGFyZ2V0LFxuICByZXBsYWNlOiByZXBsYWNlUHJvcCxcbiAgc3RhdGUsXG4gIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgcmVsYXRpdmUsXG4gIHZpZXdUcmFuc2l0aW9uXG59ID0ge30pIHtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmUgfSk7XG4gIHJldHVybiBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIChldmVudCkgPT4ge1xuICAgICAgaWYgKHNob3VsZFByb2Nlc3NMaW5rQ2xpY2soZXZlbnQsIHRhcmdldCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IHJlcGxhY2UyID0gcmVwbGFjZVByb3AgIT09IHZvaWQgMCA/IHJlcGxhY2VQcm9wIDogY3JlYXRlUGF0aChsb2NhdGlvbikgPT09IGNyZWF0ZVBhdGgocGF0aCk7XG4gICAgICAgIG5hdmlnYXRlKHRvLCB7XG4gICAgICAgICAgcmVwbGFjZTogcmVwbGFjZTIsXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICAgIHJlbGF0aXZlLFxuICAgICAgICAgIHZpZXdUcmFuc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgbG9jYXRpb24sXG4gICAgICBuYXZpZ2F0ZSxcbiAgICAgIHBhdGgsXG4gICAgICByZXBsYWNlUHJvcCxcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0LFxuICAgICAgdG8sXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHZpZXdUcmFuc2l0aW9uXG4gICAgXVxuICApO1xufVxuZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSB7XG4gIHdhcm5pbmcoXG4gICAgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICBgWW91IGNhbm5vdCB1c2UgdGhlIFxcYHVzZVNlYXJjaFBhcmFtc1xcYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkuIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgSW50ZXJuZXQgRXhwbG9yZXIgMTEsIHdlIHJlY29tbWVuZCB5b3UgbG9hZCBhIHBvbHlmaWxsIHN1Y2ggYXMgaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zLmBcbiAgKTtcbiAgbGV0IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdDEwLnVzZVJlZihjcmVhdGVTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpKTtcbiAgbGV0IGhhc1NldFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0MTAudXNlUmVmKGZhbHNlKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0MTAudXNlTWVtbyhcbiAgICAoKSA9PiAoXG4gICAgICAvLyBPbmx5IG1lcmdlIGluIHRoZSBkZWZhdWx0cyBpZiB3ZSBoYXZlbid0IHlldCBjYWxsZWQgc2V0U2VhcmNoUGFyYW1zLlxuICAgICAgLy8gT25jZSB3ZSBjYWxsIHRoYXQgd2Ugd2FudCB0aG9zZSB0byB0YWtlIHByZWNlZGVuY2UsIG90aGVyd2lzZSB5b3UgY2FuJ3RcbiAgICAgIC8vIHJlbW92ZSBhIHBhcmFtIHdpdGggc2V0U2VhcmNoUGFyYW1zKHt9KSBpZiBpdCBoYXMgYW4gaW5pdGlhbCB2YWx1ZVxuICAgICAgZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24oXG4gICAgICAgIGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzU2V0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQgPyBudWxsIDogZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50XG4gICAgICApXG4gICAgKSxcbiAgICBbbG9jYXRpb24uc2VhcmNoXVxuICApO1xuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBsZXQgc2V0U2VhcmNoUGFyYW1zID0gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICAobmV4dEluaXQsIG5hdmlnYXRlT3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgbmV3U2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKFxuICAgICAgICB0eXBlb2YgbmV4dEluaXQgPT09IFwiZnVuY3Rpb25cIiA/IG5leHRJbml0KHNlYXJjaFBhcmFtcykgOiBuZXh0SW5pdFxuICAgICAgKTtcbiAgICAgIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIG5hdmlnYXRlKFwiP1wiICsgbmV3U2VhcmNoUGFyYW1zLCBuYXZpZ2F0ZU9wdGlvbnMpO1xuICAgIH0sXG4gICAgW25hdmlnYXRlLCBzZWFyY2hQYXJhbXNdXG4gICk7XG4gIHJldHVybiBbc2VhcmNoUGFyYW1zLCBzZXRTZWFyY2hQYXJhbXNdO1xufVxudmFyIGZldGNoZXJJZCA9IDA7XG52YXIgZ2V0VW5pcXVlRmV0Y2hlcklkID0gKCkgPT4gYF9fJHtTdHJpbmcoKytmZXRjaGVySWQpfV9fYDtcbmZ1bmN0aW9uIHVzZVN1Ym1pdCgpIHtcbiAgbGV0IHsgcm91dGVyIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dDMoXCJ1c2VTdWJtaXRcIiAvKiBVc2VTdWJtaXQgKi8pO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGN1cnJlbnRSb3V0ZUlkID0gdXNlUm91dGVJZCgpO1xuICByZXR1cm4gUmVhY3QxMC51c2VDYWxsYmFjayhcbiAgICBhc3luYyAodGFyZ2V0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGxldCB7IGFjdGlvbiwgbWV0aG9kLCBlbmNUeXBlLCBmb3JtRGF0YSwgYm9keSB9ID0gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGJhc2VuYW1lXG4gICAgICApO1xuICAgICAgaWYgKG9wdGlvbnMubmF2aWdhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGxldCBrZXkgPSBvcHRpb25zLmZldGNoZXJLZXkgfHwgZ2V0VW5pcXVlRmV0Y2hlcklkKCk7XG4gICAgICAgIGF3YWl0IHJvdXRlci5mZXRjaChrZXksIGN1cnJlbnRSb3V0ZUlkLCBvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdGlvbnMucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICAgIGZvcm1EYXRhLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgZm9ybU1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgbWV0aG9kLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRpb25zLmVuY1R5cGUgfHwgZW5jVHlwZSxcbiAgICAgICAgICBmbHVzaFN5bmM6IG9wdGlvbnMuZmx1c2hTeW5jXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgcm91dGVyLm5hdmlnYXRlKG9wdGlvbnMuYWN0aW9uIHx8IGFjdGlvbiwge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBmb3JtTWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCBtZXRob2QsXG4gICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCBlbmNUeXBlLFxuICAgICAgICAgIHJlcGxhY2U6IG9wdGlvbnMucmVwbGFjZSxcbiAgICAgICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgICAgICBmcm9tUm91dGVJZDogY3VycmVudFJvdXRlSWQsXG4gICAgICAgICAgZmx1c2hTeW5jOiBvcHRpb25zLmZsdXNoU3luYyxcbiAgICAgICAgICB2aWV3VHJhbnNpdGlvbjogb3B0aW9ucy52aWV3VHJhbnNpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtyb3V0ZXIsIGJhc2VuYW1lLCBjdXJyZW50Um91dGVJZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUZvcm1BY3Rpb24oYWN0aW9uLCB7IHJlbGF0aXZlIH0gPSB7fSkge1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gUmVhY3QxMC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHJvdXRlQ29udGV4dCA9IFJlYWN0MTAudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBpbnZhcmlhbnQocm91dGVDb250ZXh0LCBcInVzZUZvcm1BY3Rpb24gbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKTtcbiAgbGV0IFttYXRjaF0gPSByb3V0ZUNvbnRleHQubWF0Y2hlcy5zbGljZSgtMSk7XG4gIGxldCBwYXRoID0geyAuLi51c2VSZXNvbHZlZFBhdGgoYWN0aW9uID8gYWN0aW9uIDogXCIuXCIsIHsgcmVsYXRpdmUgfSkgfTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgaWYgKGFjdGlvbiA9PSBudWxsKSB7XG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgbGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGF0aC5zZWFyY2gpO1xuICAgIGxldCBpbmRleFZhbHVlcyA9IHBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKTtcbiAgICBsZXQgaGFzTmFrZWRJbmRleFBhcmFtID0gaW5kZXhWYWx1ZXMuc29tZSgodikgPT4gdiA9PT0gXCJcIik7XG4gICAgaWYgKGhhc05ha2VkSW5kZXhQYXJhbSkge1xuICAgICAgcGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICAgICAgaW5kZXhWYWx1ZXMuZmlsdGVyKCh2KSA9PiB2KS5mb3JFYWNoKCh2KSA9PiBwYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgdikpO1xuICAgICAgbGV0IHFzID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICBwYXRoLnNlYXJjaCA9IHFzID8gYD8ke3FzfWAgOiBcIlwiO1xuICAgIH1cbiAgfVxuICBpZiAoKCFhY3Rpb24gfHwgYWN0aW9uID09PSBcIi5cIikgJiYgbWF0Y2gucm91dGUuaW5kZXgpIHtcbiAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoID8gcGF0aC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKSA6IFwiP2luZGV4XCI7XG4gIH1cbiAgaWYgKGJhc2VuYW1lICE9PSBcIi9cIikge1xuICAgIHBhdGgucGF0aG5hbWUgPSBwYXRoLnBhdGhuYW1lID09PSBcIi9cIiA/IGJhc2VuYW1lIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aC5wYXRobmFtZV0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVQYXRoKHBhdGgpO1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hlcih7XG4gIGtleVxufSA9IHt9KSB7XG4gIGxldCB7IHJvdXRlciB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQzKFwidXNlRmV0Y2hlclwiIC8qIFVzZUZldGNoZXIgKi8pO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUyKFwidXNlRmV0Y2hlclwiIC8qIFVzZUZldGNoZXIgKi8pO1xuICBsZXQgZmV0Y2hlckRhdGEgPSBSZWFjdDEwLnVzZUNvbnRleHQoRmV0Y2hlcnNDb250ZXh0KTtcbiAgbGV0IHJvdXRlID0gUmVhY3QxMC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCByb3V0ZUlkID0gcm91dGUubWF0Y2hlc1tyb3V0ZS5tYXRjaGVzLmxlbmd0aCAtIDFdPy5yb3V0ZS5pZDtcbiAgaW52YXJpYW50KGZldGNoZXJEYXRhLCBgdXNlRmV0Y2hlciBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgRmV0Y2hlcnNDb250ZXh0YCk7XG4gIGludmFyaWFudChyb3V0ZSwgYHVzZUZldGNoZXIgbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dGApO1xuICBpbnZhcmlhbnQoXG4gICAgcm91dGVJZCAhPSBudWxsLFxuICAgIGB1c2VGZXRjaGVyIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcImlkXCJgXG4gICk7XG4gIGxldCBkZWZhdWx0S2V5ID0gUmVhY3QxMC51c2VJZCgpO1xuICBsZXQgW2ZldGNoZXJLZXksIHNldEZldGNoZXJLZXldID0gUmVhY3QxMC51c2VTdGF0ZShrZXkgfHwgZGVmYXVsdEtleSk7XG4gIGlmIChrZXkgJiYga2V5ICE9PSBmZXRjaGVyS2V5KSB7XG4gICAgc2V0RmV0Y2hlcktleShrZXkpO1xuICB9XG4gIFJlYWN0MTAudXNlRWZmZWN0KCgpID0+IHtcbiAgICByb3V0ZXIuZ2V0RmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgICByZXR1cm4gKCkgPT4gcm91dGVyLmRlbGV0ZUZldGNoZXIoZmV0Y2hlcktleSk7XG4gIH0sIFtyb3V0ZXIsIGZldGNoZXJLZXldKTtcbiAgbGV0IGxvYWQgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChocmVmMiwgb3B0cykgPT4ge1xuICAgICAgaW52YXJpYW50KHJvdXRlSWQsIFwiTm8gcm91dGVJZCBhdmFpbGFibGUgZm9yIGZldGNoZXIubG9hZCgpXCIpO1xuICAgICAgYXdhaXQgcm91dGVyLmZldGNoKGZldGNoZXJLZXksIHJvdXRlSWQsIGhyZWYyLCBvcHRzKTtcbiAgICB9LFxuICAgIFtmZXRjaGVyS2V5LCByb3V0ZUlkLCByb3V0ZXJdXG4gICk7XG4gIGxldCBzdWJtaXRJbXBsID0gdXNlU3VibWl0KCk7XG4gIGxldCBzdWJtaXQgPSBSZWFjdDEwLnVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh0YXJnZXQsIG9wdHMpID0+IHtcbiAgICAgIGF3YWl0IHN1Ym1pdEltcGwodGFyZ2V0LCB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIG5hdmlnYXRlOiBmYWxzZSxcbiAgICAgICAgZmV0Y2hlcktleVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBbZmV0Y2hlcktleSwgc3VibWl0SW1wbF1cbiAgKTtcbiAgbGV0IEZldGNoZXJGb3JtID0gUmVhY3QxMC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgRmV0Y2hlckZvcm0yID0gUmVhY3QxMC5mb3J3YXJkUmVmKFxuICAgICAgKHByb3BzLCByZWYpID0+IHtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEwLmNyZWF0ZUVsZW1lbnQoRm9ybSwgeyAuLi5wcm9wcywgbmF2aWdhdGU6IGZhbHNlLCBmZXRjaGVyS2V5LCByZWYgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgICBGZXRjaGVyRm9ybTIuZGlzcGxheU5hbWUgPSBcImZldGNoZXIuRm9ybVwiO1xuICAgIHJldHVybiBGZXRjaGVyRm9ybTI7XG4gIH0sIFtmZXRjaGVyS2V5XSk7XG4gIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGZldGNoZXJLZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgbGV0IGRhdGEyID0gZmV0Y2hlckRhdGEuZ2V0KGZldGNoZXJLZXkpO1xuICBsZXQgZmV0Y2hlcldpdGhDb21wb25lbnRzID0gUmVhY3QxMC51c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBGb3JtOiBGZXRjaGVyRm9ybSxcbiAgICAgIHN1Ym1pdCxcbiAgICAgIGxvYWQsXG4gICAgICAuLi5mZXRjaGVyLFxuICAgICAgZGF0YTogZGF0YTJcbiAgICB9KSxcbiAgICBbRmV0Y2hlckZvcm0sIHN1Ym1pdCwgbG9hZCwgZmV0Y2hlciwgZGF0YTJdXG4gICk7XG4gIHJldHVybiBmZXRjaGVyV2l0aENvbXBvbmVudHM7XG59XG5mdW5jdGlvbiB1c2VGZXRjaGVycygpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlMihcInVzZUZldGNoZXJzXCIgLyogVXNlRmV0Y2hlcnMgKi8pO1xuICByZXR1cm4gQXJyYXkuZnJvbShzdGF0ZS5mZXRjaGVycy5lbnRyaWVzKCkpLm1hcCgoW2tleSwgZmV0Y2hlcl0pID0+ICh7XG4gICAgLi4uZmV0Y2hlcixcbiAgICBrZXlcbiAgfSkpO1xufVxudmFyIFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSA9IFwicmVhY3Qtcm91dGVyLXNjcm9sbC1wb3NpdGlvbnNcIjtcbnZhciBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IHt9O1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkobG9jYXRpb24sIG1hdGNoZXMsIGJhc2VuYW1lLCBnZXRLZXkpIHtcbiAgbGV0IGtleSA9IG51bGw7XG4gIGlmIChnZXRLZXkpIHtcbiAgICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgICBrZXkgPSBnZXRLZXkoXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5sb2NhdGlvbixcbiAgICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IGdldEtleShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgfVxuICB9XG4gIGlmIChrZXkgPT0gbnVsbCkge1xuICAgIGtleSA9IGxvY2F0aW9uLmtleTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gdXNlU2Nyb2xsUmVzdG9yYXRpb24oe1xuICBnZXRLZXksXG4gIHN0b3JhZ2VLZXlcbn0gPSB7fSkge1xuICBsZXQgeyByb3V0ZXIgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0MyhcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCIgLyogVXNlU2Nyb2xsUmVzdG9yYXRpb24gKi8pO1xuICBsZXQgeyByZXN0b3JlU2Nyb2xsUG9zaXRpb24sIHByZXZlbnRTY3JvbGxSZXNldCB9ID0gdXNlRGF0YVJvdXRlclN0YXRlMihcbiAgICBcInVzZVNjcm9sbFJlc3RvcmF0aW9uXCIgLyogVXNlU2Nyb2xsUmVzdG9yYXRpb24gKi9cbiAgKTtcbiAgbGV0IHsgYmFzZW5hbWUgfSA9IFJlYWN0MTAudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBtYXRjaGVzID0gdXNlTWF0Y2hlcygpO1xuICBsZXQgbmF2aWdhdGlvbiA9IHVzZU5hdmlnYXRpb24oKTtcbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHVzZVBhZ2VIaWRlKFxuICAgIFJlYWN0MTAudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgaWYgKG5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIGxldCBrZXkgPSBnZXRTY3JvbGxSZXN0b3JhdGlvbktleShsb2NhdGlvbiwgbWF0Y2hlcywgYmFzZW5hbWUsIGdldEtleSk7XG4gICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVksXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2F2ZWRTY3JvbGxQb3NpdGlvbnMpXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIGBGYWlsZWQgdG8gc2F2ZSBzY3JvbGwgcG9zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlLCA8U2Nyb2xsUmVzdG9yYXRpb24gLz4gd2lsbCBub3Qgd29yayBwcm9wZXJseSAoJHtlcnJvcn0pLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJhdXRvXCI7XG4gICAgfSwgW25hdmlnYXRpb24uc3RhdGUsIGdldEtleSwgYmFzZW5hbWUsIGxvY2F0aW9uLCBtYXRjaGVzLCBzdG9yYWdlS2V5XSlcbiAgKTtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFJlYWN0MTAudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzZXNzaW9uUG9zaXRpb25zID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcbiAgICAgICAgICBzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWVxuICAgICAgICApO1xuICAgICAgICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gSlNPTi5wYXJzZShzZXNzaW9uUG9zaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgIH0sIFtzdG9yYWdlS2V5XSk7XG4gICAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiA9IHJvdXRlcj8uZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oXG4gICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zLFxuICAgICAgICAoKSA9PiB3aW5kb3cuc2Nyb2xsWSxcbiAgICAgICAgZ2V0S2V5ID8gKGxvY2F0aW9uMiwgbWF0Y2hlczIpID0+IGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KGxvY2F0aW9uMiwgbWF0Y2hlczIsIGJhc2VuYW1lLCBnZXRLZXkpIDogdm9pZCAwXG4gICAgICApO1xuICAgICAgcmV0dXJuICgpID0+IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiAmJiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24oKTtcbiAgICB9LCBbcm91dGVyLCBiYXNlbmFtZSwgZ2V0S2V5XSk7XG4gICAgUmVhY3QxMC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiByZXN0b3JlU2Nyb2xsUG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHJlc3RvcmVTY3JvbGxQb3NpdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKVxuICAgICAgICApO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgfSwgW2xvY2F0aW9uLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24sIHByZXZlbnRTY3JvbGxSZXNldF0pO1xuICB9XG59XG5mdW5jdGlvbiB1c2VCZWZvcmVVbmxvYWQoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgbGV0IHsgY2FwdHVyZSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8geyBjYXB0dXJlIH0gOiB2b2lkIDA7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XG59XG5mdW5jdGlvbiB1c2VQYWdlSGlkZShjYWxsYmFjaywgb3B0aW9ucykge1xuICBsZXQgeyBjYXB0dXJlIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdDEwLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7IGNhcHR1cmUgfSA6IHZvaWQgMDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XG59XG5mdW5jdGlvbiB1c2VQcm9tcHQoe1xuICB3aGVuLFxuICBtZXNzYWdlXG59KSB7XG4gIGxldCBibG9ja2VyID0gdXNlQmxvY2tlcih3aGVuKTtcbiAgUmVhY3QxMC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIikge1xuICAgICAgbGV0IHByb2NlZWQgPSB3aW5kb3cuY29uZmlybShtZXNzYWdlKTtcbiAgICAgIGlmIChwcm9jZWVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoYmxvY2tlci5wcm9jZWVkLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrZXIucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtibG9ja2VyLCBtZXNzYWdlXSk7XG4gIFJlYWN0MTAudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIgJiYgIXdoZW4pIHtcbiAgICAgIGJsb2NrZXIucmVzZXQoKTtcbiAgICB9XG4gIH0sIFtibG9ja2VyLCB3aGVuXSk7XG59XG5mdW5jdGlvbiB1c2VWaWV3VHJhbnNpdGlvblN0YXRlKHRvLCBvcHRzID0ge30pIHtcbiAgbGV0IHZ0Q29udGV4dCA9IFJlYWN0MTAudXNlQ29udGV4dChWaWV3VHJhbnNpdGlvbkNvbnRleHQpO1xuICBpbnZhcmlhbnQoXG4gICAgdnRDb250ZXh0ICE9IG51bGwsXG4gICAgXCJgdXNlVmlld1RyYW5zaXRpb25TdGF0ZWAgbXVzdCBiZSB1c2VkIHdpdGhpbiBgcmVhY3Qtcm91dGVyLWRvbWAncyBgUm91dGVyUHJvdmlkZXJgLiAgRGlkIHlvdSBhY2NpZGVudGFsbHkgaW1wb3J0IGBSb3V0ZXJQcm92aWRlcmAgZnJvbSBgcmVhY3Qtcm91dGVyYD9cIlxuICApO1xuICBsZXQgeyBiYXNlbmFtZSB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQzKFxuICAgIFwidXNlVmlld1RyYW5zaXRpb25TdGF0ZVwiIC8qIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGUgKi9cbiAgKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHsgcmVsYXRpdmU6IG9wdHMucmVsYXRpdmUgfSk7XG4gIGlmICghdnRDb250ZXh0LmlzVHJhbnNpdGlvbmluZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgY3VycmVudFBhdGggPSBzdHJpcEJhc2VuYW1lKHZ0Q29udGV4dC5jdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCB2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICBsZXQgbmV4dFBhdGggPSBzdHJpcEJhc2VuYW1lKHZ0Q29udGV4dC5uZXh0TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCB2dENvbnRleHQubmV4dExvY2F0aW9uLnBhdGhuYW1lO1xuICByZXR1cm4gbWF0Y2hQYXRoKHBhdGgucGF0aG5hbWUsIG5leHRQYXRoKSAhPSBudWxsIHx8IG1hdGNoUGF0aChwYXRoLnBhdGhuYW1lLCBjdXJyZW50UGF0aCkgIT0gbnVsbDtcbn1cblxuLy8gbGliL2RvbS9zZXJ2ZXIudHN4XG52YXIgUmVhY3QxMSA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbmZ1bmN0aW9uIFN0YXRpY1JvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgbG9jYXRpb246IGxvY2F0aW9uUHJvcCA9IFwiL1wiXG59KSB7XG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cbiAgbGV0IGFjdGlvbiA9IFwiUE9QXCIgLyogUG9wICovO1xuICBsZXQgbG9jYXRpb24gPSB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uUHJvcC5wYXRobmFtZSB8fCBcIi9cIixcbiAgICBzZWFyY2g6IGxvY2F0aW9uUHJvcC5zZWFyY2ggfHwgXCJcIixcbiAgICBoYXNoOiBsb2NhdGlvblByb3AuaGFzaCB8fCBcIlwiLFxuICAgIHN0YXRlOiBsb2NhdGlvblByb3Auc3RhdGUgIT0gbnVsbCA/IGxvY2F0aW9uUHJvcC5zdGF0ZSA6IG51bGwsXG4gICAga2V5OiBsb2NhdGlvblByb3Aua2V5IHx8IFwiZGVmYXVsdFwiXG4gIH07XG4gIGxldCBzdGF0aWNOYXZpZ2F0b3IgPSBnZXRTdGF0ZWxlc3NOYXZpZ2F0b3IoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXG4gICAgUm91dGVyLFxuICAgIHtcbiAgICAgIGJhc2VuYW1lLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBsb2NhdGlvbixcbiAgICAgIG5hdmlnYXRpb25UeXBlOiBhY3Rpb24sXG4gICAgICBuYXZpZ2F0b3I6IHN0YXRpY05hdmlnYXRvcixcbiAgICAgIHN0YXRpYzogdHJ1ZVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIFN0YXRpY1JvdXRlclByb3ZpZGVyKHtcbiAgY29udGV4dCxcbiAgcm91dGVyLFxuICBoeWRyYXRlOiBoeWRyYXRlMiA9IHRydWUsXG4gIG5vbmNlXG59KSB7XG4gIGludmFyaWFudChcbiAgICByb3V0ZXIgJiYgY29udGV4dCxcbiAgICBcIllvdSBtdXN0IHByb3ZpZGUgYHJvdXRlcmAgYW5kIGBjb250ZXh0YCB0byA8U3RhdGljUm91dGVyUHJvdmlkZXI+XCJcbiAgKTtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0ge1xuICAgIHJvdXRlcixcbiAgICBuYXZpZ2F0b3I6IGdldFN0YXRlbGVzc05hdmlnYXRvcigpLFxuICAgIHN0YXRpYzogdHJ1ZSxcbiAgICBzdGF0aWNDb250ZXh0OiBjb250ZXh0LFxuICAgIGJhc2VuYW1lOiBjb250ZXh0LmJhc2VuYW1lIHx8IFwiL1wiXG4gIH07XG4gIGxldCBmZXRjaGVyc0NvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgaHlkcmF0ZVNjcmlwdCA9IFwiXCI7XG4gIGlmIChoeWRyYXRlMiAhPT0gZmFsc2UpIHtcbiAgICBsZXQgZGF0YTIgPSB7XG4gICAgICBsb2FkZXJEYXRhOiBjb250ZXh0LmxvYWRlckRhdGEsXG4gICAgICBhY3Rpb25EYXRhOiBjb250ZXh0LmFjdGlvbkRhdGEsXG4gICAgICBlcnJvcnM6IHNlcmlhbGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycylcbiAgICB9O1xuICAgIGxldCBqc29uID0gaHRtbEVzY2FwZShKU09OLnN0cmluZ2lmeShKU09OLnN0cmluZ2lmeShkYXRhMikpKTtcbiAgICBoeWRyYXRlU2NyaXB0ID0gYHdpbmRvdy5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGEgPSBKU09OLnBhcnNlKCR7anNvbn0pO2A7XG4gIH1cbiAgbGV0IHsgc3RhdGUgfSA9IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlcjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMS5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHQgfSwgLyogQF9fUFVSRV9fICovIFJlYWN0MTEuY3JlYXRlRWxlbWVudChEYXRhUm91dGVyU3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzdGF0ZSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KEZldGNoZXJzQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZmV0Y2hlcnNDb250ZXh0IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoVmlld1RyYW5zaXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB7IGlzVHJhbnNpdGlvbmluZzogZmFsc2UgfSB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMS5jcmVhdGVFbGVtZW50KFxuICAgIFJvdXRlcixcbiAgICB7XG4gICAgICBiYXNlbmFtZTogZGF0YVJvdXRlckNvbnRleHQuYmFzZW5hbWUsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuaGlzdG9yeUFjdGlvbixcbiAgICAgIG5hdmlnYXRvcjogZGF0YVJvdXRlckNvbnRleHQubmF2aWdhdG9yLFxuICAgICAgc3RhdGljOiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWNcbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBEYXRhUm91dGVzMixcbiAgICAgIHtcbiAgICAgICAgcm91dGVzOiByb3V0ZXIucm91dGVzLFxuICAgICAgICBmdXR1cmU6IHJvdXRlci5mdXR1cmUsXG4gICAgICAgIHN0YXRlXG4gICAgICB9XG4gICAgKVxuICApKSkpKSwgaHlkcmF0ZVNjcmlwdCA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDExLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzY3JpcHRcIixcbiAgICB7XG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBub25jZSxcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogaHlkcmF0ZVNjcmlwdCB9XG4gICAgfVxuICApIDogbnVsbCk7XG59XG5mdW5jdGlvbiBEYXRhUm91dGVzMih7XG4gIHJvdXRlcyxcbiAgZnV0dXJlLFxuICBzdGF0ZVxufSkge1xuICByZXR1cm4gdXNlUm91dGVzSW1wbChyb3V0ZXMsIHZvaWQgMCwgc3RhdGUsIGZ1dHVyZSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvcnMoZXJyb3JzKSB7XG4gIGlmICghZXJyb3JzKSByZXR1cm4gbnVsbDtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xuICBsZXQgc2VyaWFsaXplZCA9IHt9O1xuICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGVudHJpZXMpIHtcbiAgICBpZiAoaXNSb3V0ZUVycm9yUmVzcG9uc2UodmFsKSkge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0geyAuLi52YWwsIF9fdHlwZTogXCJSb3V0ZUVycm9yUmVzcG9uc2VcIiB9O1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHtcbiAgICAgICAgbWVzc2FnZTogdmFsLm1lc3NhZ2UsXG4gICAgICAgIF9fdHlwZTogXCJFcnJvclwiLFxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgc3ViY2xhc3MgKGkuZS4sIFJlZmVyZW5jZUVycm9yKSwgc2VuZCB1cCB0aGUgdHlwZSBzbyB3ZVxuICAgICAgICAvLyBjYW4gcmUtY3JlYXRlIHRoZSBzYW1lIHR5cGUgZHVyaW5nIGh5ZHJhdGlvbi5cbiAgICAgICAgLi4udmFsLm5hbWUgIT09IFwiRXJyb3JcIiA/IHtcbiAgICAgICAgICBfX3N1YlR5cGU6IHZhbC5uYW1lXG4gICAgICAgIH0gOiB7fVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbmZ1bmN0aW9uIGdldFN0YXRlbGVzc05hdmlnYXRvcigpIHtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVIcmVmLFxuICAgIGVuY29kZUxvY2F0aW9uLFxuICAgIHB1c2godG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5wdXNoKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgXFxgbmF2aWdhdGUoJHtKU09OLnN0cmluZ2lmeSh0byl9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYFxuICAgICAgKTtcbiAgICB9LFxuICAgIHJlcGxhY2UodG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5yZXBsYWNlKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgXFxgbmF2aWdhdGUoJHtKU09OLnN0cmluZ2lmeSh0byl9LCB7IHJlcGxhY2U6IHRydWUgfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmBcbiAgICAgICk7XG4gICAgfSxcbiAgICBnbyhkZWx0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmdvKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgXFxgbmF2aWdhdGUoJHtkZWx0YX0pXFxgIHNvbWV3aGVyZSBpbiB5b3VyIGFwcC5gXG4gICAgICApO1xuICAgIH0sXG4gICAgYmFjaygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5iYWNrKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGVudmlyb25tZW50LmBcbiAgICAgICk7XG4gICAgfSxcbiAgICBmb3J3YXJkKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmZvcndhcmQoKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgZW52aXJvbm1lbnQuYFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNIYW5kbGVyMihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVN0YXRpY0hhbmRsZXIocm91dGVzLCB7XG4gICAgLi4ub3B0cyxcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXNcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNSb3V0ZXIocm91dGVzLCBjb250ZXh0LCBvcHRzID0ge30pIHtcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIGxldCBkYXRhUm91dGVzID0gY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzLFxuICAgIHZvaWQgMCxcbiAgICBtYW5pZmVzdFxuICApO1xuICBsZXQgbWF0Y2hlcyA9IGNvbnRleHQubWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG4gICAgbGV0IHJvdXRlID0gbWFuaWZlc3RbbWF0Y2gucm91dGUuaWRdIHx8IG1hdGNoLnJvdXRlO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5tYXRjaCxcbiAgICAgIHJvdXRlXG4gICAgfTtcbiAgfSk7XG4gIGxldCBtc2cgPSAobWV0aG9kKSA9PiBgWW91IGNhbm5vdCB1c2Ugcm91dGVyLiR7bWV0aG9kfSgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBlbnZpcm9ubWVudGA7XG4gIHJldHVybiB7XG4gICAgZ2V0IGJhc2VuYW1lKCkge1xuICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZW5hbWU7XG4gICAgfSxcbiAgICBnZXQgZnV0dXJlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5zdGFibGVfbWlkZGxld2FyZTogZmFsc2UsXG4gICAgICAgIC4uLm9wdHM/LmZ1dHVyZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhpc3RvcnlBY3Rpb246IFwiUE9QXCIgLyogUG9wICovLFxuICAgICAgICBsb2NhdGlvbjogY29udGV4dC5sb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YTogY29udGV4dC5sb2FkZXJEYXRhLFxuICAgICAgICBhY3Rpb25EYXRhOiBjb250ZXh0LmFjdGlvbkRhdGEsXG4gICAgICAgIGVycm9yczogY29udGV4dC5lcnJvcnMsXG4gICAgICAgIGluaXRpYWxpemVkOiB0cnVlLFxuICAgICAgICBuYXZpZ2F0aW9uOiBJRExFX05BVklHQVRJT04sXG4gICAgICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogbnVsbCxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBmYWxzZSxcbiAgICAgICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcbiAgICAgICAgZmV0Y2hlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICAgIGJsb2NrZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0IHJvdXRlcygpIHtcbiAgICAgIHJldHVybiBkYXRhUm91dGVzO1xuICAgIH0sXG4gICAgZ2V0IHdpbmRvdygpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSxcbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgdGhyb3cgbXNnKFwiaW5pdGlhbGl6ZVwiKTtcbiAgICB9LFxuICAgIHN1YnNjcmliZSgpIHtcbiAgICAgIHRocm93IG1zZyhcInN1YnNjcmliZVwiKTtcbiAgICB9LFxuICAgIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uKCkge1xuICAgICAgdGhyb3cgbXNnKFwiZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb25cIik7XG4gICAgfSxcbiAgICBuYXZpZ2F0ZSgpIHtcbiAgICAgIHRocm93IG1zZyhcIm5hdmlnYXRlXCIpO1xuICAgIH0sXG4gICAgZmV0Y2goKSB7XG4gICAgICB0aHJvdyBtc2coXCJmZXRjaFwiKTtcbiAgICB9LFxuICAgIHJldmFsaWRhdGUoKSB7XG4gICAgICB0aHJvdyBtc2coXCJyZXZhbGlkYXRlXCIpO1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZixcbiAgICBlbmNvZGVMb2NhdGlvbixcbiAgICBnZXRGZXRjaGVyKCkge1xuICAgICAgcmV0dXJuIElETEVfRkVUQ0hFUjtcbiAgICB9LFxuICAgIGRlbGV0ZUZldGNoZXIoKSB7XG4gICAgICB0aHJvdyBtc2coXCJkZWxldGVGZXRjaGVyXCIpO1xuICAgIH0sXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIHRocm93IG1zZyhcImRpc3Bvc2VcIik7XG4gICAgfSxcbiAgICBnZXRCbG9ja2VyKCkge1xuICAgICAgcmV0dXJuIElETEVfQkxPQ0tFUjtcbiAgICB9LFxuICAgIGRlbGV0ZUJsb2NrZXIoKSB7XG4gICAgICB0aHJvdyBtc2coXCJkZWxldGVCbG9ja2VyXCIpO1xuICAgIH0sXG4gICAgcGF0Y2hSb3V0ZXMoKSB7XG4gICAgICB0aHJvdyBtc2coXCJwYXRjaFJvdXRlc1wiKTtcbiAgICB9LFxuICAgIF9pbnRlcm5hbEZldGNoQ29udHJvbGxlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgX2ludGVybmFsU2V0Um91dGVzKCkge1xuICAgICAgdGhyb3cgbXNnKFwiX2ludGVybmFsU2V0Um91dGVzXCIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhyZWYodG8pIHtcbiAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG59XG5mdW5jdGlvbiBlbmNvZGVMb2NhdGlvbih0bykge1xuICBsZXQgaHJlZjIgPSB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICBocmVmMiA9IGhyZWYyLnJlcGxhY2UoLyAkLywgXCIlMjBcIik7XG4gIGxldCBlbmNvZGVkID0gQUJTT0xVVEVfVVJMX1JFR0VYMy50ZXN0KGhyZWYyKSA/IG5ldyBVUkwoaHJlZjIpIDogbmV3IFVSTChocmVmMiwgXCJodHRwOi8vbG9jYWxob3N0XCIpO1xuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBlbmNvZGVkLnBhdGhuYW1lLFxuICAgIHNlYXJjaDogZW5jb2RlZC5zZWFyY2gsXG4gICAgaGFzaDogZW5jb2RlZC5oYXNoXG4gIH07XG59XG52YXIgQUJTT0xVVEVfVVJMX1JFR0VYMyA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcbnZhciBFU0NBUEVfTE9PS1VQMiA9IHtcbiAgXCImXCI6IFwiXFxcXHUwMDI2XCIsXG4gIFwiPlwiOiBcIlxcXFx1MDAzZVwiLFxuICBcIjxcIjogXCJcXFxcdTAwM2NcIixcbiAgXCJcXHUyMDI4XCI6IFwiXFxcXHUyMDI4XCIsXG4gIFwiXFx1MjAyOVwiOiBcIlxcXFx1MjAyOVwiXG59O1xudmFyIEVTQ0FQRV9SRUdFWDIgPSAvWyY+PFxcdTIwMjhcXHUyMDI5XS9nO1xuZnVuY3Rpb24gaHRtbEVzY2FwZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKEVTQ0FQRV9SRUdFWDIsIChtYXRjaCkgPT4gRVNDQVBFX0xPT0tVUDJbbWF0Y2hdKTtcbn1cblxuLy8gbGliL2RvbS9zc3Ivc2VydmVyLnRzeFxudmFyIFJlYWN0MTIgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBTZXJ2ZXJSb3V0ZXIoe1xuICBjb250ZXh0LFxuICB1cmwsXG4gIG5vbmNlXG59KSB7XG4gIGlmICh0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgdXJsID0gbmV3IFVSTCh1cmwpO1xuICB9XG4gIGxldCB7IG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIGNyaXRpY2FsQ3NzLCBzZXJ2ZXJIYW5kb2ZmU3RyaW5nIH0gPSBjb250ZXh0O1xuICBsZXQgcm91dGVzID0gY3JlYXRlU2VydmVyUm91dGVzKFxuICAgIG1hbmlmZXN0LnJvdXRlcyxcbiAgICByb3V0ZU1vZHVsZXMsXG4gICAgY29udGV4dC5mdXR1cmUsXG4gICAgY29udGV4dC5pc1NwYU1vZGVcbiAgKTtcbiAgY29udGV4dC5zdGF0aWNIYW5kbGVyQ29udGV4dC5sb2FkZXJEYXRhID0ge1xuICAgIC4uLmNvbnRleHQuc3RhdGljSGFuZGxlckNvbnRleHQubG9hZGVyRGF0YVxuICB9O1xuICBmb3IgKGxldCBtYXRjaCBvZiBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0Lm1hdGNoZXMpIHtcbiAgICBsZXQgcm91dGVJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIGxldCByb3V0ZSA9IHJvdXRlTW9kdWxlc1tyb3V0ZUlkXTtcbiAgICBsZXQgbWFuaWZlc3RSb3V0ZSA9IGNvbnRleHQubWFuaWZlc3Qucm91dGVzW3JvdXRlSWRdO1xuICAgIGlmIChyb3V0ZSAmJiBtYW5pZmVzdFJvdXRlICYmIHNob3VsZEh5ZHJhdGVSb3V0ZUxvYWRlcihcbiAgICAgIHJvdXRlSWQsXG4gICAgICByb3V0ZS5jbGllbnRMb2FkZXIsXG4gICAgICBtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcixcbiAgICAgIGNvbnRleHQuaXNTcGFNb2RlXG4gICAgKSAmJiAocm91dGUuSHlkcmF0ZUZhbGxiYWNrIHx8ICFtYW5pZmVzdFJvdXRlLmhhc0xvYWRlcikpIHtcbiAgICAgIGRlbGV0ZSBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0LmxvYWRlckRhdGFbcm91dGVJZF07XG4gICAgfVxuICB9XG4gIGxldCByb3V0ZXIgPSBjcmVhdGVTdGF0aWNSb3V0ZXIocm91dGVzLCBjb250ZXh0LnN0YXRpY0hhbmRsZXJDb250ZXh0KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoUmVhY3QxMi5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChcbiAgICBGcmFtZXdvcmtDb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICAgIGNyaXRpY2FsQ3NzLFxuICAgICAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nLFxuICAgICAgICBmdXR1cmU6IGNvbnRleHQuZnV0dXJlLFxuICAgICAgICBzc3I6IGNvbnRleHQuc3NyLFxuICAgICAgICBpc1NwYU1vZGU6IGNvbnRleHQuaXNTcGFNb2RlLFxuICAgICAgICByb3V0ZURpc2NvdmVyeTogY29udGV4dC5yb3V0ZURpc2NvdmVyeSxcbiAgICAgICAgc2VyaWFsaXplRXJyb3I6IGNvbnRleHQuc2VyaWFsaXplRXJyb3IsXG4gICAgICAgIHJlbmRlck1ldGE6IGNvbnRleHQucmVuZGVyTWV0YVxuICAgICAgfVxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIFJlYWN0MTIuY3JlYXRlRWxlbWVudChSZW1peEVycm9yQm91bmRhcnksIHsgbG9jYXRpb246IHJvdXRlci5zdGF0ZS5sb2NhdGlvbiB9LCAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFxuICAgICAgU3RhdGljUm91dGVyUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgY29udGV4dDogY29udGV4dC5zdGF0aWNIYW5kbGVyQ29udGV4dCxcbiAgICAgICAgaHlkcmF0ZTogZmFsc2VcbiAgICAgIH1cbiAgICApKVxuICApLCBjb250ZXh0LnNlcnZlckhhbmRvZmZTdHJlYW0gPyAvKiBAX19QVVJFX18gKi8gUmVhY3QxMi5jcmVhdGVFbGVtZW50KFJlYWN0MTIuU3VzcGVuc2UsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEyLmNyZWF0ZUVsZW1lbnQoXG4gICAgU3RyZWFtVHJhbnNmZXIsXG4gICAge1xuICAgICAgY29udGV4dCxcbiAgICAgIGlkZW50aWZpZXI6IDAsXG4gICAgICByZWFkZXI6IGNvbnRleHQuc2VydmVySGFuZG9mZlN0cmVhbS5nZXRSZWFkZXIoKSxcbiAgICAgIHRleHREZWNvZGVyOiBuZXcgVGV4dERlY29kZXIoKSxcbiAgICAgIG5vbmNlXG4gICAgfVxuICApKSA6IG51bGwpO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9yb3V0ZXMtdGVzdC1zdHViLnRzeFxudmFyIFJlYWN0MTMgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNTdHViKHJvdXRlcywgdW5zdGFibGVfZ2V0Q29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gUm91dGVzVGVzdFN0dWIoe1xuICAgIGluaXRpYWxFbnRyaWVzLFxuICAgIGluaXRpYWxJbmRleCxcbiAgICBoeWRyYXRpb25EYXRhLFxuICAgIGZ1dHVyZVxuICB9KSB7XG4gICAgbGV0IHJvdXRlclJlZiA9IFJlYWN0MTMudXNlUmVmKCk7XG4gICAgbGV0IHJlbWl4Q29udGV4dFJlZiA9IFJlYWN0MTMudXNlUmVmKCk7XG4gICAgaWYgKHJvdXRlclJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJlbWl4Q29udGV4dFJlZi5jdXJyZW50ID0ge1xuICAgICAgICBmdXR1cmU6IHtcbiAgICAgICAgICB1bnN0YWJsZV9zdWJSZXNvdXJjZUludGVncml0eTogZnV0dXJlPy51bnN0YWJsZV9zdWJSZXNvdXJjZUludGVncml0eSA9PT0gdHJ1ZSxcbiAgICAgICAgICB1bnN0YWJsZV9taWRkbGV3YXJlOiBmdXR1cmU/LnVuc3RhYmxlX21pZGRsZXdhcmUgPT09IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbWFuaWZlc3Q6IHtcbiAgICAgICAgICByb3V0ZXM6IHt9LFxuICAgICAgICAgIGVudHJ5OiB7IGltcG9ydHM6IFtdLCBtb2R1bGU6IFwiXCIgfSxcbiAgICAgICAgICB1cmw6IFwiXCIsXG4gICAgICAgICAgdmVyc2lvbjogXCJcIlxuICAgICAgICB9LFxuICAgICAgICByb3V0ZU1vZHVsZXM6IHt9LFxuICAgICAgICBzc3I6IGZhbHNlLFxuICAgICAgICBpc1NwYU1vZGU6IGZhbHNlLFxuICAgICAgICByb3V0ZURpc2NvdmVyeTogeyBtb2RlOiBcImxhenlcIiwgbWFuaWZlc3RQYXRoOiBcIi9fX21hbmlmZXN0XCIgfVxuICAgICAgfTtcbiAgICAgIGxldCBwYXRjaGVkID0gcHJvY2Vzc1JvdXRlcyhcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgU3R1YlJvdXRlT2JqZWN0YCBpcyBzdHJpY3RlciBhYm91dCBgbG9hZGVyYC9gYWN0aW9uYFxuICAgICAgICAvLyB0eXBlcyBjb21wYXJlZCB0byBgQWdub3N0aWNSb3V0ZU9iamVjdGBcbiAgICAgICAgY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyhyb3V0ZXMsIChyKSA9PiByKSxcbiAgICAgICAgcmVtaXhDb250ZXh0UmVmLmN1cnJlbnQubWFuaWZlc3QsXG4gICAgICAgIHJlbWl4Q29udGV4dFJlZi5jdXJyZW50LnJvdXRlTW9kdWxlc1xuICAgICAgKTtcbiAgICAgIHJvdXRlclJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5Um91dGVyKHBhdGNoZWQsIHtcbiAgICAgICAgdW5zdGFibGVfZ2V0Q29udGV4dCxcbiAgICAgICAgaW5pdGlhbEVudHJpZXMsXG4gICAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgICAgaHlkcmF0aW9uRGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QxMy5jcmVhdGVFbGVtZW50KEZyYW1ld29ya0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHJlbWl4Q29udGV4dFJlZi5jdXJyZW50IH0sIC8qIEBfX1BVUkVfXyAqLyBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoUm91dGVyUHJvdmlkZXIsIHsgcm91dGVyOiByb3V0ZXJSZWYuY3VycmVudCB9KSk7XG4gIH07XG59XG5mdW5jdGlvbiB3aXRoQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50NCkge1xuICByZXR1cm4gZnVuY3Rpb24gV3JhcHBlZCgpIHtcbiAgICByZXR1cm4gUmVhY3QxMy5jcmVhdGVFbGVtZW50KENvbXBvbmVudDQsIHtcbiAgICAgIHBhcmFtczogdXNlUGFyYW1zKCksXG4gICAgICBsb2FkZXJEYXRhOiB1c2VMb2FkZXJEYXRhKCksXG4gICAgICBhY3Rpb25EYXRhOiB1c2VBY3Rpb25EYXRhKCksXG4gICAgICBtYXRjaGVzOiB1c2VNYXRjaGVzKClcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHdpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyhIeWRyYXRlRmFsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdyYXBwZWQoKSB7XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICBwYXJhbXM6IHVzZVBhcmFtcygpLFxuICAgICAgbG9hZGVyRGF0YTogdXNlTG9hZGVyRGF0YSgpLFxuICAgICAgYWN0aW9uRGF0YTogdXNlQWN0aW9uRGF0YSgpXG4gICAgfTtcbiAgICByZXR1cm4gUmVhY3QxMy5jcmVhdGVFbGVtZW50KEh5ZHJhdGVGYWxsYmFjaywgcHJvcHMpO1xuICB9O1xufVxuZnVuY3Rpb24gd2l0aEVycm9yQm91bmRhcnlQcm9wcyhFcnJvckJvdW5kYXJ5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXcmFwcGVkKCkge1xuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgcGFyYW1zOiB1c2VQYXJhbXMoKSxcbiAgICAgIGxvYWRlckRhdGE6IHVzZUxvYWRlckRhdGEoKSxcbiAgICAgIGFjdGlvbkRhdGE6IHVzZUFjdGlvbkRhdGEoKSxcbiAgICAgIGVycm9yOiB1c2VSb3V0ZUVycm9yKClcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdDEzLmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwgcHJvcHMpO1xuICB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JvdXRlcyhyb3V0ZXMsIG1hbmlmZXN0LCByb3V0ZU1vZHVsZXMsIHBhcmVudElkKSB7XG4gIHJldHVybiByb3V0ZXMubWFwKChyb3V0ZSkgPT4ge1xuICAgIGlmICghcm91dGUuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIHJvdXRlLmlkIGluIEByZW1peC1ydW4vdGVzdGluZyBwcm9jZXNzUm91dGVzKCkgZnVuY3Rpb25cIlxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IG5ld1JvdXRlID0ge1xuICAgICAgaWQ6IHJvdXRlLmlkLFxuICAgICAgcGF0aDogcm91dGUucGF0aCxcbiAgICAgIGluZGV4OiByb3V0ZS5pbmRleCxcbiAgICAgIENvbXBvbmVudDogcm91dGUuQ29tcG9uZW50ID8gd2l0aENvbXBvbmVudFByb3BzKHJvdXRlLkNvbXBvbmVudCkgOiB2b2lkIDAsXG4gICAgICBIeWRyYXRlRmFsbGJhY2s6IHJvdXRlLkh5ZHJhdGVGYWxsYmFjayA/IHdpdGhIeWRyYXRlRmFsbGJhY2tQcm9wcyhyb3V0ZS5IeWRyYXRlRmFsbGJhY2spIDogdm9pZCAwLFxuICAgICAgRXJyb3JCb3VuZGFyeTogcm91dGUuRXJyb3JCb3VuZGFyeSA/IHdpdGhFcnJvckJvdW5kYXJ5UHJvcHMocm91dGUuRXJyb3JCb3VuZGFyeSkgOiB2b2lkIDAsXG4gICAgICBhY3Rpb246IHJvdXRlLmFjdGlvbixcbiAgICAgIGxvYWRlcjogcm91dGUubG9hZGVyLFxuICAgICAgaGFuZGxlOiByb3V0ZS5oYW5kbGUsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiByb3V0ZS5zaG91bGRSZXZhbGlkYXRlXG4gICAgfTtcbiAgICBsZXQgZW50cnlSb3V0ZSA9IHtcbiAgICAgIGlkOiByb3V0ZS5pZCxcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICBpbmRleDogcm91dGUuaW5kZXgsXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIGhhc0FjdGlvbjogcm91dGUuYWN0aW9uICE9IG51bGwsXG4gICAgICBoYXNMb2FkZXI6IHJvdXRlLmxvYWRlciAhPSBudWxsLFxuICAgICAgLy8gV2hlbiB0ZXN0aW5nIHJvdXRlcywgeW91IHNob3VsZCBiZSBzdHViYmluZyBsb2FkZXIvYWN0aW9uL21pZGRsZXdhcmUsXG4gICAgICAvLyBub3QgdHJ5aW5nIHRvIHJlLWltcGxlbWVudCB0aGUgZnVsbCBsb2FkZXIvY2xpZW50TG9hZGVyL1NTUi9oeWRyYXRpb25cbiAgICAgIC8vIGZsb3cuIFRoYXQgaXMgYmV0dGVyIHRlc3RlZCB2aWEgRTJFIHRlc3RzLlxuICAgICAgaGFzQ2xpZW50QWN0aW9uOiBmYWxzZSxcbiAgICAgIGhhc0NsaWVudExvYWRlcjogZmFsc2UsXG4gICAgICBoYXNDbGllbnRNaWRkbGV3YXJlOiBmYWxzZSxcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IHJvdXRlLkVycm9yQm91bmRhcnkgIT0gbnVsbCxcbiAgICAgIC8vIGFueSBuZWVkIGZvciB0aGVzZT9cbiAgICAgIG1vZHVsZTogXCJidWlsZC9zdHViLXBhdGgtdG8tbW9kdWxlLmpzXCIsXG4gICAgICBjbGllbnRBY3Rpb25Nb2R1bGU6IHZvaWQgMCxcbiAgICAgIGNsaWVudExvYWRlck1vZHVsZTogdm9pZCAwLFxuICAgICAgY2xpZW50TWlkZGxld2FyZU1vZHVsZTogdm9pZCAwLFxuICAgICAgaHlkcmF0ZUZhbGxiYWNrTW9kdWxlOiB2b2lkIDBcbiAgICB9O1xuICAgIG1hbmlmZXN0LnJvdXRlc1tuZXdSb3V0ZS5pZF0gPSBlbnRyeVJvdXRlO1xuICAgIHJvdXRlTW9kdWxlc1tyb3V0ZS5pZF0gPSB7XG4gICAgICBkZWZhdWx0OiBuZXdSb3V0ZS5Db21wb25lbnQgfHwgT3V0bGV0LFxuICAgICAgRXJyb3JCb3VuZGFyeTogbmV3Um91dGUuRXJyb3JCb3VuZGFyeSB8fCB2b2lkIDAsXG4gICAgICBoYW5kbGU6IHJvdXRlLmhhbmRsZSxcbiAgICAgIGxpbmtzOiByb3V0ZS5saW5rcyxcbiAgICAgIG1ldGE6IHJvdXRlLm1ldGEsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiByb3V0ZS5zaG91bGRSZXZhbGlkYXRlXG4gICAgfTtcbiAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgIG5ld1JvdXRlLmNoaWxkcmVuID0gcHJvY2Vzc1JvdXRlcyhcbiAgICAgICAgcm91dGUuY2hpbGRyZW4sXG4gICAgICAgIG1hbmlmZXN0LFxuICAgICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICAgIG5ld1JvdXRlLmlkXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3Um91dGU7XG4gIH0pO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvY29va2llcy50c1xudmFyIGltcG9ydF9jb29raWUgPSByZXF1aXJlKFwiY29va2llXCIpO1xuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvY3J5cHRvLnRzXG52YXIgZW5jb2RlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVGV4dEVuY29kZXIoKTtcbnZhciBzaWduID0gYXN5bmMgKHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgbGV0IGRhdGEyID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICBsZXQga2V5ID0gYXdhaXQgY3JlYXRlS2V5MihzZWNyZXQsIFtcInNpZ25cIl0pO1xuICBsZXQgc2lnbmF0dXJlID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKFwiSE1BQ1wiLCBrZXksIGRhdGEyKTtcbiAgbGV0IGhhc2ggPSBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSkpLnJlcGxhY2UoXG4gICAgLz0rJC8sXG4gICAgXCJcIlxuICApO1xuICByZXR1cm4gdmFsdWUgKyBcIi5cIiArIGhhc2g7XG59O1xudmFyIHVuc2lnbiA9IGFzeW5jIChjb29raWUsIHNlY3JldCkgPT4ge1xuICBsZXQgaW5kZXggPSBjb29raWUubGFzdEluZGV4T2YoXCIuXCIpO1xuICBsZXQgdmFsdWUgPSBjb29raWUuc2xpY2UoMCwgaW5kZXgpO1xuICBsZXQgaGFzaCA9IGNvb2tpZS5zbGljZShpbmRleCArIDEpO1xuICBsZXQgZGF0YTIgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gIGxldCBrZXkgPSBhd2FpdCBjcmVhdGVLZXkyKHNlY3JldCwgW1widmVyaWZ5XCJdKTtcbiAgbGV0IHNpZ25hdHVyZSA9IGJ5dGVTdHJpbmdUb1VpbnQ4QXJyYXkoYXRvYihoYXNoKSk7XG4gIGxldCB2YWxpZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUudmVyaWZ5KFwiSE1BQ1wiLCBrZXksIHNpZ25hdHVyZSwgZGF0YTIpO1xuICByZXR1cm4gdmFsaWQgPyB2YWx1ZSA6IGZhbHNlO1xufTtcbnZhciBjcmVhdGVLZXkyID0gYXN5bmMgKHNlY3JldCwgdXNhZ2VzKSA9PiBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgXCJyYXdcIixcbiAgZW5jb2Rlci5lbmNvZGUoc2VjcmV0KSxcbiAgeyBuYW1lOiBcIkhNQUNcIiwgaGFzaDogXCJTSEEtMjU2XCIgfSxcbiAgZmFsc2UsXG4gIHVzYWdlc1xuKTtcbmZ1bmN0aW9uIGJ5dGVTdHJpbmdUb1VpbnQ4QXJyYXkoYnl0ZVN0cmluZykge1xuICBsZXQgYXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlU3RyaW5nLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2Nvb2tpZXMudHNcbnZhciBjcmVhdGVDb29raWUgPSAobmFtZSwgY29va2llT3B0aW9ucyA9IHt9KSA9PiB7XG4gIGxldCB7IHNlY3JldHMgPSBbXSwgLi4ub3B0aW9ucyB9ID0ge1xuICAgIHBhdGg6IFwiL1wiLFxuICAgIHNhbWVTaXRlOiBcImxheFwiLFxuICAgIC4uLmNvb2tpZU9wdGlvbnNcbiAgfTtcbiAgd2Fybk9uY2VBYm91dEV4cGlyZXNDb29raWUobmFtZSwgb3B0aW9ucy5leHBpcmVzKTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH0sXG4gICAgZ2V0IGlzU2lnbmVkKCkge1xuICAgICAgcmV0dXJuIHNlY3JldHMubGVuZ3RoID4gMDtcbiAgICB9LFxuICAgIGdldCBleHBpcmVzKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvcHRpb25zLm1heEFnZSAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBEYXRlKERhdGUubm93KCkgKyBvcHRpb25zLm1heEFnZSAqIDFlMykgOiBvcHRpb25zLmV4cGlyZXM7XG4gICAgfSxcbiAgICBhc3luYyBwYXJzZShjb29raWVIZWFkZXIsIHBhcnNlT3B0aW9ucykge1xuICAgICAgaWYgKCFjb29raWVIZWFkZXIpIHJldHVybiBudWxsO1xuICAgICAgbGV0IGNvb2tpZXMgPSAoMCwgaW1wb3J0X2Nvb2tpZS5wYXJzZSkoY29va2llSGVhZGVyLCB7IC4uLm9wdGlvbnMsIC4uLnBhcnNlT3B0aW9ucyB9KTtcbiAgICAgIGlmIChuYW1lIGluIGNvb2tpZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gY29va2llc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSAhPT0gXCJcIikge1xuICAgICAgICAgIGxldCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpO1xuICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIHNlcmlhbGl6ZSh2YWx1ZSwgc2VyaWFsaXplT3B0aW9ucykge1xuICAgICAgcmV0dXJuICgwLCBpbXBvcnRfY29va2llLnNlcmlhbGl6ZSkoXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlID09PSBcIlwiID8gXCJcIiA6IGF3YWl0IGVuY29kZUNvb2tpZVZhbHVlKHZhbHVlLCBzZWNyZXRzKSxcbiAgICAgICAge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgLi4uc2VyaWFsaXplT3B0aW9uc1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfTtcbn07XG52YXIgaXNDb29raWUgPSAob2JqZWN0KSA9PiB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0Lm5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9iamVjdC5pc1NpZ25lZCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZW9mIG9iamVjdC5wYXJzZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3Quc2VyaWFsaXplID09PSBcImZ1bmN0aW9uXCI7XG59O1xuYXN5bmMgZnVuY3Rpb24gZW5jb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpIHtcbiAgbGV0IGVuY29kZWQgPSBlbmNvZGVEYXRhKHZhbHVlKTtcbiAgaWYgKHNlY3JldHMubGVuZ3RoID4gMCkge1xuICAgIGVuY29kZWQgPSBhd2FpdCBzaWduKGVuY29kZWQsIHNlY3JldHNbMF0pO1xuICB9XG4gIHJldHVybiBlbmNvZGVkO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjb2RlQ29va2llVmFsdWUodmFsdWUsIHNlY3JldHMpIHtcbiAgaWYgKHNlY3JldHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAobGV0IHNlY3JldCBvZiBzZWNyZXRzKSB7XG4gICAgICBsZXQgdW5zaWduZWRWYWx1ZSA9IGF3YWl0IHVuc2lnbih2YWx1ZSwgc2VjcmV0KTtcbiAgICAgIGlmICh1bnNpZ25lZFZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlRGF0YSh1bnNpZ25lZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGRlY29kZURhdGEodmFsdWUpO1xufVxuZnVuY3Rpb24gZW5jb2RlRGF0YSh2YWx1ZSkge1xuICByZXR1cm4gYnRvYShteVVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh2YWx1ZSkpKSk7XG59XG5mdW5jdGlvbiBkZWNvZGVEYXRhKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KG15RXNjYXBlKGF0b2IodmFsdWUpKSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuZnVuY3Rpb24gbXlFc2NhcGUodmFsdWUpIHtcbiAgbGV0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgY2hyLCBjb2RlO1xuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgY2hyID0gc3RyLmNoYXJBdChpbmRleCsrKTtcbiAgICBpZiAoL1tcXHcqK1xcLS4vQF0vLmV4ZWMoY2hyKSkge1xuICAgICAgcmVzdWx0ICs9IGNocjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IGNoci5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiJVwiICsgaGV4KGNvZGUsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiJXVcIiArIGhleChjb2RlLCA0KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaGV4KGNvZGUsIGxlbmd0aCkge1xuICBsZXQgcmVzdWx0ID0gY29kZS50b1N0cmluZygxNik7XG4gIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgbGVuZ3RoKSByZXN1bHQgPSBcIjBcIiArIHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG15VW5lc2NhcGUodmFsdWUpIHtcbiAgbGV0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgY2hyLCBwYXJ0O1xuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgY2hyID0gc3RyLmNoYXJBdChpbmRleCsrKTtcbiAgICBpZiAoY2hyID09PSBcIiVcIikge1xuICAgICAgaWYgKHN0ci5jaGFyQXQoaW5kZXgpID09PSBcInVcIikge1xuICAgICAgICBwYXJ0ID0gc3RyLnNsaWNlKGluZGV4ICsgMSwgaW5kZXggKyA1KTtcbiAgICAgICAgaWYgKC9eW1xcZGEtZl17NH0kL2kuZXhlYyhwYXJ0KSkge1xuICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHBhcnQsIDE2KSk7XG4gICAgICAgICAgaW5kZXggKz0gNTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydCA9IHN0ci5zbGljZShpbmRleCwgaW5kZXggKyAyKTtcbiAgICAgICAgaWYgKC9eW1xcZGEtZl17Mn0kL2kuZXhlYyhwYXJ0KSkge1xuICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHBhcnQsIDE2KSk7XG4gICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQgKz0gY2hyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3YXJuT25jZUFib3V0RXhwaXJlc0Nvb2tpZShuYW1lLCBleHBpcmVzKSB7XG4gIHdhcm5PbmNlKFxuICAgICFleHBpcmVzLFxuICAgIGBUaGUgXCIke25hbWV9XCIgY29va2llIGhhcyBhbiBcImV4cGlyZXNcIiBwcm9wZXJ0eSBzZXQuIFRoaXMgd2lsbCBjYXVzZSB0aGUgZXhwaXJlcyB2YWx1ZSB0byBub3QgYmUgdXBkYXRlZCB3aGVuIHRoZSBzZXNzaW9uIGlzIGNvbW1pdHRlZC4gSW5zdGVhZCwgeW91IHNob3VsZCBzZXQgdGhlIGV4cGlyZXMgdmFsdWUgd2hlbiBzZXJpYWxpemluZyB0aGUgY29va2llLiBZb3UgY2FuIHVzZSBcXGBjb21taXRTZXNzaW9uKHNlc3Npb24sIHsgZXhwaXJlcyB9KVxcYCBpZiB1c2luZyBhIHNlc3Npb24gc3RvcmFnZSBvYmplY3QsIG9yIFxcYGNvb2tpZS5zZXJpYWxpemUoXCJ2YWx1ZVwiLCB7IGV4cGlyZXMgfSlcXGAgaWYgeW91J3JlIHVzaW5nIHRoZSBjb29raWUgZGlyZWN0bHkuYFxuICApO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZW50cnkudHNcbmZ1bmN0aW9uIGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzKG1hbmlmZXN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtYW5pZmVzdCkucmVkdWNlKChtZW1vMiwgcm91dGVJZCkgPT4ge1xuICAgIGxldCByb3V0ZSA9IG1hbmlmZXN0W3JvdXRlSWRdO1xuICAgIGlmIChyb3V0ZSkge1xuICAgICAgbWVtbzJbcm91dGVJZF0gPSByb3V0ZS5tb2R1bGU7XG4gICAgfVxuICAgIHJldHVybiBtZW1vMjtcbiAgfSwge30pO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvbW9kZS50c1xudmFyIFNlcnZlck1vZGUgPSAvKiBAX19QVVJFX18gKi8gKChTZXJ2ZXJNb2RlMikgPT4ge1xuICBTZXJ2ZXJNb2RlMltcIkRldmVsb3BtZW50XCJdID0gXCJkZXZlbG9wbWVudFwiO1xuICBTZXJ2ZXJNb2RlMltcIlByb2R1Y3Rpb25cIl0gPSBcInByb2R1Y3Rpb25cIjtcbiAgU2VydmVyTW9kZTJbXCJUZXN0XCJdID0gXCJ0ZXN0XCI7XG4gIHJldHVybiBTZXJ2ZXJNb2RlMjtcbn0pKFNlcnZlck1vZGUgfHwge30pO1xuZnVuY3Rpb24gaXNTZXJ2ZXJNb2RlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gXCJkZXZlbG9wbWVudFwiIC8qIERldmVsb3BtZW50ICovIHx8IHZhbHVlID09PSBcInByb2R1Y3Rpb25cIiAvKiBQcm9kdWN0aW9uICovIHx8IHZhbHVlID09PSBcInRlc3RcIiAvKiBUZXN0ICovO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZXJyb3JzLnRzXG5mdW5jdGlvbiBzYW5pdGl6ZUVycm9yKGVycm9yLCBzZXJ2ZXJNb2RlKSB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIHNlcnZlck1vZGUgIT09IFwiZGV2ZWxvcG1lbnRcIiAvKiBEZXZlbG9wbWVudCAqLykge1xuICAgIGxldCBzYW5pdGl6ZWQgPSBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiKTtcbiAgICBzYW5pdGl6ZWQuc3RhY2sgPSB2b2lkIDA7XG4gICAgcmV0dXJuIHNhbml0aXplZDtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUVycm9ycyhlcnJvcnMsIHNlcnZlck1vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGVycm9ycykucmVkdWNlKChhY2MsIFtyb3V0ZUlkLCBlcnJvcl0pID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2MsIHsgW3JvdXRlSWRdOiBzYW5pdGl6ZUVycm9yKGVycm9yLCBzZXJ2ZXJNb2RlKSB9KTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRXJyb3IoZXJyb3IsIHNlcnZlck1vZGUpIHtcbiAgbGV0IHNhbml0aXplZCA9IHNhbml0aXplRXJyb3IoZXJyb3IsIHNlcnZlck1vZGUpO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IHNhbml0aXplZC5tZXNzYWdlLFxuICAgIHN0YWNrOiBzYW5pdGl6ZWQuc3RhY2tcbiAgfTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yczIoZXJyb3JzLCBzZXJ2ZXJNb2RlKSB7XG4gIGlmICghZXJyb3JzKSByZXR1cm4gbnVsbDtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xuICBsZXQgc2VyaWFsaXplZCA9IHt9O1xuICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGVudHJpZXMpIHtcbiAgICBpZiAoaXNSb3V0ZUVycm9yUmVzcG9uc2UodmFsKSkge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0geyAuLi52YWwsIF9fdHlwZTogXCJSb3V0ZUVycm9yUmVzcG9uc2VcIiB9O1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGxldCBzYW5pdGl6ZWQgPSBzYW5pdGl6ZUVycm9yKHZhbCwgc2VydmVyTW9kZSk7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB7XG4gICAgICAgIG1lc3NhZ2U6IHNhbml0aXplZC5tZXNzYWdlLFxuICAgICAgICBzdGFjazogc2FuaXRpemVkLnN0YWNrLFxuICAgICAgICBfX3R5cGU6IFwiRXJyb3JcIixcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN1YmNsYXNzIChpLmUuLCBSZWZlcmVuY2VFcnJvciksIHNlbmQgdXAgdGhlIHR5cGUgc28gd2VcbiAgICAgICAgLy8gY2FuIHJlLWNyZWF0ZSB0aGUgc2FtZSB0eXBlIGR1cmluZyBoeWRyYXRpb24uICBUaGlzIHdpbGwgb25seSBhcHBseVxuICAgICAgICAvLyBpbiBkZXYgbW9kZSBzaW5jZSBhbGwgcHJvZHVjdGlvbiBlcnJvcnMgYXJlIHNhbml0aXplZCB0byBub3JtYWxcbiAgICAgICAgLy8gRXJyb3IgaW5zdGFuY2VzXG4gICAgICAgIC4uLnNhbml0aXplZC5uYW1lICE9PSBcIkVycm9yXCIgPyB7XG4gICAgICAgICAgX19zdWJUeXBlOiBzYW5pdGl6ZWQubmFtZVxuICAgICAgICB9IDoge31cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9yb3V0ZU1hdGNoaW5nLnRzXG5mdW5jdGlvbiBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHBhdGhuYW1lLCBiYXNlbmFtZSkge1xuICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKFxuICAgIHJvdXRlcyxcbiAgICBwYXRobmFtZSxcbiAgICBiYXNlbmFtZVxuICApO1xuICBpZiAoIW1hdGNoZXMpIHJldHVybiBudWxsO1xuICByZXR1cm4gbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiAoe1xuICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaC5wYXRobmFtZSxcbiAgICByb3V0ZTogbWF0Y2gucm91dGVcbiAgfSkpO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvZGF0YS50c1xuYXN5bmMgZnVuY3Rpb24gY2FsbFJvdXRlSGFuZGxlcihoYW5kbGVyLCBhcmdzKSB7XG4gIGxldCByZXN1bHQgPSBhd2FpdCBoYW5kbGVyKHtcbiAgICByZXF1ZXN0OiBzdHJpcFJvdXRlc1BhcmFtKHN0cmlwSW5kZXhQYXJhbTIoYXJncy5yZXF1ZXN0KSksXG4gICAgcGFyYW1zOiBhcmdzLnBhcmFtcyxcbiAgICBjb250ZXh0OiBhcmdzLmNvbnRleHRcbiAgfSk7XG4gIGlmIChpc0RhdGFXaXRoUmVzcG9uc2VJbml0KHJlc3VsdCkgJiYgcmVzdWx0LmluaXQgJiYgcmVzdWx0LmluaXQuc3RhdHVzICYmIGlzUmVkaXJlY3RTdGF0dXNDb2RlKHJlc3VsdC5pbml0LnN0YXR1cykpIHtcbiAgICB0aHJvdyBuZXcgUmVzcG9uc2UobnVsbCwgcmVzdWx0LmluaXQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzdHJpcEluZGV4UGFyYW0yKHJlcXVlc3QpIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICBsZXQgaW5kZXhWYWx1ZXMgPSB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICBsZXQgaW5kZXhWYWx1ZXNUb0tlZXAgPSBbXTtcbiAgZm9yIChsZXQgaW5kZXhWYWx1ZSBvZiBpbmRleFZhbHVlcykge1xuICAgIGlmIChpbmRleFZhbHVlKSB7XG4gICAgICBpbmRleFZhbHVlc1RvS2VlcC5wdXNoKGluZGV4VmFsdWUpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCB0b0tlZXAgb2YgaW5kZXhWYWx1ZXNUb0tlZXApIHtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImluZGV4XCIsIHRvS2VlcCk7XG4gIH1cbiAgbGV0IGluaXQgPSB7XG4gICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICBib2R5OiByZXF1ZXN0LmJvZHksXG4gICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgfTtcbiAgaWYgKGluaXQuYm9keSkge1xuICAgIGluaXQuZHVwbGV4ID0gXCJoYWxmXCI7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybC5ocmVmLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHN0cmlwUm91dGVzUGFyYW0ocmVxdWVzdCkge1xuICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKFwiX3JvdXRlc1wiKTtcbiAgbGV0IGluaXQgPSB7XG4gICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICBib2R5OiByZXF1ZXN0LmJvZHksXG4gICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgfTtcbiAgaWYgKGluaXQuYm9keSkge1xuICAgIGluaXQuZHVwbGV4ID0gXCJoYWxmXCI7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybC5ocmVmLCBpbml0KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2ludmFyaWFudC50c1xuZnVuY3Rpb24gaW52YXJpYW50Myh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIlRoZSBmb2xsb3dpbmcgZXJyb3IgaXMgYSBidWcgaW4gUmVhY3QgUm91dGVyOyBwbGVhc2Ugb3BlbiBhbiBpc3N1ZSEgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZWFjdC1yb3V0ZXIvaXNzdWVzL25ldy9jaG9vc2VcIlxuICAgICk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9kZXYudHNcbnZhciBnbG9iYWxEZXZTZXJ2ZXJIb29rc0tleSA9IFwiX19yZWFjdFJvdXRlckRldlNlcnZlckhvb2tzXCI7XG5mdW5jdGlvbiBzZXREZXZTZXJ2ZXJIb29rcyhkZXZTZXJ2ZXJIb29rcykge1xuICBnbG9iYWxUaGlzW2dsb2JhbERldlNlcnZlckhvb2tzS2V5XSA9IGRldlNlcnZlckhvb2tzO1xufVxuZnVuY3Rpb24gZ2V0RGV2U2VydmVySG9va3MoKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzW2dsb2JhbERldlNlcnZlckhvb2tzS2V5XTtcbn1cbmZ1bmN0aW9uIGdldEJ1aWxkVGltZUhlYWRlcihyZXF1ZXN0LCBoZWFkZXJOYW1lKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRyeSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnY/LklTX1JSX0JVSUxEX1JFUVVFU1QgPT09IFwieWVzXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3QuaGVhZGVycy5nZXQoaGVhZGVyTmFtZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3JvdXRlcy50c1xuZnVuY3Rpb24gZ3JvdXBSb3V0ZXNCeVBhcmVudElkMihtYW5pZmVzdCkge1xuICBsZXQgcm91dGVzID0ge307XG4gIE9iamVjdC52YWx1ZXMobWFuaWZlc3QpLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgaWYgKHJvdXRlKSB7XG4gICAgICBsZXQgcGFyZW50SWQgPSByb3V0ZS5wYXJlbnRJZCB8fCBcIlwiO1xuICAgICAgaWYgKCFyb3V0ZXNbcGFyZW50SWRdKSB7XG4gICAgICAgIHJvdXRlc1twYXJlbnRJZF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHJvdXRlc1twYXJlbnRJZF0ucHVzaChyb3V0ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvdXRlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcyhtYW5pZmVzdCwgcGFyZW50SWQgPSBcIlwiLCByb3V0ZXNCeVBhcmVudElkID0gZ3JvdXBSb3V0ZXNCeVBhcmVudElkMihtYW5pZmVzdCkpIHtcbiAgcmV0dXJuIChyb3V0ZXNCeVBhcmVudElkW3BhcmVudElkXSB8fCBbXSkubWFwKChyb3V0ZSkgPT4gKHtcbiAgICAuLi5yb3V0ZSxcbiAgICBjaGlsZHJlbjogY3JlYXRlUm91dGVzKG1hbmlmZXN0LCByb3V0ZS5pZCwgcm91dGVzQnlQYXJlbnRJZClcbiAgfSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGljSGFuZGxlckRhdGFSb3V0ZXMobWFuaWZlc3QsIGZ1dHVyZSwgcGFyZW50SWQgPSBcIlwiLCByb3V0ZXNCeVBhcmVudElkID0gZ3JvdXBSb3V0ZXNCeVBhcmVudElkMihtYW5pZmVzdCkpIHtcbiAgcmV0dXJuIChyb3V0ZXNCeVBhcmVudElkW3BhcmVudElkXSB8fCBbXSkubWFwKChyb3V0ZSkgPT4ge1xuICAgIGxldCBjb21tb25Sb3V0ZSA9IHtcbiAgICAgIC8vIEFsd2F5cyBpbmNsdWRlIHJvb3QgZHVlIHRvIGRlZmF1bHQgYm91bmRhcmllc1xuICAgICAgaGFzRXJyb3JCb3VuZGFyeTogcm91dGUuaWQgPT09IFwicm9vdFwiIHx8IHJvdXRlLm1vZHVsZS5FcnJvckJvdW5kYXJ5ICE9IG51bGwsXG4gICAgICBpZDogcm91dGUuaWQsXG4gICAgICBwYXRoOiByb3V0ZS5wYXRoLFxuICAgICAgdW5zdGFibGVfbWlkZGxld2FyZTogcm91dGUubW9kdWxlLnVuc3RhYmxlX21pZGRsZXdhcmUsXG4gICAgICAvLyBOZWVkIHRvIHVzZSBSUidzIHZlcnNpb24gaW4gdGhlIHBhcmFtIHR5cGVkIGhlcmUgdG8gcGVybWl0IHRoZSBvcHRpb25hbFxuICAgICAgLy8gY29udGV4dCBldmVuIHRob3VnaCB3ZSBrbm93IGl0J2xsIGFsd2F5cyBiZSBwcm92aWRlZCBpbiByZW1peFxuICAgICAgbG9hZGVyOiByb3V0ZS5tb2R1bGUubG9hZGVyID8gYXN5bmMgKGFyZ3MpID0+IHtcbiAgICAgICAgbGV0IHByZVJlbmRlcmVkRGF0YSA9IGdldEJ1aWxkVGltZUhlYWRlcihcbiAgICAgICAgICBhcmdzLnJlcXVlc3QsXG4gICAgICAgICAgXCJYLVJlYWN0LVJvdXRlci1QcmVyZW5kZXItRGF0YVwiXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwcmVSZW5kZXJlZERhdGEgIT0gbnVsbCkge1xuICAgICAgICAgIGxldCBlbmNvZGVkID0gcHJlUmVuZGVyZWREYXRhID8gZGVjb2RlVVJJKHByZVJlbmRlcmVkRGF0YSkgOiBwcmVSZW5kZXJlZERhdGE7XG4gICAgICAgICAgaW52YXJpYW50MyhlbmNvZGVkLCBcIk1pc3NpbmcgcHJlcmVuZGVyZWQgZGF0YSBmb3Igcm91dGVcIik7XG4gICAgICAgICAgbGV0IHVpbnQ4YXJyYXkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZW5jb2RlZCk7XG4gICAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh1aW50OGFycmF5KTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCBkZWNvZGVkID0gYXdhaXQgZGVjb2RlVmlhVHVyYm9TdHJlYW0oc3RyZWFtLCBnbG9iYWwpO1xuICAgICAgICAgIGxldCBkYXRhMiA9IGRlY29kZWQudmFsdWU7XG4gICAgICAgICAgaWYgKGRhdGEyICYmIFNpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wgaW4gZGF0YTIpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBkYXRhMltTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sXTtcbiAgICAgICAgICAgIGxldCBpbml0ID0geyBzdGF0dXM6IHJlc3VsdC5zdGF0dXMgfTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVsb2FkKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlZGlyZWN0RG9jdW1lbnQocmVzdWx0LnJlZGlyZWN0LCBpbml0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnJlcGxhY2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVwbGFjZShyZXN1bHQucmVkaXJlY3QsIGluaXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVkaXJlY3QocmVzdWx0LnJlZGlyZWN0LCBpbml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW52YXJpYW50MyhcbiAgICAgICAgICAgICAgZGF0YTIgJiYgcm91dGUuaWQgaW4gZGF0YTIsXG4gICAgICAgICAgICAgIFwiVW5hYmxlIHRvIGRlY29kZSBwcmVyZW5kZXJlZCBkYXRhXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZGF0YTJbcm91dGUuaWRdO1xuICAgICAgICAgICAgaW52YXJpYW50MyhcbiAgICAgICAgICAgICAgXCJkYXRhXCIgaW4gcmVzdWx0LFxuICAgICAgICAgICAgICBcIlVuYWJsZSB0byBwcm9jZXNzIHByZXJlbmRlcmVkIGRhdGFcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbCA9IGF3YWl0IGNhbGxSb3V0ZUhhbmRsZXIocm91dGUubW9kdWxlLmxvYWRlciwgYXJncyk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9IDogdm9pZCAwLFxuICAgICAgYWN0aW9uOiByb3V0ZS5tb2R1bGUuYWN0aW9uID8gKGFyZ3MpID0+IGNhbGxSb3V0ZUhhbmRsZXIocm91dGUubW9kdWxlLmFjdGlvbiwgYXJncykgOiB2b2lkIDAsXG4gICAgICBoYW5kbGU6IHJvdXRlLm1vZHVsZS5oYW5kbGVcbiAgICB9O1xuICAgIHJldHVybiByb3V0ZS5pbmRleCA/IHtcbiAgICAgIGluZGV4OiB0cnVlLFxuICAgICAgLi4uY29tbW9uUm91dGVcbiAgICB9IDoge1xuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGNoaWxkcmVuOiBjcmVhdGVTdGF0aWNIYW5kbGVyRGF0YVJvdXRlcyhcbiAgICAgICAgbWFuaWZlc3QsXG4gICAgICAgIGZ1dHVyZSxcbiAgICAgICAgcm91dGUuaWQsXG4gICAgICAgIHJvdXRlc0J5UGFyZW50SWRcbiAgICAgICksXG4gICAgICAuLi5jb21tb25Sb3V0ZVxuICAgIH07XG4gIH0pO1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvbWFya3VwLnRzXG52YXIgRVNDQVBFX0xPT0tVUDMgPSB7XG4gIFwiJlwiOiBcIlxcXFx1MDAyNlwiLFxuICBcIj5cIjogXCJcXFxcdTAwM2VcIixcbiAgXCI8XCI6IFwiXFxcXHUwMDNjXCIsXG4gIFwiXFx1MjAyOFwiOiBcIlxcXFx1MjAyOFwiLFxuICBcIlxcdTIwMjlcIjogXCJcXFxcdTIwMjlcIlxufTtcbnZhciBFU0NBUEVfUkVHRVgzID0gL1smPjxcXHUyMDI4XFx1MjAyOV0vZztcbmZ1bmN0aW9uIGVzY2FwZUh0bWwyKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwucmVwbGFjZShFU0NBUEVfUkVHRVgzLCAobWF0Y2gpID0+IEVTQ0FQRV9MT09LVVAzW21hdGNoXSk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zZXJ2ZXJIYW5kb2ZmLnRzXG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKHNlcnZlckhhbmRvZmYpIHtcbiAgcmV0dXJuIGVzY2FwZUh0bWwyKEpTT04uc3RyaW5naWZ5KHNlcnZlckhhbmRvZmYpKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL2hlYWRlcnMudHNcbnZhciBpbXBvcnRfc2V0X2Nvb2tpZV9wYXJzZXIgPSByZXF1aXJlKFwic2V0LWNvb2tpZS1wYXJzZXJcIik7XG5mdW5jdGlvbiBnZXREb2N1bWVudEhlYWRlcnMoYnVpbGQsIGNvbnRleHQpIHtcbiAgbGV0IGJvdW5kYXJ5SWR4ID0gY29udGV4dC5lcnJvcnMgPyBjb250ZXh0Lm1hdGNoZXMuZmluZEluZGV4KChtKSA9PiBjb250ZXh0LmVycm9yc1ttLnJvdXRlLmlkXSkgOiAtMTtcbiAgbGV0IG1hdGNoZXMgPSBib3VuZGFyeUlkeCA+PSAwID8gY29udGV4dC5tYXRjaGVzLnNsaWNlKDAsIGJvdW5kYXJ5SWR4ICsgMSkgOiBjb250ZXh0Lm1hdGNoZXM7XG4gIGxldCBlcnJvckhlYWRlcnM7XG4gIGlmIChib3VuZGFyeUlkeCA+PSAwKSB7XG4gICAgbGV0IHsgYWN0aW9uSGVhZGVycywgYWN0aW9uRGF0YSwgbG9hZGVySGVhZGVycywgbG9hZGVyRGF0YSB9ID0gY29udGV4dDtcbiAgICBjb250ZXh0Lm1hdGNoZXMuc2xpY2UoYm91bmRhcnlJZHgpLnNvbWUoKG1hdGNoKSA9PiB7XG4gICAgICBsZXQgaWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICAgIGlmIChhY3Rpb25IZWFkZXJzW2lkXSAmJiAoIWFjdGlvbkRhdGEgfHwgIWFjdGlvbkRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSkge1xuICAgICAgICBlcnJvckhlYWRlcnMgPSBhY3Rpb25IZWFkZXJzW2lkXTtcbiAgICAgIH0gZWxzZSBpZiAobG9hZGVySGVhZGVyc1tpZF0gJiYgIWxvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIGVycm9ySGVhZGVycyA9IGxvYWRlckhlYWRlcnNbaWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9ySGVhZGVycyAhPSBudWxsO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBtYXRjaGVzLnJlZHVjZSgocGFyZW50SGVhZGVycywgbWF0Y2gsIGlkeCkgPT4ge1xuICAgIGxldCB7IGlkIH0gPSBtYXRjaC5yb3V0ZTtcbiAgICBsZXQgcm91dGUgPSBidWlsZC5yb3V0ZXNbaWRdO1xuICAgIGludmFyaWFudDMocm91dGUsIGBSb3V0ZSB3aXRoIGlkIFwiJHtpZH1cIiBub3QgZm91bmQgaW4gYnVpbGRgKTtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSByb3V0ZS5tb2R1bGU7XG4gICAgbGV0IGxvYWRlckhlYWRlcnMgPSBjb250ZXh0LmxvYWRlckhlYWRlcnNbaWRdIHx8IG5ldyBIZWFkZXJzKCk7XG4gICAgbGV0IGFjdGlvbkhlYWRlcnMgPSBjb250ZXh0LmFjdGlvbkhlYWRlcnNbaWRdIHx8IG5ldyBIZWFkZXJzKCk7XG4gICAgbGV0IGluY2x1ZGVFcnJvckhlYWRlcnMgPSBlcnJvckhlYWRlcnMgIT0gbnVsbCAmJiBpZHggPT09IG1hdGNoZXMubGVuZ3RoIC0gMTtcbiAgICBsZXQgaW5jbHVkZUVycm9yQ29va2llcyA9IGluY2x1ZGVFcnJvckhlYWRlcnMgJiYgZXJyb3JIZWFkZXJzICE9PSBsb2FkZXJIZWFkZXJzICYmIGVycm9ySGVhZGVycyAhPT0gYWN0aW9uSGVhZGVycztcbiAgICBpZiAocm91dGVNb2R1bGUuaGVhZGVycyA9PSBudWxsKSB7XG4gICAgICBsZXQgaGVhZGVyczIgPSBuZXcgSGVhZGVycyhwYXJlbnRIZWFkZXJzKTtcbiAgICAgIGlmIChpbmNsdWRlRXJyb3JDb29raWVzKSB7XG4gICAgICAgIHByZXBlbmRDb29raWVzKGVycm9ySGVhZGVycywgaGVhZGVyczIpO1xuICAgICAgfVxuICAgICAgcHJlcGVuZENvb2tpZXMoYWN0aW9uSGVhZGVycywgaGVhZGVyczIpO1xuICAgICAgcHJlcGVuZENvb2tpZXMobG9hZGVySGVhZGVycywgaGVhZGVyczIpO1xuICAgICAgcmV0dXJuIGhlYWRlcnMyO1xuICAgIH1cbiAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKFxuICAgICAgcm91dGVNb2R1bGUuaGVhZGVycyA/IHR5cGVvZiByb3V0ZU1vZHVsZS5oZWFkZXJzID09PSBcImZ1bmN0aW9uXCIgPyByb3V0ZU1vZHVsZS5oZWFkZXJzKHtcbiAgICAgICAgbG9hZGVySGVhZGVycyxcbiAgICAgICAgcGFyZW50SGVhZGVycyxcbiAgICAgICAgYWN0aW9uSGVhZGVycyxcbiAgICAgICAgZXJyb3JIZWFkZXJzOiBpbmNsdWRlRXJyb3JIZWFkZXJzID8gZXJyb3JIZWFkZXJzIDogdm9pZCAwXG4gICAgICB9KSA6IHJvdXRlTW9kdWxlLmhlYWRlcnMgOiB2b2lkIDBcbiAgICApO1xuICAgIGlmIChpbmNsdWRlRXJyb3JDb29raWVzKSB7XG4gICAgICBwcmVwZW5kQ29va2llcyhlcnJvckhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIH1cbiAgICBwcmVwZW5kQ29va2llcyhhY3Rpb25IZWFkZXJzLCBoZWFkZXJzKTtcbiAgICBwcmVwZW5kQ29va2llcyhsb2FkZXJIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICBwcmVwZW5kQ29va2llcyhwYXJlbnRIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSwgbmV3IEhlYWRlcnMoKSk7XG59XG5mdW5jdGlvbiBwcmVwZW5kQ29va2llcyhwYXJlbnRIZWFkZXJzLCBjaGlsZEhlYWRlcnMpIHtcbiAgbGV0IHBhcmVudFNldENvb2tpZVN0cmluZyA9IHBhcmVudEhlYWRlcnMuZ2V0KFwiU2V0LUNvb2tpZVwiKTtcbiAgaWYgKHBhcmVudFNldENvb2tpZVN0cmluZykge1xuICAgIGxldCBjb29raWVzID0gKDAsIGltcG9ydF9zZXRfY29va2llX3BhcnNlci5zcGxpdENvb2tpZXNTdHJpbmcpKHBhcmVudFNldENvb2tpZVN0cmluZyk7XG4gICAgbGV0IGNoaWxkQ29va2llcyA9IG5ldyBTZXQoY2hpbGRIZWFkZXJzLmdldFNldENvb2tpZSgpKTtcbiAgICBjb29raWVzLmZvckVhY2goKGNvb2tpZSkgPT4ge1xuICAgICAgaWYgKCFjaGlsZENvb2tpZXMuaGFzKGNvb2tpZSkpIHtcbiAgICAgICAgY2hpbGRIZWFkZXJzLmFwcGVuZChcIlNldC1Db29raWVcIiwgY29va2llKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2luZ2xlLWZldGNoLnRzXG52YXIgU0VSVkVSX05PX0JPRFlfU1RBVFVTX0NPREVTID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAuLi5OT19CT0RZX1NUQVRVU19DT0RFUyxcbiAgMzA0XG5dKTtcbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoQWN0aW9uKGJ1aWxkLCBzZXJ2ZXJNb2RlLCBzdGF0aWNIYW5kbGVyLCByZXF1ZXN0LCBoYW5kbGVyVXJsLCBsb2FkQ29udGV4dCwgaGFuZGxlRXJyb3IpIHtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzcG9uZDIgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICBsZXQgaGVhZGVycyA9IGdldERvY3VtZW50SGVhZGVycyhidWlsZCwgY29udGV4dCk7XG4gICAgICBpZiAoaXNSZWRpcmVjdFN0YXR1c0NvZGUoY29udGV4dC5zdGF0dXNDb2RlKSAmJiBoZWFkZXJzLmhhcyhcIkxvY2F0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgICAgICByZXN1bHQ6IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgICBjb250ZXh0LnN0YXR1c0NvZGUsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgc3RhdHVzOiBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyKSB8fCBlcnIuZXJyb3IpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5lcnJvcnMgPSBzYW5pdGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSk7XG4gICAgICB9XG4gICAgICBsZXQgc2luZ2xlRmV0Y2hSZXN1bHQ7XG4gICAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgICAgc2luZ2xlRmV0Y2hSZXN1bHQgPSB7IGVycm9yOiBPYmplY3QudmFsdWVzKGNvbnRleHQuZXJyb3JzKVswXSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2luZ2xlRmV0Y2hSZXN1bHQgPSB7XG4gICAgICAgICAgZGF0YTogT2JqZWN0LnZhbHVlcyhjb250ZXh0LmFjdGlvbkRhdGEgfHwge30pWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2VuZXJhdGVTaW5nbGVGZXRjaFJlc3BvbnNlKHJlcXVlc3QsIGJ1aWxkLCBzZXJ2ZXJNb2RlLCB7XG4gICAgICAgIHJlc3VsdDogc2luZ2xlRmV0Y2hSZXN1bHQsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogY29udGV4dC5zdGF0dXNDb2RlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciByZXNwb25kID0gcmVzcG9uZDI7XG4gICAgbGV0IGhhbmRsZXJSZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaGFuZGxlclVybCwge1xuICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWwsXG4gICAgICAuLi5yZXF1ZXN0LmJvZHkgPyB7IGR1cGxleDogXCJoYWxmXCIgfSA6IHZvaWQgMFxuICAgIH0pO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5KGhhbmRsZXJSZXF1ZXN0LCB7XG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICBza2lwTG9hZGVyRXJyb3JCdWJibGluZzogdHJ1ZSxcbiAgICAgIHNraXBSZXZhbGlkYXRpb246IHRydWUsXG4gICAgICB1bnN0YWJsZV9yZXNwb25kOiByZXNwb25kMlxuICAgIH0pO1xuICAgIGlmICghaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSByZXNwb25kMihyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgICAgcmVzdWx0OiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KFxuICAgICAgICAgIHJlc3VsdC5zdGF0dXMsXG4gICAgICAgICAgcmVzdWx0LmhlYWRlcnMsXG4gICAgICAgICAgYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgKSxcbiAgICAgICAgaGVhZGVyczogcmVzdWx0LmhlYWRlcnMsXG4gICAgICAgIHN0YXR1czogU0lOR0xFX0ZFVENIX1JFRElSRUNUX1NUQVRVU1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgIHJlc3VsdDogeyBlcnJvciB9LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoKSxcbiAgICAgIHN0YXR1czogNTAwXG4gICAgfSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNpbmdsZUZldGNoTG9hZGVycyhidWlsZCwgc2VydmVyTW9kZSwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgaGFuZGxlclVybCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlc3BvbmQyID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgbGV0IGhlYWRlcnMgPSBnZXREb2N1bWVudEhlYWRlcnMoYnVpbGQsIGNvbnRleHQpO1xuICAgICAgaWYgKGlzUmVkaXJlY3RTdGF0dXNDb2RlKGNvbnRleHQuc3RhdHVzQ29kZSkgJiYgaGVhZGVycy5oYXMoXCJMb2NhdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gZ2VuZXJhdGVTaW5nbGVGZXRjaFJlc3BvbnNlKHJlcXVlc3QsIGJ1aWxkLCBzZXJ2ZXJNb2RlLCB7XG4gICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICBbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF06IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgICAgIGNvbnRleHQuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgc3RhdHVzOiBTSU5HTEVfRkVUQ0hfUkVESVJFQ1RfU1RBVFVTXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHQuZXJyb3JzKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyKSB8fCBlcnIuZXJyb3IpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5lcnJvcnMgPSBzYW5pdGl6ZUVycm9ycyhjb250ZXh0LmVycm9ycywgc2VydmVyTW9kZSk7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0cyA9IHt9O1xuICAgICAgbGV0IGxvYWRlZE1hdGNoZXMgPSBuZXcgU2V0KFxuICAgICAgICBjb250ZXh0Lm1hdGNoZXMuZmlsdGVyKFxuICAgICAgICAgIChtKSA9PiBsb2FkUm91dGVJZHMgPyBsb2FkUm91dGVJZHMuaGFzKG0ucm91dGUuaWQpIDogbS5yb3V0ZS5sb2FkZXIgIT0gbnVsbFxuICAgICAgICApLm1hcCgobSkgPT4gbS5yb3V0ZS5pZClcbiAgICAgICk7XG4gICAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgICAgZm9yIChsZXQgW2lkLCBlcnJvcl0gb2YgT2JqZWN0LmVudHJpZXMoY29udGV4dC5lcnJvcnMpKSB7XG4gICAgICAgICAgcmVzdWx0c1tpZF0gPSB7IGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IFtpZCwgZGF0YTJdIG9mIE9iamVjdC5lbnRyaWVzKGNvbnRleHQubG9hZGVyRGF0YSkpIHtcbiAgICAgICAgaWYgKCEoaWQgaW4gcmVzdWx0cykgJiYgbG9hZGVkTWF0Y2hlcy5oYXMoaWQpKSB7XG4gICAgICAgICAgcmVzdWx0c1tpZF0gPSB7IGRhdGE6IGRhdGEyIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgICAgcmVzdWx0OiByZXN1bHRzLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IGNvbnRleHQuc3RhdHVzQ29kZVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgcmVzcG9uZCA9IHJlc3BvbmQyO1xuICAgIGxldCBoYW5kbGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGhhbmRsZXJVcmwsIHtcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgICB9KTtcbiAgICBsZXQgcm91dGVzUGFyYW0gPSBuZXcgVVJMKHJlcXVlc3QudXJsKS5zZWFyY2hQYXJhbXMuZ2V0KFwiX3JvdXRlc1wiKTtcbiAgICBsZXQgbG9hZFJvdXRlSWRzID0gcm91dGVzUGFyYW0gPyBuZXcgU2V0KHJvdXRlc1BhcmFtLnNwbGl0KFwiLFwiKSkgOiBudWxsO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdGF0aWNIYW5kbGVyLnF1ZXJ5KGhhbmRsZXJSZXF1ZXN0LCB7XG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICBmaWx0ZXJNYXRjaGVzVG9Mb2FkOiAobSkgPT4gIWxvYWRSb3V0ZUlkcyB8fCBsb2FkUm91dGVJZHMuaGFzKG0ucm91dGUuaWQpLFxuICAgICAgc2tpcExvYWRlckVycm9yQnViYmxpbmc6IHRydWUsXG4gICAgICB1bnN0YWJsZV9yZXNwb25kOiByZXNwb25kMlxuICAgIH0pO1xuICAgIGlmICghaXNSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSByZXNwb25kMihyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZVNpbmdsZUZldGNoUmVzcG9uc2UocmVxdWVzdCwgYnVpbGQsIHNlcnZlck1vZGUsIHtcbiAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgW1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2xdOiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KFxuICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgICAgIHJlc3VsdC5oZWFkZXJzLFxuICAgICAgICAgICAgYnVpbGQuYmFzZW5hbWVcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IFNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICByZXR1cm4gZ2VuZXJhdGVTaW5nbGVGZXRjaFJlc3BvbnNlKHJlcXVlc3QsIGJ1aWxkLCBzZXJ2ZXJNb2RlLCB7XG4gICAgICByZXN1bHQ6IHsgcm9vdDogeyBlcnJvciB9IH0sXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycygpLFxuICAgICAgc3RhdHVzOiA1MDBcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2VuZXJhdGVTaW5nbGVGZXRjaFJlc3BvbnNlKHJlcXVlc3QsIGJ1aWxkLCBzZXJ2ZXJNb2RlLCB7XG4gIHJlc3VsdCxcbiAgaGVhZGVycyxcbiAgc3RhdHVzXG59KSB7XG4gIGxldCByZXN1bHRIZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyk7XG4gIHJlc3VsdEhlYWRlcnMuc2V0KFwiWC1SZW1peC1SZXNwb25zZVwiLCBcInllc1wiKTtcbiAgaWYgKFNFUlZFUl9OT19CT0RZX1NUQVRVU19DT0RFUy5oYXMoc3RhdHVzKSkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXMsIGhlYWRlcnM6IHJlc3VsdEhlYWRlcnMgfSk7XG4gIH1cbiAgcmVzdWx0SGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L3gtc2NyaXB0XCIpO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgIGVuY29kZVZpYVR1cmJvU3RyZWFtKFxuICAgICAgcmVzdWx0LFxuICAgICAgcmVxdWVzdC5zaWduYWwsXG4gICAgICBidWlsZC5lbnRyeS5tb2R1bGUuc3RyZWFtVGltZW91dCxcbiAgICAgIHNlcnZlck1vZGVcbiAgICApLFxuICAgIHtcbiAgICAgIHN0YXR1czogc3RhdHVzIHx8IDIwMCxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdEhlYWRlcnNcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBnZXRTaW5nbGVGZXRjaFJlZGlyZWN0KHN0YXR1cywgaGVhZGVycywgYmFzZW5hbWUpIHtcbiAgbGV0IHJlZGlyZWN0MiA9IGhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIik7XG4gIGlmIChiYXNlbmFtZSkge1xuICAgIHJlZGlyZWN0MiA9IHN0cmlwQmFzZW5hbWUocmVkaXJlY3QyLCBiYXNlbmFtZSkgfHwgcmVkaXJlY3QyO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVkaXJlY3Q6IHJlZGlyZWN0MixcbiAgICBzdGF0dXMsXG4gICAgcmV2YWxpZGF0ZTogKFxuICAgICAgLy8gVGVjaG5pY2FsbHkgWC1SZW1peC1SZXZhbGlkYXRlIGlzbid0IG5lZWRlZCBoZXJlIC0gdGhhdCB3YXMgYW4gaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIGRldGFpbCBvZiA/X2RhdGEgcmVxdWVzdHMgYXMgb3VyIHdheSB0byB0ZWxsIHRoZSBmcm9udCBlbmQgdG8gcmV2YWxpZGF0ZSB3aGVuXG4gICAgICAvLyB3ZSBkaWRuJ3QgaGF2ZSBhIHJlc3BvbnNlIGJvZHkgdG8gaW5jbHVkZSB0aGF0IGluZm9ybWF0aW9uIGluLlxuICAgICAgLy8gV2l0aCBzaW5nbGUgZmV0Y2gsIHdlIHRlbGwgdGhlIGZyb250IGVuZCB2aWEgdGhpcyByZXZhbGlkYXRlIGJvb2xlYW4gZmllbGQuXG4gICAgICAvLyBIb3dldmVyLCB3ZSdyZSByZXNwZWN0aW5nIGl0IGZvciBub3cgYmVjYXVzZSBpdCBtYXkgYmUgc29tZXRoaW5nIGZvbGtzIGhhdmVcbiAgICAgIC8vIHVzZWQgaW4gdGhlaXIgb3duIHJlc3BvbnNlc1xuICAgICAgLy8gVE9ETyh2Myk6IENvbnNpZGVyIHJlbW92aW5nIG9yIG1ha2luZyB0aGlzIG9mZmljaWFsIHB1YmxpYyBBUElcbiAgICAgIGhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXZhbGlkYXRlXCIpIHx8IGhlYWRlcnMuaGFzKFwiU2V0LUNvb2tpZVwiKVxuICAgICksXG4gICAgcmVsb2FkOiBoZWFkZXJzLmhhcyhcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpLFxuICAgIHJlcGxhY2U6IGhlYWRlcnMuaGFzKFwiWC1SZW1peC1SZXBsYWNlXCIpXG4gIH07XG59XG5mdW5jdGlvbiBlbmNvZGVWaWFUdXJib1N0cmVhbShkYXRhMiwgcmVxdWVzdFNpZ25hbCwgc3RyZWFtVGltZW91dCwgc2VydmVyTW9kZSkge1xuICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgbGV0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoXG4gICAgKCkgPT4gY29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoXCJTZXJ2ZXIgVGltZW91dFwiKSksXG4gICAgdHlwZW9mIHN0cmVhbVRpbWVvdXQgPT09IFwibnVtYmVyXCIgPyBzdHJlYW1UaW1lb3V0IDogNDk1MFxuICApO1xuICByZXF1ZXN0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dElkKSk7XG4gIHJldHVybiBlbmNvZGUoZGF0YTIsIHtcbiAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgIHBsdWdpbnM6IFtcbiAgICAgICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGxldCB7IG5hbWUsIG1lc3NhZ2UsIHN0YWNrIH0gPSBzZXJ2ZXJNb2RlID09PSBcInByb2R1Y3Rpb25cIiAvKiBQcm9kdWN0aW9uICovID8gc2FuaXRpemVFcnJvcih2YWx1ZSwgc2VydmVyTW9kZSkgOiB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gW1wiU2FuaXRpemVkRXJyb3JcIiwgbmFtZSwgbWVzc2FnZSwgc3RhY2tdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yUmVzcG9uc2VJbXBsKSB7XG4gICAgICAgICAgbGV0IHsgZGF0YTogZGF0YTMsIHN0YXR1cywgc3RhdHVzVGV4dCB9ID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIFtcIkVycm9yUmVzcG9uc2VcIiwgZGF0YTMsIHN0YXR1cywgc3RhdHVzVGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBTaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sIGluIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIFtcIlNpbmdsZUZldGNoUmVkaXJlY3RcIiwgdmFsdWVbU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbF1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXSxcbiAgICBwb3N0UGx1Z2luczogW1xuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiU2luZ2xlRmV0Y2hDbGFzc0luc3RhbmNlXCIsXG4gICAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHZhbHVlKSlcbiAgICAgICAgXTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiBbXCJTaW5nbGVGZXRjaEZhbGxiYWNrXCJdXG4gICAgXVxuICB9KTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3NlcnZlci50c1xuZnVuY3Rpb24gZGVyaXZlKGJ1aWxkLCBtb2RlKSB7XG4gIGxldCByb3V0ZXMgPSBjcmVhdGVSb3V0ZXMoYnVpbGQucm91dGVzKTtcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjcmVhdGVTdGF0aWNIYW5kbGVyRGF0YVJvdXRlcyhidWlsZC5yb3V0ZXMsIGJ1aWxkLmZ1dHVyZSk7XG4gIGxldCBzZXJ2ZXJNb2RlID0gaXNTZXJ2ZXJNb2RlKG1vZGUpID8gbW9kZSA6IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi87XG4gIGxldCBzdGF0aWNIYW5kbGVyID0gY3JlYXRlU3RhdGljSGFuZGxlcihkYXRhUm91dGVzLCB7XG4gICAgYmFzZW5hbWU6IGJ1aWxkLmJhc2VuYW1lXG4gIH0pO1xuICBsZXQgZXJyb3JIYW5kbGVyID0gYnVpbGQuZW50cnkubW9kdWxlLmhhbmRsZUVycm9yIHx8ICgoZXJyb3IsIHsgcmVxdWVzdCB9KSA9PiB7XG4gICAgaWYgKHNlcnZlck1vZGUgIT09IFwidGVzdFwiIC8qIFRlc3QgKi8gJiYgIXJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBpcyBcInByaXZhdGVcIiBmcm9tIHVzZXJzIGJ1dCBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlXG4gICAgICAgIGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSAmJiBlcnJvci5lcnJvciA/IGVycm9yLmVycm9yIDogZXJyb3JcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICByb3V0ZXMsXG4gICAgZGF0YVJvdXRlcyxcbiAgICBzZXJ2ZXJNb2RlLFxuICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgZXJyb3JIYW5kbGVyXG4gIH07XG59XG52YXIgY3JlYXRlUmVxdWVzdEhhbmRsZXIgPSAoYnVpbGQsIG1vZGUpID0+IHtcbiAgbGV0IF9idWlsZDtcbiAgbGV0IHJvdXRlcztcbiAgbGV0IHNlcnZlck1vZGU7XG4gIGxldCBzdGF0aWNIYW5kbGVyO1xuICBsZXQgZXJyb3JIYW5kbGVyO1xuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gcmVxdWVzdEhhbmRsZXIocmVxdWVzdCwgaW5pdGlhbENvbnRleHQpIHtcbiAgICBfYnVpbGQgPSB0eXBlb2YgYnVpbGQgPT09IFwiZnVuY3Rpb25cIiA/IGF3YWl0IGJ1aWxkKCkgOiBidWlsZDtcbiAgICBpZiAodHlwZW9mIGJ1aWxkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGxldCBkZXJpdmVkID0gZGVyaXZlKF9idWlsZCwgbW9kZSk7XG4gICAgICByb3V0ZXMgPSBkZXJpdmVkLnJvdXRlcztcbiAgICAgIHNlcnZlck1vZGUgPSBkZXJpdmVkLnNlcnZlck1vZGU7XG4gICAgICBzdGF0aWNIYW5kbGVyID0gZGVyaXZlZC5zdGF0aWNIYW5kbGVyO1xuICAgICAgZXJyb3JIYW5kbGVyID0gZGVyaXZlZC5lcnJvckhhbmRsZXI7XG4gICAgfSBlbHNlIGlmICghcm91dGVzIHx8ICFzZXJ2ZXJNb2RlIHx8ICFzdGF0aWNIYW5kbGVyIHx8ICFlcnJvckhhbmRsZXIpIHtcbiAgICAgIGxldCBkZXJpdmVkID0gZGVyaXZlKF9idWlsZCwgbW9kZSk7XG4gICAgICByb3V0ZXMgPSBkZXJpdmVkLnJvdXRlcztcbiAgICAgIHNlcnZlck1vZGUgPSBkZXJpdmVkLnNlcnZlck1vZGU7XG4gICAgICBzdGF0aWNIYW5kbGVyID0gZGVyaXZlZC5zdGF0aWNIYW5kbGVyO1xuICAgICAgZXJyb3JIYW5kbGVyID0gZGVyaXZlZC5lcnJvckhhbmRsZXI7XG4gICAgfVxuICAgIGxldCBwYXJhbXMgPSB7fTtcbiAgICBsZXQgbG9hZENvbnRleHQ7XG4gICAgbGV0IGhhbmRsZUVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBpZiAobW9kZSA9PT0gXCJkZXZlbG9wbWVudFwiIC8qIERldmVsb3BtZW50ICovKSB7XG4gICAgICAgIGdldERldlNlcnZlckhvb2tzKCk/LnByb2Nlc3NSZXF1ZXN0RXJyb3I/LihlcnJvcik7XG4gICAgICB9XG4gICAgICBlcnJvckhhbmRsZXIoZXJyb3IsIHtcbiAgICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoX2J1aWxkLmZ1dHVyZS51bnN0YWJsZV9taWRkbGV3YXJlKSB7XG4gICAgICBpZiAoaW5pdGlhbENvbnRleHQgPT0gbnVsbCkge1xuICAgICAgICBsb2FkQ29udGV4dCA9IG5ldyB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9hZENvbnRleHQgPSBuZXcgdW5zdGFibGVfUm91dGVyQ29udGV4dFByb3ZpZGVyKFxuICAgICAgICAgICAgaW5pdGlhbENvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgYFVuYWJsZSB0byBjcmVhdGUgaW5pdGlhbCBcXGB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXJcXGAgaW5zdGFuY2UuIFBsZWFzZSBjb25maXJtIHlvdSBhcmUgcmV0dXJuaW5nIGFuIGluc3RhbmNlIG9mIFxcYE1hcDx1bnN0YWJsZV9yb3V0ZXJDb250ZXh0LCB1bmtub3duPlxcYCBmcm9tIHlvdXIgXFxgZ2V0TG9hZENvbnRleHRcXGAgZnVuY3Rpb24uXG5cbkVycm9yOiAke2UgaW5zdGFuY2VvZiBFcnJvciA/IGUudG9TdHJpbmcoKSA6IGV9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybiByZXR1cm5MYXN0UmVzb3J0RXJyb3JSZXNwb25zZShlcnJvciwgc2VydmVyTW9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZENvbnRleHQgPSBpbml0aWFsQ29udGV4dCB8fCB7fTtcbiAgICB9XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBub3JtYWxpemVkQmFzZW5hbWUgPSBfYnVpbGQuYmFzZW5hbWUgfHwgXCIvXCI7XG4gICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gdXJsLnBhdGhuYW1lO1xuICAgIGlmIChzdHJpcEJhc2VuYW1lKG5vcm1hbGl6ZWRQYXRoLCBub3JtYWxpemVkQmFzZW5hbWUpID09PSBcIi9fcm9vdC5kYXRhXCIpIHtcbiAgICAgIG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplZEJhc2VuYW1lO1xuICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZFBhdGguZW5kc1dpdGgoXCIuZGF0YVwiKSkge1xuICAgICAgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVkUGF0aC5yZXBsYWNlKC9cXC5kYXRhJC8sIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoc3RyaXBCYXNlbmFtZShub3JtYWxpemVkUGF0aCwgbm9ybWFsaXplZEJhc2VuYW1lKSAhPT0gXCIvXCIgJiYgbm9ybWFsaXplZFBhdGguZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZWRQYXRoLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgbGV0IGlzU3BhTW9kZSA9IGdldEJ1aWxkVGltZUhlYWRlcihyZXF1ZXN0LCBcIlgtUmVhY3QtUm91dGVyLVNQQS1Nb2RlXCIpID09PSBcInllc1wiO1xuICAgIGlmICghX2J1aWxkLnNzcikge1xuICAgICAgaWYgKF9idWlsZC5wcmVyZW5kZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlzU3BhTW9kZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCFfYnVpbGQucHJlcmVuZGVyLmluY2x1ZGVzKG5vcm1hbGl6ZWRQYXRoKSAmJiAhX2J1aWxkLnByZXJlbmRlci5pbmNsdWRlcyhub3JtYWxpemVkUGF0aCArIFwiL1wiKSkge1xuICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLmRhdGFcIikpIHtcbiAgICAgICAgICBlcnJvckhhbmRsZXIoXG4gICAgICAgICAgICBuZXcgRXJyb3JSZXNwb25zZUltcGwoXG4gICAgICAgICAgICAgIDQwNCxcbiAgICAgICAgICAgICAgXCJOb3QgRm91bmRcIixcbiAgICAgICAgICAgICAgYFJlZnVzaW5nIHRvIFNTUiB0aGUgcGF0aCBcXGAke25vcm1hbGl6ZWRQYXRofVxcYCBiZWNhdXNlIFxcYHNzcjpmYWxzZVxcYCBpcyBzZXQgYW5kIHRoZSBwYXRoIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgXFxgcHJlcmVuZGVyXFxgIGNvbmZpZywgc28gaW4gcHJvZHVjdGlvbiB0aGUgcGF0aCB3aWxsIGJlIGEgNDA0LmBcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXCJOb3QgRm91bmRcIiwge1xuICAgICAgICAgICAgc3RhdHVzOiA0MDQsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNTcGFNb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWFuaWZlc3RVcmwgPSBnZXRNYW5pZmVzdFBhdGgoXG4gICAgICBfYnVpbGQucm91dGVEaXNjb3ZlcnkubWFuaWZlc3RQYXRoLFxuICAgICAgbm9ybWFsaXplZEJhc2VuYW1lXG4gICAgKTtcbiAgICBpZiAodXJsLnBhdGhuYW1lID09PSBtYW5pZmVzdFVybCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IGhhbmRsZU1hbmlmZXN0UmVxdWVzdChfYnVpbGQsIHJvdXRlcywgdXJsKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXCJVbmtub3duIFNlcnZlciBFcnJvclwiLCB7IHN0YXR1czogNTAwIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoU2VydmVyUm91dGVzKHJvdXRlcywgbm9ybWFsaXplZFBhdGgsIF9idWlsZC5iYXNlbmFtZSk7XG4gICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHBhcmFtcywgbWF0Y2hlc1swXS5wYXJhbXMpO1xuICAgIH1cbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgaWYgKHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5kYXRhXCIpKSB7XG4gICAgICBsZXQgaGFuZGxlclVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgaGFuZGxlclVybC5wYXRobmFtZSA9IG5vcm1hbGl6ZWRQYXRoO1xuICAgICAgbGV0IHNpbmdsZUZldGNoTWF0Y2hlcyA9IG1hdGNoU2VydmVyUm91dGVzKFxuICAgICAgICByb3V0ZXMsXG4gICAgICAgIGhhbmRsZXJVcmwucGF0aG5hbWUsXG4gICAgICAgIF9idWlsZC5iYXNlbmFtZVxuICAgICAgKTtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlU2luZ2xlRmV0Y2hSZXF1ZXN0KFxuICAgICAgICBzZXJ2ZXJNb2RlLFxuICAgICAgICBfYnVpbGQsXG4gICAgICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGhhbmRsZXJVcmwsXG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBoYW5kbGVFcnJvclxuICAgICAgKTtcbiAgICAgIGlmIChfYnVpbGQuZW50cnkubW9kdWxlLmhhbmRsZURhdGFSZXF1ZXN0KSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgX2J1aWxkLmVudHJ5Lm1vZHVsZS5oYW5kbGVEYXRhUmVxdWVzdChyZXNwb25zZSwge1xuICAgICAgICAgIGNvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgICAgIHBhcmFtczogc2luZ2xlRmV0Y2hNYXRjaGVzID8gc2luZ2xlRmV0Y2hNYXRjaGVzWzBdLnBhcmFtcyA6IHt9LFxuICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGdldFNpbmdsZUZldGNoUmVkaXJlY3QoXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgX2J1aWxkLmJhc2VuYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgW1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2xdOiByZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L3gtc2NyaXB0XCIpO1xuICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXG4gICAgICAgICAgICBlbmNvZGVWaWFUdXJib1N0cmVhbShcbiAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICByZXF1ZXN0LnNpZ25hbCxcbiAgICAgICAgICAgICAgX2J1aWxkLmVudHJ5Lm1vZHVsZS5zdHJlYW1UaW1lb3V0LFxuICAgICAgICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0dXM6IFNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVMsXG4gICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTcGFNb2RlICYmIG1hdGNoZXMgJiYgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLm1vZHVsZS5kZWZhdWx0ID09IG51bGwgJiYgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLm1vZHVsZS5FcnJvckJvdW5kYXJ5ID09IG51bGwpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlUmVzb3VyY2VSZXF1ZXN0KFxuICAgICAgICBzZXJ2ZXJNb2RlLFxuICAgICAgICBfYnVpbGQsXG4gICAgICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgICAgIG1hdGNoZXMuc2xpY2UoLTEpWzBdLnJvdXRlLmlkLFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgaGFuZGxlRXJyb3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB7IHBhdGhuYW1lIH0gPSB1cmw7XG4gICAgICBsZXQgY3JpdGljYWxDc3MgPSB2b2lkIDA7XG4gICAgICBpZiAoX2J1aWxkLnVuc3RhYmxlX2dldENyaXRpY2FsQ3NzKSB7XG4gICAgICAgIGNyaXRpY2FsQ3NzID0gYXdhaXQgX2J1aWxkLnVuc3RhYmxlX2dldENyaXRpY2FsQ3NzKHsgcGF0aG5hbWUgfSk7XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiZGV2ZWxvcG1lbnRcIiAvKiBEZXZlbG9wbWVudCAqLyAmJiBnZXREZXZTZXJ2ZXJIb29rcygpPy5nZXRDcml0aWNhbENzcykge1xuICAgICAgICBjcml0aWNhbENzcyA9IGF3YWl0IGdldERldlNlcnZlckhvb2tzKCk/LmdldENyaXRpY2FsQ3NzPy4ocGF0aG5hbWUpO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVEb2N1bWVudFJlcXVlc3QoXG4gICAgICAgIHNlcnZlck1vZGUsXG4gICAgICAgIF9idWlsZCxcbiAgICAgICAgc3RhdGljSGFuZGxlcixcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgIGhhbmRsZUVycm9yLFxuICAgICAgICBpc1NwYU1vZGUsXG4gICAgICAgIGNyaXRpY2FsQ3NzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFwiSEVBRFwiKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH07XG59O1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlTWFuaWZlc3RSZXF1ZXN0KGJ1aWxkLCByb3V0ZXMsIHVybCkge1xuICBpZiAoYnVpbGQuYXNzZXRzLnZlcnNpb24gIT09IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidmVyc2lvblwiKSkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgc3RhdHVzOiAyMDQsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiWC1SZW1peC1SZWxvYWQtRG9jdW1lbnRcIjogXCJ0cnVlXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXQgcGF0Y2hlcyA9IHt9O1xuICBpZiAodXJsLnNlYXJjaFBhcmFtcy5oYXMoXCJwXCIpKSB7XG4gICAgbGV0IHBhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcInBcIikuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIHBhdGggPSBgLyR7cGF0aH1gO1xuICAgICAgfVxuICAgICAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIikuc2xpY2UoMSk7XG4gICAgICBzZWdtZW50cy5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICAgIGxldCBwYXJ0aWFsUGF0aCA9IHNlZ21lbnRzLnNsaWNlKDAsIGkgKyAxKS5qb2luKFwiL1wiKTtcbiAgICAgICAgcGF0aHMuYWRkKGAvJHtwYXJ0aWFsUGF0aH1gKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGZvciAobGV0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGxldCBtYXRjaGVzID0gbWF0Y2hTZXJ2ZXJSb3V0ZXMocm91dGVzLCBwYXRoLCBidWlsZC5iYXNlbmFtZSk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgbGV0IHJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICAgICAgICBsZXQgcm91dGUgPSBidWlsZC5hc3NldHMucm91dGVzW3JvdXRlSWRdO1xuICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgcGF0Y2hlc1tyb3V0ZUlkXSA9IHJvdXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmVzcG9uc2UuanNvbihwYXRjaGVzLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ2FjaGUtQ29udHJvbFwiOiBcInB1YmxpYywgbWF4LWFnZT0zMTUzNjAwMCwgaW1tdXRhYmxlXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IFJlc3BvbnNlKFwiSW52YWxpZCBSZXF1ZXN0XCIsIHsgc3RhdHVzOiA0MDAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVTaW5nbGVGZXRjaFJlcXVlc3Qoc2VydmVyTW9kZSwgYnVpbGQsIHN0YXRpY0hhbmRsZXIsIHJlcXVlc3QsIGhhbmRsZXJVcmwsIGxvYWRDb250ZXh0LCBoYW5kbGVFcnJvcikge1xuICBsZXQgcmVzcG9uc2UgPSByZXF1ZXN0Lm1ldGhvZCAhPT0gXCJHRVRcIiA/IGF3YWl0IHNpbmdsZUZldGNoQWN0aW9uKFxuICAgIGJ1aWxkLFxuICAgIHNlcnZlck1vZGUsXG4gICAgc3RhdGljSGFuZGxlcixcbiAgICByZXF1ZXN0LFxuICAgIGhhbmRsZXJVcmwsXG4gICAgbG9hZENvbnRleHQsXG4gICAgaGFuZGxlRXJyb3JcbiAgKSA6IGF3YWl0IHNpbmdsZUZldGNoTG9hZGVycyhcbiAgICBidWlsZCxcbiAgICBzZXJ2ZXJNb2RlLFxuICAgIHN0YXRpY0hhbmRsZXIsXG4gICAgcmVxdWVzdCxcbiAgICBoYW5kbGVyVXJsLFxuICAgIGxvYWRDb250ZXh0LFxuICAgIGhhbmRsZUVycm9yXG4gICk7XG4gIHJldHVybiByZXNwb25zZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZURvY3VtZW50UmVxdWVzdChzZXJ2ZXJNb2RlLCBidWlsZCwgc3RhdGljSGFuZGxlciwgcmVxdWVzdCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yLCBpc1NwYU1vZGUsIGNyaXRpY2FsQ3NzKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgc3RhdGljSGFuZGxlci5xdWVyeShyZXF1ZXN0LCB7XG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICB1bnN0YWJsZV9yZXNwb25kOiBidWlsZC5mdXR1cmUudW5zdGFibGVfbWlkZGxld2FyZSA/IChjdHgpID0+IHJlbmRlckh0bWwoY3R4LCBpc1NwYU1vZGUpIDogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIGlzUmVzcG9uc2UocmVzcG9uc2UpID8gcmVzcG9uc2UgOiByZW5kZXJIdG1sKHJlc3BvbnNlLCBpc1NwYU1vZGUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVuZGVySHRtbChjb250ZXh0LCBpc1NwYU1vZGUyKSB7XG4gICAgaWYgKGlzUmVzcG9uc2UoY29udGV4dCkpIHtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBsZXQgaGVhZGVycyA9IGdldERvY3VtZW50SGVhZGVycyhidWlsZCwgY29udGV4dCk7XG4gICAgaWYgKFNFUlZFUl9OT19CT0RZX1NUQVRVU19DT0RFUy5oYXMoY29udGV4dC5zdGF0dXNDb2RlKSkge1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogY29udGV4dC5zdGF0dXNDb2RlLCBoZWFkZXJzIH0pO1xuICAgIH1cbiAgICBpZiAoY29udGV4dC5lcnJvcnMpIHtcbiAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5lcnJvcnMpLmZvckVhY2goKGVycikgPT4ge1xuICAgICAgICBpZiAoIWlzUm91dGVFcnJvclJlc3BvbnNlKGVycikgfHwgZXJyLmVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gICAgbGV0IHN0YXRlID0ge1xuICAgICAgbG9hZGVyRGF0YTogY29udGV4dC5sb2FkZXJEYXRhLFxuICAgICAgYWN0aW9uRGF0YTogY29udGV4dC5hY3Rpb25EYXRhLFxuICAgICAgZXJyb3JzOiBzZXJpYWxpemVFcnJvcnMyKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKVxuICAgIH07XG4gICAgbGV0IGJhc2VTZXJ2ZXJIYW5kb2ZmID0ge1xuICAgICAgYmFzZW5hbWU6IGJ1aWxkLmJhc2VuYW1lLFxuICAgICAgZnV0dXJlOiBidWlsZC5mdXR1cmUsXG4gICAgICByb3V0ZURpc2NvdmVyeTogYnVpbGQucm91dGVEaXNjb3ZlcnksXG4gICAgICBzc3I6IGJ1aWxkLnNzcixcbiAgICAgIGlzU3BhTW9kZTogaXNTcGFNb2RlMlxuICAgIH07XG4gICAgbGV0IGVudHJ5Q29udGV4dCA9IHtcbiAgICAgIG1hbmlmZXN0OiBidWlsZC5hc3NldHMsXG4gICAgICByb3V0ZU1vZHVsZXM6IGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzKGJ1aWxkLnJvdXRlcyksXG4gICAgICBzdGF0aWNIYW5kbGVyQ29udGV4dDogY29udGV4dCxcbiAgICAgIGNyaXRpY2FsQ3NzLFxuICAgICAgc2VydmVySGFuZG9mZlN0cmluZzogY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyh7XG4gICAgICAgIC4uLmJhc2VTZXJ2ZXJIYW5kb2ZmLFxuICAgICAgICBjcml0aWNhbENzc1xuICAgICAgfSksXG4gICAgICBzZXJ2ZXJIYW5kb2ZmU3RyZWFtOiBlbmNvZGVWaWFUdXJib1N0cmVhbShcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICBidWlsZC5lbnRyeS5tb2R1bGUuc3RyZWFtVGltZW91dCxcbiAgICAgICAgc2VydmVyTW9kZVxuICAgICAgKSxcbiAgICAgIHJlbmRlck1ldGE6IHt9LFxuICAgICAgZnV0dXJlOiBidWlsZC5mdXR1cmUsXG4gICAgICBzc3I6IGJ1aWxkLnNzcixcbiAgICAgIHJvdXRlRGlzY292ZXJ5OiBidWlsZC5yb3V0ZURpc2NvdmVyeSxcbiAgICAgIGlzU3BhTW9kZTogaXNTcGFNb2RlMixcbiAgICAgIHNlcmlhbGl6ZUVycm9yOiAoZXJyKSA9PiBzZXJpYWxpemVFcnJvcihlcnIsIHNlcnZlck1vZGUpXG4gICAgfTtcbiAgICBsZXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0RnVuY3Rpb24gPSBidWlsZC5lbnRyeS5tb2R1bGUuZGVmYXVsdDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZURvY3VtZW50UmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjb250ZXh0LnN0YXR1c0NvZGUsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGVudHJ5Q29udGV4dCxcbiAgICAgICAgbG9hZENvbnRleHRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgIGxldCBlcnJvckZvclNlY29uZFJlbmRlciA9IGVycm9yO1xuICAgICAgaWYgKGlzUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGRhdGEyID0gYXdhaXQgdW53cmFwUmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICAgIGVycm9yRm9yU2Vjb25kUmVuZGVyID0gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICAgICAgZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgICAgZXJyb3Iuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGRhdGEyXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250ZXh0ID0gZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvcihcbiAgICAgICAgc3RhdGljSGFuZGxlci5kYXRhUm91dGVzLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBlcnJvckZvclNlY29uZFJlbmRlclxuICAgICAgKTtcbiAgICAgIGlmIChjb250ZXh0LmVycm9ycykge1xuICAgICAgICBjb250ZXh0LmVycm9ycyA9IHNhbml0aXplRXJyb3JzKGNvbnRleHQuZXJyb3JzLCBzZXJ2ZXJNb2RlKTtcbiAgICAgIH1cbiAgICAgIGxldCBzdGF0ZTIgPSB7XG4gICAgICAgIGxvYWRlckRhdGE6IGNvbnRleHQubG9hZGVyRGF0YSxcbiAgICAgICAgYWN0aW9uRGF0YTogY29udGV4dC5hY3Rpb25EYXRhLFxuICAgICAgICBlcnJvcnM6IHNlcmlhbGl6ZUVycm9yczIoY29udGV4dC5lcnJvcnMsIHNlcnZlck1vZGUpXG4gICAgICB9O1xuICAgICAgZW50cnlDb250ZXh0ID0ge1xuICAgICAgICAuLi5lbnRyeUNvbnRleHQsXG4gICAgICAgIHN0YXRpY0hhbmRsZXJDb250ZXh0OiBjb250ZXh0LFxuICAgICAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nOiBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nKGJhc2VTZXJ2ZXJIYW5kb2ZmKSxcbiAgICAgICAgc2VydmVySGFuZG9mZlN0cmVhbTogZW5jb2RlVmlhVHVyYm9TdHJlYW0oXG4gICAgICAgICAgc3RhdGUyLFxuICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLFxuICAgICAgICAgIGJ1aWxkLmVudHJ5Lm1vZHVsZS5zdHJlYW1UaW1lb3V0LFxuICAgICAgICAgIHNlcnZlck1vZGVcbiAgICAgICAgKSxcbiAgICAgICAgcmVuZGVyTWV0YToge31cbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBjb250ZXh0LnN0YXR1c0NvZGUsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBlbnRyeUNvbnRleHQsXG4gICAgICAgICAgbG9hZENvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnJvcjIpO1xuICAgICAgICByZXR1cm4gcmV0dXJuTGFzdFJlc29ydEVycm9yUmVzcG9uc2UoZXJyb3IyLCBzZXJ2ZXJNb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlc291cmNlUmVxdWVzdChzZXJ2ZXJNb2RlLCBidWlsZCwgc3RhdGljSGFuZGxlciwgcm91dGVJZCwgcmVxdWVzdCwgbG9hZENvbnRleHQsIGhhbmRsZUVycm9yKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgc3RhdGljSGFuZGxlci5xdWVyeVJvdXRlKHJlcXVlc3QsIHtcbiAgICAgIHJvdXRlSWQsXG4gICAgICByZXF1ZXN0Q29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICB1bnN0YWJsZV9yZXNwb25kOiBidWlsZC5mdXR1cmUudW5zdGFibGVfbWlkZGxld2FyZSA/IChjdHgpID0+IGN0eCA6IHZvaWQgMFxuICAgIH0pO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc3BvbnNlLmpzb24ocmVzcG9uc2UpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgZXJyb3IuaGVhZGVycy5zZXQoXCJYLVJlbWl4LUNhdGNoXCIsIFwieWVzXCIpO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBpZiAoaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9yUmVzcG9uc2VUb0pzb24oZXJyb3IsIHNlcnZlck1vZGUpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlID09PSBcIkV4cGVjdGVkIGEgcmVzcG9uc2UgZnJvbSBxdWVyeVJvdXRlXCIpIHtcbiAgICAgIGxldCBuZXdFcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFJlc3BvbnNlIHRvIGJlIHJldHVybmVkIGZyb20gcmVzb3VyY2Ugcm91dGUgaGFuZGxlclwiXG4gICAgICApO1xuICAgICAgaGFuZGxlRXJyb3IobmV3RXJyb3IpO1xuICAgICAgcmV0dXJuIHJldHVybkxhc3RSZXNvcnRFcnJvclJlc3BvbnNlKG5ld0Vycm9yLCBzZXJ2ZXJNb2RlKTtcbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiByZXR1cm5MYXN0UmVzb3J0RXJyb3JSZXNwb25zZShlcnJvciwgc2VydmVyTW9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yUmVzcG9uc2VUb0pzb24oZXJyb3JSZXNwb25zZSwgc2VydmVyTW9kZSkge1xuICByZXR1cm4gUmVzcG9uc2UuanNvbihcbiAgICBzZXJpYWxpemVFcnJvcihcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBpcyBcInByaXZhdGVcIiBmcm9tIHVzZXJzIGJ1dCBpbnRlbmRlZCBmb3IgaW50ZXJuYWwgdXNlXG4gICAgICBlcnJvclJlc3BvbnNlLmVycm9yIHx8IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCIpLFxuICAgICAgc2VydmVyTW9kZVxuICAgICksXG4gICAge1xuICAgICAgc3RhdHVzOiBlcnJvclJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IGVycm9yUmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJYLVJlbWl4LUVycm9yXCI6IFwieWVzXCJcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiByZXR1cm5MYXN0UmVzb3J0RXJyb3JSZXNwb25zZShlcnJvciwgc2VydmVyTW9kZSkge1xuICBsZXQgbWVzc2FnZSA9IFwiVW5leHBlY3RlZCBTZXJ2ZXIgRXJyb3JcIjtcbiAgaWYgKHNlcnZlck1vZGUgIT09IFwicHJvZHVjdGlvblwiIC8qIFByb2R1Y3Rpb24gKi8pIHtcbiAgICBtZXNzYWdlICs9IGBcblxuJHtTdHJpbmcoZXJyb3IpfWA7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShtZXNzYWdlLCB7XG4gICAgc3RhdHVzOiA1MDAsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCJcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdW53cmFwUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgbGV0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gIHJldHVybiBjb250ZW50VHlwZSAmJiAvXFxiYXBwbGljYXRpb25cXC9qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSA/IHJlc3BvbnNlLmJvZHkgPT0gbnVsbCA/IG51bGwgOiByZXNwb25zZS5qc29uKCkgOiByZXNwb25zZS50ZXh0KCk7XG59XG5cbi8vIGxpYi9zZXJ2ZXItcnVudGltZS9zZXNzaW9ucy50c1xuZnVuY3Rpb24gZmxhc2gobmFtZSkge1xuICByZXR1cm4gYF9fZmxhc2hfJHtuYW1lfV9fYDtcbn1cbnZhciBjcmVhdGVTZXNzaW9uID0gKGluaXRpYWxEYXRhID0ge30sIGlkID0gXCJcIikgPT4ge1xuICBsZXQgbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhpbml0aWFsRGF0YSkpO1xuICByZXR1cm4ge1xuICAgIGdldCBpZCgpIHtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuICAgIGdldCBkYXRhKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhtYXApO1xuICAgIH0sXG4gICAgaGFzKG5hbWUpIHtcbiAgICAgIHJldHVybiBtYXAuaGFzKG5hbWUpIHx8IG1hcC5oYXMoZmxhc2gobmFtZSkpO1xuICAgIH0sXG4gICAgZ2V0KG5hbWUpIHtcbiAgICAgIGlmIChtYXAuaGFzKG5hbWUpKSByZXR1cm4gbWFwLmdldChuYW1lKTtcbiAgICAgIGxldCBmbGFzaE5hbWUgPSBmbGFzaChuYW1lKTtcbiAgICAgIGlmIChtYXAuaGFzKGZsYXNoTmFtZSkpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gbWFwLmdldChmbGFzaE5hbWUpO1xuICAgICAgICBtYXAuZGVsZXRlKGZsYXNoTmFtZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSxcbiAgICBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICAgIG1hcC5zZXQobmFtZSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZmxhc2gobmFtZSwgdmFsdWUpIHtcbiAgICAgIG1hcC5zZXQoZmxhc2gobmFtZSksIHZhbHVlKTtcbiAgICB9LFxuICAgIHVuc2V0KG5hbWUpIHtcbiAgICAgIG1hcC5kZWxldGUobmFtZSk7XG4gICAgfVxuICB9O1xufTtcbnZhciBpc1Nlc3Npb24gPSAob2JqZWN0KSA9PiB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LmlkID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvYmplY3QuZGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygb2JqZWN0LmhhcyA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmplY3QuZ2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC5zZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqZWN0LmZsYXNoID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iamVjdC51bnNldCA9PT0gXCJmdW5jdGlvblwiO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVNlc3Npb25TdG9yYWdlKHtcbiAgY29va2llOiBjb29raWVBcmcsXG4gIGNyZWF0ZURhdGEsXG4gIHJlYWREYXRhLFxuICB1cGRhdGVEYXRhLFxuICBkZWxldGVEYXRhXG59KSB7XG4gIGxldCBjb29raWUgPSBpc0Nvb2tpZShjb29raWVBcmcpID8gY29va2llQXJnIDogY3JlYXRlQ29va2llKGNvb2tpZUFyZz8ubmFtZSB8fCBcIl9fc2Vzc2lvblwiLCBjb29raWVBcmcpO1xuICB3YXJuT25jZUFib3V0U2lnbmluZ1Nlc3Npb25Db29raWUoY29va2llKTtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBnZXRTZXNzaW9uKGNvb2tpZUhlYWRlciwgb3B0aW9ucykge1xuICAgICAgbGV0IGlkID0gY29va2llSGVhZGVyICYmIGF3YWl0IGNvb2tpZS5wYXJzZShjb29raWVIZWFkZXIsIG9wdGlvbnMpO1xuICAgICAgbGV0IGRhdGEyID0gaWQgJiYgYXdhaXQgcmVhZERhdGEoaWQpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVNlc3Npb24oZGF0YTIgfHwge30sIGlkIHx8IFwiXCIpO1xuICAgIH0sXG4gICAgYXN5bmMgY29tbWl0U2Vzc2lvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgICBsZXQgeyBpZCwgZGF0YTogZGF0YTIgfSA9IHNlc3Npb247XG4gICAgICBsZXQgZXhwaXJlcyA9IG9wdGlvbnM/Lm1heEFnZSAhPSBudWxsID8gbmV3IERhdGUoRGF0ZS5ub3coKSArIG9wdGlvbnMubWF4QWdlICogMWUzKSA6IG9wdGlvbnM/LmV4cGlyZXMgIT0gbnVsbCA/IG9wdGlvbnMuZXhwaXJlcyA6IGNvb2tpZS5leHBpcmVzO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGF3YWl0IHVwZGF0ZURhdGEoaWQsIGRhdGEyLCBleHBpcmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkID0gYXdhaXQgY3JlYXRlRGF0YShkYXRhMiwgZXhwaXJlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29va2llLnNlcmlhbGl6ZShpZCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBkZXN0cm95U2Vzc2lvbihzZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgICBhd2FpdCBkZWxldGVEYXRhKHNlc3Npb24uaWQpO1xuICAgICAgcmV0dXJuIGNvb2tpZS5zZXJpYWxpemUoXCJcIiwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBtYXhBZ2U6IHZvaWQgMCxcbiAgICAgICAgZXhwaXJlczogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB3YXJuT25jZUFib3V0U2lnbmluZ1Nlc3Npb25Db29raWUoY29va2llKSB7XG4gIHdhcm5PbmNlKFxuICAgIGNvb2tpZS5pc1NpZ25lZCxcbiAgICBgVGhlIFwiJHtjb29raWUubmFtZX1cIiBjb29raWUgaXMgbm90IHNpZ25lZCwgYnV0IHNlc3Npb24gY29va2llcyBzaG91bGQgYmUgc2lnbmVkIHRvIHByZXZlbnQgdGFtcGVyaW5nIG9uIHRoZSBjbGllbnQgYmVmb3JlIHRoZXkgYXJlIHNlbnQgYmFjayB0byB0aGUgc2VydmVyLiBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZXhwbGFuYXRpb24vc2Vzc2lvbnMtYW5kLWNvb2tpZXMjc2lnbmluZy1jb29raWVzIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgKTtcbn1cblxuLy8gbGliL3NlcnZlci1ydW50aW1lL3Nlc3Npb25zL2Nvb2tpZVN0b3JhZ2UudHNcbmZ1bmN0aW9uIGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlKHsgY29va2llOiBjb29raWVBcmcgfSA9IHt9KSB7XG4gIGxldCBjb29raWUgPSBpc0Nvb2tpZShjb29raWVBcmcpID8gY29va2llQXJnIDogY3JlYXRlQ29va2llKGNvb2tpZUFyZz8ubmFtZSB8fCBcIl9fc2Vzc2lvblwiLCBjb29raWVBcmcpO1xuICB3YXJuT25jZUFib3V0U2lnbmluZ1Nlc3Npb25Db29raWUoY29va2llKTtcbiAgcmV0dXJuIHtcbiAgICBhc3luYyBnZXRTZXNzaW9uKGNvb2tpZUhlYWRlciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNlc3Npb24oXG4gICAgICAgIGNvb2tpZUhlYWRlciAmJiBhd2FpdCBjb29raWUucGFyc2UoY29va2llSGVhZGVyLCBvcHRpb25zKSB8fCB7fVxuICAgICAgKTtcbiAgICB9LFxuICAgIGFzeW5jIGNvbW1pdFNlc3Npb24oc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgbGV0IHNlcmlhbGl6ZWRDb29raWUgPSBhd2FpdCBjb29raWUuc2VyaWFsaXplKHNlc3Npb24uZGF0YSwgb3B0aW9ucyk7XG4gICAgICBpZiAoc2VyaWFsaXplZENvb2tpZS5sZW5ndGggPiA0MDk2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkNvb2tpZSBsZW5ndGggd2lsbCBleGNlZWQgYnJvd3NlciBtYXhpbXVtLiBMZW5ndGg6IFwiICsgc2VyaWFsaXplZENvb2tpZS5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpYWxpemVkQ29va2llO1xuICAgIH0sXG4gICAgYXN5bmMgZGVzdHJveVNlc3Npb24oX3Nlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBjb29raWUuc2VyaWFsaXplKFwiXCIsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbWF4QWdlOiB2b2lkIDAsXG4gICAgICAgIGV4cGlyZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgwKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBsaWIvc2VydmVyLXJ1bnRpbWUvc2Vzc2lvbnMvbWVtb3J5U3RvcmFnZS50c1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UoeyBjb29raWUgfSA9IHt9KSB7XG4gIGxldCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gY3JlYXRlU2Vzc2lvblN0b3JhZ2Uoe1xuICAgIGNvb2tpZSxcbiAgICBhc3luYyBjcmVhdGVEYXRhKGRhdGEyLCBleHBpcmVzKSB7XG4gICAgICBsZXQgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApO1xuICAgICAgbWFwLnNldChpZCwgeyBkYXRhOiBkYXRhMiwgZXhwaXJlcyB9KTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuICAgIGFzeW5jIHJlYWREYXRhKGlkKSB7XG4gICAgICBpZiAobWFwLmhhcyhpZCkpIHtcbiAgICAgICAgbGV0IHsgZGF0YTogZGF0YTIsIGV4cGlyZXMgfSA9IG1hcC5nZXQoaWQpO1xuICAgICAgICBpZiAoIWV4cGlyZXMgfHwgZXhwaXJlcyA+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBpcmVzKSBtYXAuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgYXN5bmMgdXBkYXRlRGF0YShpZCwgZGF0YTIsIGV4cGlyZXMpIHtcbiAgICAgIG1hcC5zZXQoaWQsIHsgZGF0YTogZGF0YTIsIGV4cGlyZXMgfSk7XG4gICAgfSxcbiAgICBhc3luYyBkZWxldGVEYXRhKGlkKSB7XG4gICAgICBtYXAuZGVsZXRlKGlkKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBsaWIvaHJlZi50c1xuZnVuY3Rpb24gaHJlZihwYXRoLCAuLi5hcmdzKSB7XG4gIGxldCBwYXJhbXMgPSBhcmdzWzBdO1xuICByZXR1cm4gcGF0aC5zcGxpdChcIi9cIikubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiKlwiKSB7XG4gICAgICByZXR1cm4gcGFyYW1zID8gcGFyYW1zW1wiKlwiXSA6IHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eOihbXFx3LV0rKShcXD8pPy8pO1xuICAgIGlmICghbWF0Y2gpIHJldHVybiBzZWdtZW50O1xuICAgIGNvbnN0IHBhcmFtID0gbWF0Y2hbMV07XG4gICAgY29uc3QgdmFsdWUgPSBwYXJhbXMgPyBwYXJhbXNbcGFyYW1dIDogdm9pZCAwO1xuICAgIGNvbnN0IGlzUmVxdWlyZWQgPSBtYXRjaFsyXSA9PT0gdm9pZCAwO1xuICAgIGlmIChpc1JlcXVpcmVkICYmIHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgUGF0aCAnJHtwYXRofScgcmVxdWlyZXMgcGFyYW0gJyR7cGFyYW19JyBidXQgaXQgd2FzIG5vdCBwcm92aWRlZGBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSkuZmlsdGVyKChzZWdtZW50KSA9PiBzZWdtZW50ICE9PSB2b2lkIDApLmpvaW4oXCIvXCIpO1xufVxuXG4vLyBsaWIvZG9tL3Nzci9lcnJvcnMudHNcbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3JzMihlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG4gIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZW50cmllcykge1xuICAgIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJSb3V0ZUVycm9yUmVzcG9uc2VcIikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IEVycm9yUmVzcG9uc2VJbXBsKFxuICAgICAgICB2YWwuc3RhdHVzLFxuICAgICAgICB2YWwuc3RhdHVzVGV4dCxcbiAgICAgICAgdmFsLmRhdGEsXG4gICAgICAgIHZhbC5pbnRlcm5hbCA9PT0gdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIkVycm9yXCIpIHtcbiAgICAgIGlmICh2YWwuX19zdWJUeXBlKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gd2luZG93W3ZhbC5fX3N1YlR5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWwubWVzc2FnZSk7XG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IHZhbC5zdGFjaztcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXJpYWxpemVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5zdGFjayA9IHZhbC5zdGFjaztcbiAgICAgICAgc2VyaWFsaXplZFtrZXldID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbi8vIGxpYi9kb20vc3NyL2h5ZHJhdGlvbi50c3hcbmZ1bmN0aW9uIGdldEh5ZHJhdGlvbkRhdGEoc3RhdGUsIHJvdXRlcywgZ2V0Um91dGVJbmZvLCBsb2NhdGlvbiwgYmFzZW5hbWUsIGlzU3BhTW9kZSkge1xuICBsZXQgaHlkcmF0aW9uRGF0YSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsb2FkZXJEYXRhOiB7IC4uLnN0YXRlLmxvYWRlckRhdGEgfVxuICB9O1xuICBsZXQgaW5pdGlhbE1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gIGlmIChpbml0aWFsTWF0Y2hlcykge1xuICAgIGZvciAobGV0IG1hdGNoIG9mIGluaXRpYWxNYXRjaGVzKSB7XG4gICAgICBsZXQgcm91dGVJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgICAgbGV0IHJvdXRlSW5mbyA9IGdldFJvdXRlSW5mbyhyb3V0ZUlkKTtcbiAgICAgIGlmIChzaG91bGRIeWRyYXRlUm91dGVMb2FkZXIoXG4gICAgICAgIHJvdXRlSWQsXG4gICAgICAgIHJvdXRlSW5mby5jbGllbnRMb2FkZXIsXG4gICAgICAgIHJvdXRlSW5mby5oYXNMb2FkZXIsXG4gICAgICAgIGlzU3BhTW9kZVxuICAgICAgKSAmJiAocm91dGVJbmZvLmhhc0h5ZHJhdGVGYWxsYmFjayB8fCAhcm91dGVJbmZvLmhhc0xvYWRlcikpIHtcbiAgICAgICAgZGVsZXRlIGh5ZHJhdGlvbkRhdGEubG9hZGVyRGF0YVtyb3V0ZUlkXTtcbiAgICAgIH0gZWxzZSBpZiAoIXJvdXRlSW5mby5oYXNMb2FkZXIpIHtcbiAgICAgICAgaHlkcmF0aW9uRGF0YS5sb2FkZXJEYXRhW3JvdXRlSWRdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGh5ZHJhdGlvbkRhdGE7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQXdhaXQsXG4gIEJyb3dzZXJSb3V0ZXIsXG4gIEZvcm0sXG4gIEhhc2hSb3V0ZXIsXG4gIElETEVfQkxPQ0tFUixcbiAgSURMRV9GRVRDSEVSLFxuICBJRExFX05BVklHQVRJT04sXG4gIExpbmssXG4gIExpbmtzLFxuICBNZW1vcnlSb3V0ZXIsXG4gIE1ldGEsXG4gIE5hdkxpbmssXG4gIE5hdmlnYXRlLFxuICBOYXZpZ2F0aW9uVHlwZSxcbiAgT3V0bGV0LFxuICBQcmVmZXRjaFBhZ2VMaW5rcyxcbiAgUm91dGUsXG4gIFJvdXRlcixcbiAgUm91dGVyUHJvdmlkZXIsXG4gIFJvdXRlcyxcbiAgU2NyaXB0cyxcbiAgU2Nyb2xsUmVzdG9yYXRpb24sXG4gIFNlcnZlclJvdXRlcixcbiAgU3RhdGljUm91dGVyLFxuICBTdGF0aWNSb3V0ZXJQcm92aWRlcixcbiAgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LFxuICBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCxcbiAgVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsLFxuICBVTlNBRkVfRmV0Y2hlcnNDb250ZXh0LFxuICBVTlNBRkVfRnJhbWV3b3JrQ29udGV4dCxcbiAgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LFxuICBVTlNBRkVfUmVtaXhFcnJvckJvdW5kYXJ5LFxuICBVTlNBRkVfUm91dGVDb250ZXh0LFxuICBVTlNBRkVfU2VydmVyTW9kZSxcbiAgVU5TQUZFX1NpbmdsZUZldGNoUmVkaXJlY3RTeW1ib2wsXG4gIFVOU0FGRV9WaWV3VHJhbnNpdGlvbkNvbnRleHQsXG4gIFVOU0FGRV9jcmVhdGVCcm93c2VySGlzdG9yeSxcbiAgVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlcyxcbiAgVU5TQUZFX2NyZWF0ZUNsaWVudFJvdXRlc1dpdGhITVJSZXZhbGlkYXRpb25PcHRPdXQsXG4gIFVOU0FGRV9jcmVhdGVSb3V0ZXIsXG4gIFVOU0FGRV9kZWNvZGVWaWFUdXJib1N0cmVhbSxcbiAgVU5TQUZFX2Rlc2VyaWFsaXplRXJyb3JzLFxuICBVTlNBRkVfZ2V0SHlkcmF0aW9uRGF0YSxcbiAgVU5TQUZFX2dldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24sXG4gIFVOU0FGRV9nZXRUdXJib1N0cmVhbVNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5LFxuICBVTlNBRkVfaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzLFxuICBVTlNBRkVfaW52YXJpYW50LFxuICBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLFxuICBVTlNBRkVfc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyLFxuICBVTlNBRkVfdXNlRm9nT0ZXYXJEaXNjb3ZlcnksXG4gIFVOU0FGRV91c2VTY3JvbGxSZXN0b3JhdGlvbixcbiAgY3JlYXRlQnJvd3NlclJvdXRlcixcbiAgY3JlYXRlQ29va2llLFxuICBjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSxcbiAgY3JlYXRlSGFzaFJvdXRlcixcbiAgY3JlYXRlTWVtb3J5Um91dGVyLFxuICBjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZSxcbiAgY3JlYXRlUGF0aCxcbiAgY3JlYXRlUmVxdWVzdEhhbmRsZXIsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzLFxuICBjcmVhdGVSb3V0ZXNTdHViLFxuICBjcmVhdGVTZWFyY2hQYXJhbXMsXG4gIGNyZWF0ZVNlc3Npb24sXG4gIGNyZWF0ZVNlc3Npb25TdG9yYWdlLFxuICBjcmVhdGVTdGF0aWNIYW5kbGVyLFxuICBjcmVhdGVTdGF0aWNSb3V0ZXIsXG4gIGRhdGEsXG4gIGdlbmVyYXRlUGF0aCxcbiAgaHJlZixcbiAgaXNDb29raWUsXG4gIGlzUm91dGVFcnJvclJlc3BvbnNlLFxuICBpc1Nlc3Npb24sXG4gIG1hdGNoUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIHBhcnNlUGF0aCxcbiAgcmVkaXJlY3QsXG4gIHJlZGlyZWN0RG9jdW1lbnQsXG4gIHJlbmRlck1hdGNoZXMsXG4gIHJlcGxhY2UsXG4gIHJlc29sdmVQYXRoLFxuICB1bnN0YWJsZV9IaXN0b3J5Um91dGVyLFxuICB1bnN0YWJsZV9Sb3V0ZXJDb250ZXh0UHJvdmlkZXIsXG4gIHVuc3RhYmxlX2NyZWF0ZUNvbnRleHQsXG4gIHVuc3RhYmxlX3NldERldlNlcnZlckhvb2tzLFxuICB1bnN0YWJsZV91c2VQcm9tcHQsXG4gIHVzZUFjdGlvbkRhdGEsXG4gIHVzZUFzeW5jRXJyb3IsXG4gIHVzZUFzeW5jVmFsdWUsXG4gIHVzZUJlZm9yZVVubG9hZCxcbiAgdXNlQmxvY2tlcixcbiAgdXNlRmV0Y2hlcixcbiAgdXNlRmV0Y2hlcnMsXG4gIHVzZUZvcm1BY3Rpb24sXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTGlua0NsaWNrSGFuZGxlcixcbiAgdXNlTG9hZGVyRGF0YSxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VNYXRjaGVzLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvbixcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldCxcbiAgdXNlT3V0bGV0Q29udGV4dCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJldmFsaWRhdG9yLFxuICB1c2VSb3V0ZUVycm9yLFxuICB1c2VSb3V0ZUxvYWRlckRhdGEsXG4gIHVzZVJvdXRlcyxcbiAgdXNlU2VhcmNoUGFyYW1zLFxuICB1c2VTdWJtaXQsXG4gIHVzZVZpZXdUcmFuc2l0aW9uU3RhdGVcbn0pO1xuIl0sIm5hbWVzIjpbIl9fY3JlYXRlIiwiT2JqZWN0IiwiY3JlYXRlIiwiX19kZWZQcm9wIiwiZGVmaW5lUHJvcGVydHkiLCJfX2dldE93blByb3BEZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19nZXRPd25Qcm9wTmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiX19nZXRQcm90b09mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fdHlwZUVycm9yIiwibXNnIiwiVHlwZUVycm9yIiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsIl9fY29weVByb3BzIiwidG8iLCJmcm9tIiwiZXhjZXB0IiwiZGVzYyIsImtleSIsImNhbGwiLCJfX3RvRVNNIiwibW9kIiwiaXNOb2RlTW9kZSIsIl9fZXNNb2R1bGUiLCJ2YWx1ZSIsIl9fdG9Db21tb25KUyIsIl9fYWNjZXNzQ2hlY2siLCJvYmoiLCJtZW1iZXIiLCJoYXMiLCJfX3ByaXZhdGVHZXQiLCJnZXR0ZXIiLCJfX3ByaXZhdGVBZGQiLCJXZWFrU2V0IiwiYWRkIiwic2V0IiwicmVhY3Rfcm91dGVyX2V4cG9ydHMiLCJBd2FpdCIsIkJyb3dzZXJSb3V0ZXIiLCJGb3JtIiwiSGFzaFJvdXRlciIsIklETEVfQkxPQ0tFUiIsIklETEVfRkVUQ0hFUiIsIklETEVfTkFWSUdBVElPTiIsIkxpbmsiLCJMaW5rcyIsIk1lbW9yeVJvdXRlciIsIk1ldGEiLCJOYXZMaW5rIiwiTmF2aWdhdGUiLCJOYXZpZ2F0aW9uVHlwZSIsIkFjdGlvbiIsIk91dGxldCIsIlByZWZldGNoUGFnZUxpbmtzIiwiUm91dGUiLCJSb3V0ZXIiLCJSb3V0ZXJQcm92aWRlciIsIlJvdXRlcyIsIlNjcmlwdHMiLCJTY3JvbGxSZXN0b3JhdGlvbiIsIlNlcnZlclJvdXRlciIsIlN0YXRpY1JvdXRlciIsIlN0YXRpY1JvdXRlclByb3ZpZGVyIiwiVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0IiwiRGF0YVJvdXRlckNvbnRleHQiLCJVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsIkRhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJVTlNBRkVfRXJyb3JSZXNwb25zZUltcGwiLCJFcnJvclJlc3BvbnNlSW1wbCIsIlVOU0FGRV9GZXRjaGVyc0NvbnRleHQiLCJGZXRjaGVyc0NvbnRleHQiLCJVTlNBRkVfRnJhbWV3b3JrQ29udGV4dCIsIkZyYW1ld29ya0NvbnRleHQiLCJVTlNBRkVfTG9jYXRpb25Db250ZXh0IiwiTG9jYXRpb25Db250ZXh0IiwiVU5TQUZFX05hdmlnYXRpb25Db250ZXh0IiwiTmF2aWdhdGlvbkNvbnRleHQiLCJVTlNBRkVfUmVtaXhFcnJvckJvdW5kYXJ5IiwiUmVtaXhFcnJvckJvdW5kYXJ5IiwiVU5TQUZFX1JvdXRlQ29udGV4dCIsIlJvdXRlQ29udGV4dCIsIlVOU0FGRV9TZXJ2ZXJNb2RlIiwiU2VydmVyTW9kZSIsIlVOU0FGRV9TaW5nbGVGZXRjaFJlZGlyZWN0U3ltYm9sIiwiU2luZ2xlRmV0Y2hSZWRpcmVjdFN5bWJvbCIsIlVOU0FGRV9WaWV3VHJhbnNpdGlvbkNvbnRleHQiLCJWaWV3VHJhbnNpdGlvbkNvbnRleHQiLCJVTlNBRkVfY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsIlVOU0FGRV9jcmVhdGVDbGllbnRSb3V0ZXMiLCJjcmVhdGVDbGllbnRSb3V0ZXMiLCJVTlNBRkVfY3JlYXRlQ2xpZW50Um91dGVzV2l0aEhNUlJldmFsaWRhdGlvbk9wdE91dCIsImNyZWF0ZUNsaWVudFJvdXRlc1dpdGhITVJSZXZhbGlkYXRpb25PcHRPdXQiLCJVTlNBRkVfY3JlYXRlUm91dGVyIiwiY3JlYXRlUm91dGVyIiwiVU5TQUZFX2RlY29kZVZpYVR1cmJvU3RyZWFtIiwiZGVjb2RlVmlhVHVyYm9TdHJlYW0iLCJVTlNBRkVfZGVzZXJpYWxpemVFcnJvcnMiLCJkZXNlcmlhbGl6ZUVycm9yczIiLCJVTlNBRkVfZ2V0SHlkcmF0aW9uRGF0YSIsImdldEh5ZHJhdGlvbkRhdGEiLCJVTlNBRkVfZ2V0UGF0Y2hSb3V0ZXNPbk5hdmlnYXRpb25GdW5jdGlvbiIsImdldFBhdGNoUm91dGVzT25OYXZpZ2F0aW9uRnVuY3Rpb24iLCJVTlNBRkVfZ2V0VHVyYm9TdHJlYW1TaW5nbGVGZXRjaERhdGFTdHJhdGVneSIsImdldFR1cmJvU3RyZWFtU2luZ2xlRmV0Y2hEYXRhU3RyYXRlZ3kiLCJVTlNBRkVfaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzIiwiaHlkcmF0aW9uUm91dGVQcm9wZXJ0aWVzIiwiVU5TQUZFX2ludmFyaWFudCIsImludmFyaWFudCIsIlVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMiLCJtYXBSb3V0ZVByb3BlcnRpZXMiLCJVTlNBRkVfc2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyIiwic2hvdWxkSHlkcmF0ZVJvdXRlTG9hZGVyIiwiVU5TQUZFX3VzZUZvZ09GV2FyRGlzY292ZXJ5IiwidXNlRm9nT0ZXYXJEaXNjb3ZlcnkiLCJVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24iLCJ1c2VTY3JvbGxSZXN0b3JhdGlvbiIsImNyZWF0ZUJyb3dzZXJSb3V0ZXIiLCJjcmVhdGVDb29raWUiLCJjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSIsImNyZWF0ZUhhc2hSb3V0ZXIiLCJjcmVhdGVNZW1vcnlSb3V0ZXIiLCJjcmVhdGVNZW1vcnlTZXNzaW9uU3RvcmFnZSIsImNyZWF0ZVBhdGgiLCJjcmVhdGVSZXF1ZXN0SGFuZGxlciIsImNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiIsImNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyIsImNyZWF0ZVJvdXRlc1N0dWIiLCJjcmVhdGVTZWFyY2hQYXJhbXMiLCJjcmVhdGVTZXNzaW9uIiwiY3JlYXRlU2Vzc2lvblN0b3JhZ2UiLCJjcmVhdGVTdGF0aWNIYW5kbGVyIiwiY3JlYXRlU3RhdGljSGFuZGxlcjIiLCJjcmVhdGVTdGF0aWNSb3V0ZXIiLCJkYXRhIiwiZ2VuZXJhdGVQYXRoIiwiaHJlZiIsImlzQ29va2llIiwiaXNSb3V0ZUVycm9yUmVzcG9uc2UiLCJpc1Nlc3Npb24iLCJtYXRjaFBhdGgiLCJtYXRjaFJvdXRlcyIsInBhcnNlUGF0aCIsInJlZGlyZWN0IiwicmVkaXJlY3REb2N1bWVudCIsInJlbmRlck1hdGNoZXMiLCJyZXBsYWNlIiwicmVzb2x2ZVBhdGgiLCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyIiwiSGlzdG9yeVJvdXRlciIsInVuc3RhYmxlX1JvdXRlckNvbnRleHRQcm92aWRlciIsInVuc3RhYmxlX2NyZWF0ZUNvbnRleHQiLCJ1bnN0YWJsZV9zZXREZXZTZXJ2ZXJIb29rcyIsInNldERldlNlcnZlckhvb2tzIiwidW5zdGFibGVfdXNlUHJvbXB0IiwidXNlUHJvbXB0IiwidXNlQWN0aW9uRGF0YSIsInVzZUFzeW5jRXJyb3IiLCJ1c2VBc3luY1ZhbHVlIiwidXNlQmVmb3JlVW5sb2FkIiwidXNlQmxvY2tlciIsInVzZUZldGNoZXIiLCJ1c2VGZXRjaGVycyIsInVzZUZvcm1BY3Rpb24iLCJ1c2VIcmVmIiwidXNlSW5Sb3V0ZXJDb250ZXh0IiwidXNlTGlua0NsaWNrSGFuZGxlciIsInVzZUxvYWRlckRhdGEiLCJ1c2VMb2NhdGlvbiIsInVzZU1hdGNoIiwidXNlTWF0Y2hlcyIsInVzZU5hdmlnYXRlIiwidXNlTmF2aWdhdGlvbiIsInVzZU5hdmlnYXRpb25UeXBlIiwidXNlT3V0bGV0IiwidXNlT3V0bGV0Q29udGV4dCIsInVzZVBhcmFtcyIsInVzZVJlc29sdmVkUGF0aCIsInVzZVJldmFsaWRhdG9yIiwidXNlUm91dGVFcnJvciIsInVzZVJvdXRlTG9hZGVyRGF0YSIsInVzZVJvdXRlcyIsInVzZVNlYXJjaFBhcmFtcyIsInVzZVN1Ym1pdCIsInVzZVZpZXdUcmFuc2l0aW9uU3RhdGUiLCJtb2R1bGUiLCJleHBvcnRzIiwiQWN0aW9uMiIsIlBvcFN0YXRlRXZlbnRUeXBlIiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsIm9wdGlvbnMiLCJpbml0aWFsRW50cmllcyIsImluaXRpYWxJbmRleCIsInY1Q29tcGF0IiwiZW50cmllcyIsIm1hcCIsImVudHJ5IiwiaW5kZXgyIiwiY3JlYXRlTWVtb3J5TG9jYXRpb24iLCJzdGF0ZSIsImluZGV4IiwiY2xhbXBJbmRleCIsImxlbmd0aCIsImFjdGlvbiIsImxpc3RlbmVyIiwibiIsIk1hdGgiLCJtaW4iLCJtYXgiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJsb2NhdGlvbiIsImNyZWF0ZUxvY2F0aW9uIiwicGF0aG5hbWUiLCJ3YXJuaW5nIiwiY2hhckF0IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZUhyZWYyIiwiaGlzdG9yeSIsImNyZWF0ZUhyZWYiLCJjcmVhdGVVUkwiLCJVUkwiLCJlbmNvZGVMb2NhdGlvbiIsInBhdGgiLCJzZWFyY2giLCJoYXNoIiwicHVzaCIsIm5leHRMb2NhdGlvbiIsInNwbGljZSIsImRlbHRhIiwiZ28iLCJuZXh0SW5kZXgiLCJsaXN0ZW4iLCJmbiIsImNyZWF0ZUJyb3dzZXJMb2NhdGlvbiIsIndpbmRvdzIiLCJnbG9iYWxIaXN0b3J5IiwidXNyIiwiY3JlYXRlQnJvd3NlckhyZWYiLCJnZXRVcmxCYXNlZEhpc3RvcnkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsImNyZWF0ZUhhc2hMb2NhdGlvbiIsInN1YnN0cmluZyIsInN0YXJ0c1dpdGgiLCJjcmVhdGVIYXNoSHJlZiIsImJhc2UiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmMiIsImdldEF0dHJpYnV0ZSIsInVybCIsImhhc2hJbmRleCIsImluZGV4T2YiLCJzbGljZSIsInZhbGlkYXRlSGFzaExvY2F0aW9uIiwibWVzc2FnZSIsIkVycm9yIiwiY29uZCIsImNvbnNvbGUiLCJ3YXJuIiwiZSIsImNyZWF0ZUtleSIsInJhbmRvbSIsInRvU3RyaW5nIiwiZ2V0SGlzdG9yeVN0YXRlIiwiaWR4IiwiY3VycmVudCIsInBhcnNlZFBhdGgiLCJzZWFyY2hJbmRleCIsImdldExvY2F0aW9uIiwidmFsaWRhdGVMb2NhdGlvbiIsIndpbmRvdyIsImRlZmF1bHRWaWV3IiwiZ2V0SW5kZXgiLCJyZXBsYWNlU3RhdGUiLCJoYW5kbGVQb3AiLCJoaXN0b3J5U3RhdGUiLCJwdXNoU3RhdGUiLCJlcnJvciIsIkRPTUV4Y2VwdGlvbiIsImFzc2lnbiIsInJlcGxhY2UyIiwiY3JlYXRlQnJvd3NlclVSTEltcGwiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImlzQWJzb2x1dGUiLCJvcmlnaW4iLCJkZWZhdWx0VmFsdWUiLCJfbWFwIiwiY29uc3RydWN0b3IiLCJpbml0IiwiTWFwIiwiY29udGV4dCIsIldlYWtNYXAiLCJ1bnN1cHBvcnRlZExhenlSb3V0ZU9iamVjdEtleXMiLCJTZXQiLCJpc1Vuc3VwcG9ydGVkTGF6eVJvdXRlT2JqZWN0S2V5IiwidW5zdXBwb3J0ZWRMYXp5Um91dGVGdW5jdGlvbktleXMiLCJpc1Vuc3VwcG9ydGVkTGF6eVJvdXRlRnVuY3Rpb25LZXkiLCJpc0luZGV4Um91dGUiLCJyb3V0ZSIsImNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMiLCJyb3V0ZXMiLCJtYXBSb3V0ZVByb3BlcnRpZXMyIiwicGFyZW50UGF0aCIsIm1hbmlmZXN0IiwidHJlZVBhdGgiLCJTdHJpbmciLCJpZCIsImpvaW4iLCJjaGlsZHJlbiIsImluZGV4Um91dGUiLCJwYXRoT3JMYXlvdXRSb3V0ZSIsImxvY2F0aW9uQXJnIiwiYmFzZW5hbWUiLCJtYXRjaFJvdXRlc0ltcGwiLCJhbGxvd1BhcnRpYWwiLCJzdHJpcEJhc2VuYW1lIiwiYnJhbmNoZXMiLCJmbGF0dGVuUm91dGVzIiwicmFua1JvdXRlQnJhbmNoZXMiLCJtYXRjaGVzIiwiaSIsImRlY29kZWQiLCJkZWNvZGVQYXRoIiwibWF0Y2hSb3V0ZUJyYW5jaCIsImNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIiwibWF0Y2giLCJsb2FkZXJEYXRhIiwicGFyYW1zIiwiaGFuZGxlIiwicGFyZW50c01ldGEiLCJmbGF0dGVuUm91dGUiLCJyZWxhdGl2ZVBhdGgiLCJtZXRhIiwiY2FzZVNlbnNpdGl2ZSIsImNoaWxkcmVuSW5kZXgiLCJqb2luUGF0aHMiLCJyb3V0ZXNNZXRhIiwiY29uY2F0Iiwic2NvcmUiLCJjb21wdXRlU2NvcmUiLCJmb3JFYWNoIiwiaW5jbHVkZXMiLCJleHBsb2RlZCIsImV4cGxvZGVPcHRpb25hbFNlZ21lbnRzIiwic2VnbWVudHMiLCJzcGxpdCIsImZpcnN0IiwicmVzdCIsImlzT3B0aW9uYWwiLCJlbmRzV2l0aCIsInJlcXVpcmVkIiwicmVzdEV4cGxvZGVkIiwicmVzdWx0Iiwic3VicGF0aCIsInNvcnQiLCJhIiwiYiIsImNvbXBhcmVJbmRleGVzIiwicGFyYW1SZSIsImR5bmFtaWNTZWdtZW50VmFsdWUiLCJpbmRleFJvdXRlVmFsdWUiLCJlbXB0eVNlZ21lbnRWYWx1ZSIsInN0YXRpY1NlZ21lbnRWYWx1ZSIsInNwbGF0UGVuYWx0eSIsImlzU3BsYXQiLCJzIiwiaW5pdGlhbFNjb3JlIiwic29tZSIsImZpbHRlciIsInJlZHVjZSIsInNlZ21lbnQiLCJ0ZXN0Iiwic2libGluZ3MiLCJldmVyeSIsImJyYW5jaCIsIm1hdGNoZWRQYXJhbXMiLCJtYXRjaGVkUGF0aG5hbWUiLCJlbmQiLCJyZW1haW5pbmdQYXRobmFtZSIsInBhdGhuYW1lQmFzZSIsIm5vcm1hbGl6ZVBhdGhuYW1lIiwib3JpZ2luYWxQYXRoIiwicHJlZml4Iiwic3RyaW5naWZ5MiIsInAiLCJhcnJheSIsImlzTGFzdFNlZ21lbnQiLCJzdGFyIiwia2V5TWF0Y2giLCJvcHRpb25hbCIsInBhcmFtIiwicGF0dGVybiIsIm1hdGNoZXIiLCJjb21waWxlZFBhcmFtcyIsImNvbXBpbGVQYXRoIiwiY2FwdHVyZUdyb3VwcyIsIm1lbW8yIiwicGFyYW1OYW1lIiwic3BsYXRWYWx1ZSIsInJlZ2V4cFNvdXJjZSIsIl8iLCJSZWdFeHAiLCJ2IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwidG9Mb3dlckNhc2UiLCJzdGFydEluZGV4IiwibmV4dENoYXIiLCJmcm9tUGF0aG5hbWUiLCJ0b1BhdGhuYW1lIiwicmVzb2x2ZVBhdGhuYW1lIiwibm9ybWFsaXplU2VhcmNoIiwibm9ybWFsaXplSGFzaCIsInJlbGF0aXZlU2VnbWVudHMiLCJwb3AiLCJnZXRJbnZhbGlkUGF0aEVycm9yIiwiY2hhciIsImZpZWxkIiwiZGVzdCIsImdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzIiwiZ2V0UmVzb2x2ZVRvTWF0Y2hlcyIsInBhdGhNYXRjaGVzIiwicmVzb2x2ZVRvIiwidG9BcmciLCJyb3V0ZVBhdGhuYW1lcyIsImxvY2F0aW9uUGF0aG5hbWUiLCJpc1BhdGhSZWxhdGl2ZSIsImlzRW1wdHlQYXRoIiwicm91dGVQYXRobmFtZUluZGV4IiwidG9TZWdtZW50cyIsInNoaWZ0IiwiaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIiwiaGFzQ3VycmVudFRyYWlsaW5nU2xhc2giLCJwYXRocyIsIkRhdGFXaXRoUmVzcG9uc2VJbml0IiwiZGF0YTIiLCJ0eXBlIiwic3RhdHVzIiwicmVzcG9uc2VJbml0IiwiaGVhZGVycyIsIkhlYWRlcnMiLCJSZXNwb25zZSIsInJlc3BvbnNlIiwic3RhdHVzVGV4dCIsImludGVybmFsIiwidmFsaWRNdXRhdGlvbk1ldGhvZHNBcnIiLCJ2YWxpZE11dGF0aW9uTWV0aG9kcyIsInZhbGlkUmVxdWVzdE1ldGhvZHNBcnIiLCJ2YWxpZFJlcXVlc3RNZXRob2RzIiwicmVkaXJlY3RTdGF0dXNDb2RlcyIsInJlZGlyZWN0UHJlc2VydmVNZXRob2RTdGF0dXNDb2RlcyIsImZvcm1NZXRob2QiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtRGF0YSIsImpzb24iLCJ0ZXh0IiwicHJvY2VlZCIsInJlc2V0IiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwiZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcyIsImhhc0Vycm9yQm91bmRhcnkiLCJCb29sZWFuIiwiVFJBTlNJVElPTlNfU1RPUkFHRV9LRVkiLCJSZXNldExvYWRlckRhdGFTeW1ib2wiLCJTeW1ib2wiLCJyb3V0ZXJXaW5kb3ciLCJpc0Jyb3dzZXIyIiwiY3JlYXRlRWxlbWVudCIsImh5ZHJhdGlvblJvdXRlUHJvcGVydGllczIiLCJkYXRhUm91dGVzIiwiaW5GbGlnaHREYXRhUm91dGVzIiwiZGF0YVN0cmF0ZWd5SW1wbCIsImRhdGFTdHJhdGVneSIsImRlZmF1bHREYXRhU3RyYXRlZ3lXaXRoTWlkZGxld2FyZSIsImZ1dHVyZSIsInVuc3RhYmxlX21pZGRsZXdhcmUiLCJ1bmxpc3Rlbkhpc3RvcnkiLCJzdWJzY3JpYmVycyIsInNhdmVkU2Nyb2xsUG9zaXRpb25zMiIsImdldFNjcm9sbFJlc3RvcmF0aW9uS2V5MiIsImdldFNjcm9sbFBvc2l0aW9uIiwiaW5pdGlhbFNjcm9sbFJlc3RvcmVkIiwiaHlkcmF0aW9uRGF0YSIsImluaXRpYWxNYXRjaGVzIiwiaW5pdGlhbE1hdGNoZXNJc0ZPVyIsImluaXRpYWxFcnJvcnMiLCJpbml0aWFsaXplZCIsInBhdGNoUm91dGVzT25OYXZpZ2F0aW9uIiwiZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvciIsImdldFNob3J0Q2lyY3VpdE1hdGNoZXMiLCJmb2dPZldhciIsImNoZWNrRm9nT2ZXYXIiLCJhY3RpdmUiLCJtIiwibGF6eSIsImxvYWRlciIsImVycm9ycyIsImZpbmRJbmRleCIsInNob3VsZExvYWRSb3V0ZU9uSHlkcmF0aW9uIiwicm91dGVyIiwiaGlzdG9yeUFjdGlvbiIsIm5hdmlnYXRpb24iLCJyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJyZXZhbGlkYXRpb24iLCJhY3Rpb25EYXRhIiwiZmV0Y2hlcnMiLCJibG9ja2VycyIsInBlbmRpbmdBY3Rpb24iLCJwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0IiwicGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyIiwicGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCIsImFwcGxpZWRWaWV3VHJhbnNpdGlvbnMiLCJyZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIiLCJpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24iLCJpc1JldmFsaWRhdGlvblJlcXVpcmVkIiwiY2FuY2VsbGVkRmV0Y2hlckxvYWRzIiwiZmV0Y2hDb250cm9sbGVycyIsImluY3JlbWVudGluZ0xvYWRJZCIsInBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkIiwiZmV0Y2hSZWxvYWRJZHMiLCJmZXRjaFJlZGlyZWN0SWRzIiwiZmV0Y2hMb2FkTWF0Y2hlcyIsImFjdGl2ZUZldGNoZXJzIiwiZmV0Y2hlcnNRdWV1ZWRGb3JEZWxldGlvbiIsImJsb2NrZXJGdW5jdGlvbnMiLCJ1bmJsb2NrQmxvY2tlckhpc3RvcnlVcGRhdGUiLCJwZW5kaW5nUmV2YWxpZGF0aW9uRGZkIiwiaW5pdGlhbGl6ZSIsInNpemUiLCJibG9ja2VyS2V5Iiwic2hvdWxkQmxvY2tOYXZpZ2F0aW9uIiwiY3VycmVudExvY2F0aW9uIiwibmV4dEhpc3RvcnlVcGRhdGVQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ1cGRhdGVCbG9ja2VyIiwidGhlbiIsInVwZGF0ZVN0YXRlIiwic3RhcnROYXZpZ2F0aW9uIiwicmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyIsIl9zYXZlQXBwbGllZFRyYW5zaXRpb25zIiwicGVyc2lzdEFwcGxpZWRUcmFuc2l0aW9ucyIsImluaXRpYWxIeWRyYXRpb24iLCJkaXNwb3NlIiwiY2xlYXIiLCJhYm9ydCIsImRlbGV0ZUZldGNoZXIiLCJkZWxldGVCbG9ja2VyIiwic3Vic2NyaWJlIiwiZGVsZXRlIiwibmV3U3RhdGUiLCJvcHRzIiwidW5tb3VudGVkRmV0Y2hlcnMiLCJtb3VudGVkRmV0Y2hlcnMiLCJmZXRjaGVyIiwic3Vic2NyaWJlciIsImRlbGV0ZWRGZXRjaGVycyIsInZpZXdUcmFuc2l0aW9uT3B0cyIsImZsdXNoU3luYyIsImNvbXBsZXRlTmF2aWdhdGlvbiIsImlzQWN0aW9uUmVsb2FkIiwiaXNNdXRhdGlvbk1ldGhvZCIsIl9pc1JlZGlyZWN0Iiwia2V5cyIsIm1lcmdlTG9hZGVyRGF0YSIsImsiLCJwcmlvclBhdGhzIiwidG9QYXRocyIsImdldFNhdmVkU2Nyb2xsUG9zaXRpb24iLCJuYXZpZ2F0ZSIsIm5vcm1hbGl6ZWRQYXRoIiwibm9ybWFsaXplVG8iLCJmcm9tUm91dGVJZCIsInJlbGF0aXZlIiwic3VibWlzc2lvbiIsIm5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyIsInVzZXJSZXBsYWNlIiwicGVuZGluZ0Vycm9yIiwiZW5hYmxlVmlld1RyYW5zaXRpb24iLCJ2aWV3VHJhbnNpdGlvbiIsInJldmFsaWRhdGUiLCJjcmVhdGVEZWZlcnJlZCIsImludGVycnVwdEFjdGl2ZUxvYWRzIiwicHJvbWlzZSIsInN0YXJ0VW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsIm92ZXJyaWRlTmF2aWdhdGlvbiIsInNhdmVTY3JvbGxQb3NpdGlvbiIsInJvdXRlc1RvVXNlIiwibG9hZGluZ05hdmlnYXRpb24iLCJpc0hhc2hDaGFuZ2VPbmx5Iiwibm90Rm91bmRNYXRjaGVzIiwiaGFuZGxlTmF2aWdhdGlvbmFsNDA0IiwiQWJvcnRDb250cm9sbGVyIiwicmVxdWVzdCIsImNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0Iiwic2lnbmFsIiwic2NvcGVkQ29udGV4dCIsInVuc3RhYmxlX2dldENvbnRleHQiLCJwZW5kaW5nQWN0aW9uUmVzdWx0IiwiZmluZE5lYXJlc3RCb3VuZGFyeSIsImFjdGlvblJlc3VsdCIsImhhbmRsZUFjdGlvbiIsInNob3J0Q2lyY3VpdGVkIiwicm91dGVJZCIsImlzRXJyb3JSZXN1bHQiLCJnZXRMb2FkaW5nTmF2aWdhdGlvbiIsInVwZGF0ZWRNYXRjaGVzIiwiaGFuZGxlTG9hZGVycyIsImZldGNoZXJTdWJtaXNzaW9uIiwiZ2V0QWN0aW9uRGF0YUZvckNvbW1pdCIsImlzRm9nT2ZXYXIiLCJnZXRTdWJtaXR0aW5nTmF2aWdhdGlvbiIsImRpc2NvdmVyUmVzdWx0IiwiZGlzY292ZXJSb3V0ZXMiLCJib3VuZGFyeUlkIiwicGFydGlhbE1hdGNoZXMiLCJhY3Rpb25NYXRjaCIsImdldFRhcmdldE1hdGNoIiwibWV0aG9kIiwiZHNNYXRjaGVzIiwiZ2V0VGFyZ2V0ZWREYXRhU3RyYXRlZ3lNYXRjaGVzIiwicmVzdWx0cyIsImNhbGxEYXRhU3RyYXRlZ3kiLCJhYm9ydGVkIiwiaXNSZWRpcmVjdFJlc3VsdCIsImxvY2F0aW9uMiIsIm5vcm1hbGl6ZVJlZGlyZWN0TG9jYXRpb24iLCJzdGFydFJlZGlyZWN0TmF2aWdhdGlvbiIsImJvdW5kYXJ5TWF0Y2giLCJhY3RpdmVTdWJtaXNzaW9uIiwiZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uIiwic2hvdWxkVXBkYXRlTmF2aWdhdGlvblN0YXRlIiwiZ2V0VXBkYXRlZEFjdGlvbkRhdGEiLCJyZXZhbGlkYXRpbmdGZXRjaGVycyIsImdldE1hdGNoZXNUb0xvYWQiLCJzaG91bGRMb2FkIiwidXBkYXRlZEZldGNoZXJzMiIsIm1hcmtGZXRjaFJlZGlyZWN0c0RvbmUiLCJ1cGRhdGVzIiwiZ2V0VXBkYXRlZFJldmFsaWRhdGluZ0ZldGNoZXJzIiwicmYiLCJhYm9ydEZldGNoZXIiLCJjb250cm9sbGVyIiwiYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zIiwiZiIsImxvYWRlclJlc3VsdHMiLCJmZXRjaGVyUmVzdWx0cyIsImNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YSIsInJlZGlyZWN0MiIsImZpbmRSZWRpcmVjdCIsInByb2Nlc3NMb2FkZXJEYXRhIiwidXBkYXRlZEZldGNoZXJzIiwiZGlkQWJvcnRGZXRjaExvYWRzIiwiYWJvcnRTdGFsZUZldGNoTG9hZHMiLCJzaG91bGRVcGRhdGVGZXRjaGVycyIsInJldmFsaWRhdGluZ0ZldGNoZXIiLCJnZXRMb2FkaW5nRmV0Y2hlciIsImZldGNoMiIsInNldEZldGNoZXJFcnJvciIsImhhbmRsZUZldGNoZXJBY3Rpb24iLCJoYW5kbGVGZXRjaGVyTG9hZGVyIiwicmVxdWVzdE1hdGNoZXMiLCJkZXRlY3RBbmRIYW5kbGU0MDVFcnJvciIsImV4aXN0aW5nRmV0Y2hlciIsInVwZGF0ZUZldGNoZXJTdGF0ZSIsImdldFN1Ym1pdHRpbmdGZXRjaGVyIiwiYWJvcnRDb250cm9sbGVyIiwiZmV0Y2hSZXF1ZXN0Iiwib3JpZ2luYXRpbmdMb2FkSWQiLCJmZXRjaE1hdGNoZXMiLCJhY3Rpb25SZXN1bHRzIiwiZ2V0RG9uZUZldGNoZXIiLCJyZXZhbGlkYXRpb25SZXF1ZXN0IiwibG9hZElkIiwibG9hZEZldGNoZXIiLCJzdGFsZUtleSIsImV4aXN0aW5nRmV0Y2hlcjIiLCJyIiwiZG9uZUZldGNoZXIiLCJpc05hdmlnYXRpb24iLCJyZWRpcmVjdExvY2F0aW9uIiwiaXNEb2N1bWVudFJlbG9hZCIsInJlZGlyZWN0TmF2aWdhdGlvblR5cGUiLCJmZXRjaGVyS2V5IiwiZGF0YVJlc3VsdHMiLCJjYWxsRGF0YVN0cmF0ZWd5SW1wbCIsImlzUmVkaXJlY3REYXRhU3RyYXRlZ3lSZXN1bHQiLCJub3JtYWxpemVSZWxhdGl2ZVJvdXRpbmdSZWRpcmVjdFJlc3BvbnNlIiwiY29udmVydERhdGFTdHJhdGVneVJlc3VsdFRvRGF0YVJlc3VsdCIsImZldGNoZXJzVG9Mb2FkIiwibG9hZGVyUmVzdWx0c1Byb21pc2UiLCJmZXRjaGVyUmVzdWx0c1Byb21pc2UiLCJhY2MiLCJnZXRGZXRjaGVyIiwicXVldWVGZXRjaGVyRm9yRGVsZXRpb24iLCJjb3VudCIsIm1hcmtGZXRjaGVyc0RvbmUiLCJkb25lS2V5cyIsImxhbmRlZElkIiwieWVldGVkS2V5cyIsImdldEJsb2NrZXIiLCJibG9ja2VyIiwibmV3QmxvY2tlciIsIkFycmF5IiwiYmxvY2tlckZ1bmN0aW9uIiwiZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJwb3NpdGlvbnMiLCJnZXRQb3NpdGlvbiIsImdldEtleSIsInkiLCJnZXRTY3JvbGxLZXkiLCJmb2dNYXRjaGVzIiwiaXNOb25ITVIiLCJsb2NhbE1hbmlmZXN0IiwicGF0Y2giLCJwYXRjaFJvdXRlc0ltcGwiLCJuZXdNYXRjaGVzIiwibmV3UGFydGlhbE1hdGNoZXMiLCJfaW50ZXJuYWxTZXRSb3V0ZXMiLCJuZXdSb3V0ZXMiLCJwYXRjaFJvdXRlcyIsImZldGNoIiwiX2ludGVybmFsRmV0Y2hDb250cm9sbGVycyIsInF1ZXJ5IiwicmVxdWVzdENvbnRleHQiLCJmaWx0ZXJNYXRjaGVzVG9Mb2FkIiwic2tpcExvYWRlckVycm9yQnViYmxpbmciLCJza2lwUmV2YWxpZGF0aW9uIiwidW5zdGFibGVfcmVzcG9uZCIsInJlc3BvbmQiLCJpc1ZhbGlkTWV0aG9kIiwibWV0aG9kTm90QWxsb3dlZE1hdGNoZXMiLCJzdGF0aWNDb250ZXh0Iiwic3RhdHVzQ29kZSIsImxvYWRlckhlYWRlcnMiLCJhY3Rpb25IZWFkZXJzIiwibG9hZExhenlNaWRkbGV3YXJlRm9yTWF0Y2hlcyIsInJlbmRlcmVkU3RhdGljQ29udGV4dCIsInJ1bk1pZGRsZXdhcmVQaXBlbGluZSIsInJlc3VsdDIiLCJxdWVyeUltcGwiLCJpc1Jlc3BvbnNlIiwicmVzIiwiZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvciIsImJvdW5kYXJ5Um91dGVJZCIsImZpbmQiLCJxdWVyeVJvdXRlIiwiZXJyb3IyIiwidmFsdWVzIiwicm91dGVNYXRjaCIsInN1Ym1pdCIsImxvYWRSb3V0ZURhdGEiLCJpc0RhdGFTdHJhdGVneVJlc3VsdCIsImlzUmVkaXJlY3RSZXNwb25zZSIsImlzUm91dGVSZXF1ZXN0IiwidGhyb3dTdGF0aWNIYW5kbGVyQWJvcnRlZEVycm9yIiwiTG9jYXRpb24iLCJsb2FkZXJSZXF1ZXN0IiwiUmVxdWVzdCIsImhhbmRsZXJDb250ZXh0MiIsImhhbmRsZXJDb250ZXh0IiwibWF4SWR4IiwiZ2V0RGF0YVN0cmF0ZWd5TWF0Y2giLCJwcm9jZXNzUm91dGVMb2FkZXJEYXRhIiwiZGVmYXVsdERhdGFTdHJhdGVneSIsImVycm9yQm91bmRhcnlJZCIsIl9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIiwicmVhc29uIiwiaXNTdWJtaXNzaW9uTmF2aWdhdGlvbiIsImJvZHkiLCJjb250ZXh0dWFsTWF0Y2hlcyIsImFjdGl2ZVJvdXRlTWF0Y2giLCJuYWtlZEluZGV4IiwiaGFzTmFrZWRJbmRleFF1ZXJ5IiwiVVJMU2VhcmNoUGFyYW1zIiwiaW5kZXhWYWx1ZXMiLCJnZXRBbGwiLCJhcHBlbmQiLCJxcyIsImlzRmV0Y2hlciIsImdldEludmFsaWRCb2R5RXJyb3IiLCJyYXdGb3JtTWV0aG9kIiwidG9VcHBlckNhc2UiLCJzdHJpcEhhc2hGcm9tUGF0aCIsIkZvcm1EYXRhIiwicGFyc2UiLCJzZWFyY2hQYXJhbXMiLCJjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyIsImNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhIiwibGF6eVJvdXRlUHJvcGVydGllc1RvU2tpcCIsImhhc1BhdGNoUm91dGVzT25OYXZpZ2F0aW9uIiwiY3VycmVudFVybCIsIm5leHRVcmwiLCJhY3Rpb25TdGF0dXMiLCJzaG91bGRTa2lwUmV2YWxpZGF0aW9uIiwiYmFzZVNob3VsZFJldmFsaWRhdGVBcmdzIiwiY3VycmVudFBhcmFtcyIsIm5leHRQYXJhbXMiLCJmb3JjZVNob3VsZExvYWQiLCJpc05ld0xvYWRlciIsImRlZmF1bHRTaG91bGRSZXZhbGlkYXRlIiwiaXNOZXdSb3V0ZUluc3RhbmNlIiwic2hvdWxkUmV2YWxpZGF0ZUFyZ3MiLCJzaG91bGRSZXZhbGlkYXRlTG9hZGVyIiwiaXNNaWRJbml0aWFsTG9hZCIsImZldGNoZXJNYXRjaGVzIiwiZmV0Y2hlck1hdGNoIiwiZmV0Y2hDb250cm9sbGVyIiwiZmV0Y2hlckRzTWF0Y2hlcyIsImhhc0RhdGEiLCJoYXNFcnJvciIsImh5ZHJhdGUiLCJjdXJyZW50TG9hZGVyRGF0YSIsImN1cnJlbnRNYXRjaCIsImlzTmV3IiwiaXNNaXNzaW5nRGF0YSIsImN1cnJlbnRQYXRoIiwibG9hZGVyTWF0Y2giLCJhcmciLCJzaG91bGRSZXZhbGlkYXRlIiwicm91dGVDaG9pY2UiLCJjaGlsZHJlblRvUGF0Y2giLCJ1bmlxdWVDaGlsZHJlbiIsIm5ld1JvdXRlIiwiZXhpc3RpbmdSb3V0ZSIsImlzU2FtZVJvdXRlIiwiYUNoaWxkIiwiYkNoaWxkIiwibGF6eVJvdXRlUHJvcGVydHlDYWNoZSIsImxvYWRMYXp5Um91dGVQcm9wZXJ0eSIsInJvdXRlVG9VcGRhdGUiLCJsYXp5Rm4iLCJjYWNoZSIsImNhY2hlZFByb21pc2UiLCJwcm9wZXJ0eVByb21pc2UiLCJpc1Vuc3VwcG9ydGVkIiwic3RhdGljUm91dGVWYWx1ZSIsImlzU3RhdGljYWxseURlZmluZWQiLCJsYXp5Um91dGVGdW5jdGlvbkNhY2hlIiwibG9hZExhenlSb3V0ZSIsImxhenlSb3V0ZVByb21pc2UiLCJsYXp5SGFuZGxlclByb21pc2UiLCJsYXp5Um91dGVQcm9taXNlMiIsImxhenlSb3V0ZSIsInJvdXRlVXBkYXRlcyIsImxhenlSb3V0ZVByb3BlcnR5IiwibGF6eVZhbHVlIiwiY2F0Y2giLCJsYXp5S2V5cyIsImxhenlQcm9wZXJ0eVByb21pc2VzIiwiaXNOb25OdWxsYWJsZSIsInByb21pc2VzIiwiYXJncyIsIm1hdGNoZXNUb0xvYWQiLCJrZXllZFJlc3VsdHMiLCJwcm9wYWdhdGVSZXN1bHQiLCJoYW5kbGVyIiwiZXJyb3JIYW5kbGVyIiwibWlkZGxld2FyZVN0YXRlIiwiaGFuZGxlclJlc3VsdCIsInR1cGxlcyIsImZsYXRNYXAiLCJjYWxsUm91dGVNaWRkbGV3YXJlIiwibWlkZGxld2FyZUVycm9yIiwibWlkZGxld2FyZXMiLCJ0dXBsZSIsIm1pZGRsZXdhcmUiLCJuZXh0Q2FsbGVkIiwibmV4dFJlc3VsdCIsIm5leHQiLCJnZXREYXRhU3RyYXRlZ3lNYXRjaExhenlQcm9taXNlcyIsImxhenlNaWRkbGV3YXJlUHJvbWlzZSIsImxhenlSb3V0ZVByb21pc2VzIiwidW5zdGFibGVfc2hvdWxkUmV2YWxpZGF0ZUFyZ3MiLCJpc1VzaW5nTmV3QXBpIiwiX2xhenlQcm9taXNlcyIsInVuc3RhYmxlX3Nob3VsZENhbGxIYW5kbGVyIiwiaGFuZGxlck92ZXJyaWRlIiwiY2FsbExvYWRlck9yQWN0aW9uIiwidGFyZ2V0TWF0Y2giLCJpc1N0YXRpY0hhbmRsZXIiLCJkYXRhU3RyYXRlZ3lBcmdzIiwidW5zdGFibGVfcnVuQ2xpZW50TWlkZGxld2FyZSIsImNiIiwidHlwZWREYXRhU3RyYXRlZ3lBcmdzIiwib25SZWplY3QiLCJpc0FjdGlvbiIsInJ1bkhhbmRsZXIiLCJyZWplY3QiLCJhYm9ydFByb21pc2UiLCJhY3R1YWxIYW5kbGVyIiwiY3R4IiwiaGFuZGxlclByb21pc2UiLCJ2YWwiLCJyYWNlIiwiaGFuZGxlckVycm9yIiwiaGFuZGxlcjIiLCJkYXRhU3RyYXRlZ3lSZXN1bHQiLCJjb250ZW50VHlwZSIsImlzRGF0YVdpdGhSZXNwb25zZUluaXQiLCJ0cmltbWVkTWF0Y2hlcyIsIm5vcm1hbGl6ZWRMb2NhdGlvbiIsInByb3RvY29sIiwiaXNTYW1lQmFzZW5hbWUiLCJmb3VuZEVycm9yIiwibmV3TG9hZGVyRGF0YSIsIm1lcmdlZExvYWRlckRhdGEiLCJtZXJnZWQiLCJlbGlnaWJsZU1hdGNoZXMiLCJyZXZlcnNlIiwiZXJyb3JNZXNzYWdlIiwiaXNSZWRpcmVjdFN0YXR1c0NvZGUiLCJfd2luZG93IiwidHJhbnNpdGlvbnMiLCJzZXNzaW9uUG9zaXRpb25zIiwic2Vzc2lvblN0b3JhZ2UiLCJnZXRJdGVtIiwiaXNBcnJheSIsInNldEl0ZW0iLCJyZWoiLCJSZWFjdDMiLCJyZXF1aXJlIiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwiZGlzcGxheU5hbWUiLCJpc1RyYW5zaXRpb25pbmciLCJBd2FpdENvbnRleHQiLCJvdXRsZXQiLCJpc0RhdGFSb3V0ZSIsIlJvdXRlRXJyb3JDb250ZXh0IiwiRU5BQkxFX0RFVl9XQVJOSU5HUyIsIlJlYWN0MiIsIm5hdmlnYXRvciIsInVzZUNvbnRleHQiLCJqb2luZWRQYXRobmFtZSIsIm5hdmlnYXRpb25UeXBlIiwidXNlTWVtbyIsIm5hdmlnYXRlRWZmZWN0V2FybmluZyIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJpc1N0YXRpYyIsInN0YXRpYyIsInVzZUxheW91dEVmZmVjdCIsInVzZU5hdmlnYXRlU3RhYmxlIiwidXNlTmF2aWdhdGVVbnN0YWJsZSIsImRhdGFSb3V0ZXJDb250ZXh0Iiwicm91dGVQYXRobmFtZXNKc29uIiwiYWN0aXZlUmVmIiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJPdXRsZXRDb250ZXh0IiwiUHJvdmlkZXIiLCJ1c2VSb3V0ZXNJbXBsIiwiZGF0YVJvdXRlclN0YXRlIiwicGFyZW50TWF0Y2hlcyIsInBhcmVudFBhcmFtcyIsInBhcmVudFBhdGhuYW1lIiwicGFyZW50UGF0aG5hbWVCYXNlIiwicGFyZW50Um91dGUiLCJ3YXJuaW5nT25jZSIsImxvY2F0aW9uRnJvbUNvbnRleHQiLCJwYXJzZWRMb2NhdGlvbkFyZyIsInBhcmVudFNlZ21lbnRzIiwiZWxlbWVudCIsIkNvbXBvbmVudCIsInJlbmRlcmVkTWF0Y2hlcyIsIl9yZW5kZXJNYXRjaGVzIiwiRGVmYXVsdEVycm9yQ29tcG9uZW50Iiwic3RhY2siLCJsaWdodGdyZXkiLCJwcmVTdHlsZXMiLCJwYWRkaW5nIiwiYmFja2dyb3VuZENvbG9yIiwiY29kZVN0eWxlcyIsImRldkluZm8iLCJGcmFnbWVudCIsInN0eWxlIiwiZm9udFN0eWxlIiwiZGVmYXVsdEVycm9yRWxlbWVudCIsIlJlbmRlckVycm9yQm91bmRhcnkiLCJwcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImNvbXBvbmVudERpZENhdGNoIiwiZXJyb3JJbmZvIiwicmVuZGVyIiwicm91dGVDb250ZXh0IiwiY29tcG9uZW50IiwiUmVuZGVyZWRSb3V0ZSIsImVycm9yRWxlbWVudCIsIkVycm9yQm91bmRhcnkiLCJlcnJvckluZGV4IiwicmVuZGVyRmFsbGJhY2siLCJmYWxsYmFja0luZGV4IiwiSHlkcmF0ZUZhbGxiYWNrIiwiaHlkcmF0ZUZhbGxiYWNrRWxlbWVudCIsImVycm9yczIiLCJuZWVkc1RvUnVuTG9hZGVyIiwicmVkdWNlUmlnaHQiLCJzaG91bGRSZW5kZXJIeWRyYXRlRmFsbGJhY2siLCJtYXRjaGVzMiIsImdldENoaWxkcmVuIiwiZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvciIsImhvb2tOYW1lIiwidXNlRGF0YVJvdXRlckNvbnRleHQiLCJ1c2VEYXRhUm91dGVyU3RhdGUiLCJ1c2VSb3V0ZUNvbnRleHQiLCJ1c2VDdXJyZW50Um91dGVJZCIsInRoaXNSb3V0ZSIsInVzZVJvdXRlSWQiLCJfZGF0YSIsIl9lcnJvciIsImJsb2NrZXJJZCIsInNob3VsZEJsb2NrIiwic2V0QmxvY2tlcktleSIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiYWxyZWFkeVdhcm5lZCIsImFscmVhZHlXYXJuZWQyIiwid2Fybk9uY2UiLCJjb25kaXRpb24iLCJEZWZlcnJlZCIsInJlYWN0RG9tRmx1c2hTeW5jSW1wbCIsInNldFN0YXRlSW1wbCIsInBlbmRpbmdTdGF0ZSIsInNldFBlbmRpbmdTdGF0ZSIsInZ0Q29udGV4dCIsInNldFZ0Q29udGV4dCIsInJlbmRlckRmZCIsInNldFJlbmRlckRmZCIsInRyYW5zaXRpb24iLCJzZXRUcmFuc2l0aW9uIiwiaW50ZXJydXB0aW9uIiwic2V0SW50ZXJydXB0aW9uIiwiZmV0Y2hlckRhdGEiLCJzZXRTdGF0ZSIsImlzVmlld1RyYW5zaXRpb25BdmFpbGFibGUiLCJzdGFydFZpZXdUcmFuc2l0aW9uIiwic3RhcnRUcmFuc2l0aW9uIiwic2tpcFRyYW5zaXRpb24iLCJ0IiwiZmluaXNoZWQiLCJmaW5hbGx5IiwicmVuZGVyUHJvbWlzZSIsInRyYW5zaXRpb24yIiwic3RhdGUyIiwiTWVtb2l6ZWREYXRhUm91dGVzIiwibWVtbyIsIkRhdGFSb3V0ZXMiLCJoaXN0b3J5UmVmIiwianNvblBhdGgiLCJfcHJvcHMiLCJiYXNlbmFtZVByb3AiLCJsb2NhdGlvblByb3AiLCJzdGF0aWNQcm9wIiwibmF2aWdhdGlvbkNvbnRleHQiLCJsb2NhdGlvbkNvbnRleHQiLCJ0cmFpbGluZ1BhdGhuYW1lIiwiQXdhaXRFcnJvckJvdW5kYXJ5IiwiUmVzb2x2ZUF3YWl0IiwicmVuZGVyRXJyb3IiLCJfdHJhY2tlZCIsInRvUmVuZGVyIiwiQ2hpbGRyZW4iLCJpc1ZhbGlkRWxlbWVudCIsImFwcGx5IiwiUmVhY3QxMCIsImRlZmF1bHRNZXRob2QiLCJkZWZhdWx0RW5jVHlwZSIsImlzSHRtbEVsZW1lbnQiLCJvYmplY3QiLCJ0YWdOYW1lIiwiaXNCdXR0b25FbGVtZW50IiwiaXNGb3JtRWxlbWVudCIsImlzSW5wdXRFbGVtZW50IiwiaXNNb2RpZmllZEV2ZW50IiwiZXZlbnQiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5Iiwic2hvdWxkUHJvY2Vzc0xpbmtDbGljayIsImJ1dHRvbiIsImdldFNlYXJjaFBhcmFtc0ZvckxvY2F0aW9uIiwibG9jYXRpb25TZWFyY2giLCJkZWZhdWx0U2VhcmNoUGFyYW1zIiwiX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIiLCJpc0Zvcm1EYXRhU3VibWl0dGVyU3VwcG9ydGVkIiwic3VwcG9ydGVkRm9ybUVuY1R5cGVzIiwiZ2V0Rm9ybUVuY1R5cGUiLCJlbmNUeXBlIiwiZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvIiwiYXR0ciIsImZvcm0iLCJSZWFjdDkiLCJpbnZhcmlhbnQyIiwibG9hZFJvdXRlTW9kdWxlIiwicm91dGVNb2R1bGVzQ2FjaGUiLCJyb3V0ZU1vZHVsZSIsIl9fcmVhY3RSb3V0ZXJDb250ZXh0IiwiaXNTcGFNb2RlIiwicmVsb2FkIiwiZ2V0S2V5ZWRMaW5rc0Zvck1hdGNoZXMiLCJyb3V0ZU1vZHVsZXMiLCJkZXNjcmlwdG9ycyIsIm1vZHVsZTIiLCJjc3MiLCJyZWwiLCJsaW5rcyIsImZsYXQiLCJwcmVsb2FkcyIsImdldE1vZHVsZUxpbmtIcmVmcyIsImRlZHVwZUxpbmtEZXNjcmlwdG9ycyIsImdldFJvdXRlQ3NzRGVzY3JpcHRvcnMiLCJwcmVmZXRjaFJvdXRlQ3NzIiwicHJlZmV0Y2hTdHlsZUxpbmsiLCJwcmVmZXRjaFN0eWxlTGlua3MiLCJpc1ByZWxvYWRTdXBwb3J0ZWQiLCJzdHlsZUxpbmtzIiwiZGVzY3JpcHRvciIsImlzUGFnZUxpbmtEZXNjcmlwdG9yIiwiYXMiLCJtZWRpYSIsIm1hdGNoTWVkaWEiLCJsaW5rIiwicmVtb3ZlTGluayIsImhlYWQiLCJjb250YWlucyIsInJlbW92ZUNoaWxkIiwib25sb2FkIiwib25lcnJvciIsImFwcGVuZENoaWxkIiwicGFnZSIsImlzSHRtbExpbmtEZXNjcmlwdG9yIiwiaW1hZ2VTcmNTZXQiLCJpbWFnZVNpemVzIiwiZ2V0S2V5ZWRQcmVmZXRjaExpbmtzIiwiZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzIiwibmV4dE1hdGNoZXMiLCJjdXJyZW50TWF0Y2hlcyIsIm1vZGUiLCJtYXRjaFBhdGhDaGFuZ2VkIiwibWFuaWZlc3RSb3V0ZSIsImhhc0xvYWRlciIsImluY2x1ZGVIeWRyYXRlRmFsbGJhY2siLCJkZWR1cGVIcmVmcyIsImhyZWZzIiwiY2xpZW50QWN0aW9uTW9kdWxlIiwiY2xpZW50TG9hZGVyTW9kdWxlIiwiaHlkcmF0ZUZhbGxiYWNrTW9kdWxlIiwiaW1wb3J0cyIsInNvcnRLZXlzIiwic29ydGVkIiwicHJlbG9hZHNTZXQiLCJkZWR1cGVkIiwiYWxyZWFkeU1vZHVsZVByZWxvYWQiLCJfaXNQcmVsb2FkU3VwcG9ydGVkIiwiZWwiLCJyZWxMaXN0Iiwic3VwcG9ydHMiLCJFU0NBUEVfTE9PS1VQIiwiRVNDQVBFX1JFR0VYIiwiZXNjYXBlSHRtbCIsImh0bWwiLCJjcmVhdGVIdG1sIiwiX19odG1sIiwiUmVhY3Q0IiwiSE9MRSIsIk5BTiIsIk5FR0FUSVZFX0lORklOSVRZIiwiTkVHQVRJVkVfWkVSTyIsIk5VTEwiLCJQT1NJVElWRV9JTkZJTklUWSIsIlVOREVGSU5FRCIsIlRZUEVfQklHSU5UIiwiVFlQRV9EQVRFIiwiVFlQRV9FUlJPUiIsIlRZUEVfTUFQIiwiVFlQRV9OVUxMX09CSkVDVCIsIlRZUEVfUFJPTUlTRSIsIlRZUEVfUkVHRVhQIiwiVFlQRV9TRVQiLCJUWVBFX1NZTUJPTCIsIlRZUEVfVVJMIiwiVFlQRV9QUkVWSU9VU19SRVNPTFZFRCIsIkRlZmVycmVkMiIsImNyZWF0ZUxpbmVTcGxpdHRpbmdUcmFuc2Zvcm0iLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJsZWZ0b3ZlciIsIlRyYW5zZm9ybVN0cmVhbSIsInRyYW5zZm9ybSIsImNodW5rIiwic3RyIiwiZGVjb2RlIiwic3RyZWFtIiwicGFydHMiLCJwYXJ0IiwiZW5xdWV1ZSIsImZsdXNoIiwiZmxhdHRlbiIsImlucHV0IiwiaW5kaWNlcyIsImV4aXN0aW5nIiwiTnVtYmVyIiwiaXNOYU4iLCJkZWZlcnJlZCIsInBsdWdpbnMiLCJwb3N0UGx1Z2lucyIsInN0cmluZ2lmaWVkIiwiaW5wdXQyIiwicGFydHNGb3JPYmoiLCJrZXlGb3IiLCJwbHVnaW5IYW5kbGVkIiwicGx1Z2luIiwicGx1Z2luUmVzdWx0IiwicGx1Z2luSWRlbnRpZmllciIsIkRhdGUiLCJnZXRUaW1lIiwic291cmNlIiwiZmxhZ3MiLCJpc1BsYWluT2JqZWN0Iiwib2JqZWN0UHJvdG9OYW1lcyIsInRoaW5nIiwicHJvdG8iLCJnbG9iYWxPYmoiLCJnbG9iYWxUaGlzIiwidW5mbGF0dGVuIiwicGFyc2VkIiwiaHlkcmF0ZWQiLCJTeW50YXhFcnJvciIsInBvc3RSdW4iLCJOYU4iLCJJbmZpbml0eSIsImMiLCJCaWdJbnQiLCJmb3IiLCJuZXdTZXQiLCJkIiwiZXJyb3JUeXBlIiwidmFscyIsInYyIiwicmVhZGFibGUiLCJkb25lIiwicmVhZGVyIiwicGlwZVRocm91Z2giLCJnZXRSZWFkZXIiLCJkZWNvZGVJbml0aWFsIiwiZG9uZVByb21pc2UiLCJkZWNvZGVEZWZlcnJlZCIsImNsb3NlZCIsInJlYWQiLCJsaW5lIiwiY29sb25JbmRleCIsImRlZmVycmVkSWQiLCJsaW5lRGF0YSIsImpzb25MaW5lIiwiZW5jb2RlIiwiZW5jb2RlcjIiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwibGFzdFNlbnRJbmRleCIsIlJlYWRhYmxlU3RyZWFtIiwic3RhcnQiLCJzZWVuUHJvbWlzZXMiLCJyYWNlRG9uZSIsInJhY2VQcm9taXNlIiwicmVqZWN0UHJvbWlzZSIsInJlc29sdmVkIiwiaWQyIiwiY2xvc2UiLCJjcmVhdGVSZXF1ZXN0SW5pdCIsIlNpbmdsZUZldGNoTm9SZXN1bHRFcnJvciIsIlNJTkdMRV9GRVRDSF9SRURJUkVDVF9TVEFUVVMiLCJOT19CT0RZX1NUQVRVU19DT0RFUyIsIlN0cmVhbVRyYW5zZmVyIiwiaWRlbnRpZmllciIsInRleHREZWNvZGVyIiwibm9uY2UiLCJyZW5kZXJNZXRhIiwiZGlkUmVuZGVyU2NyaXB0cyIsInN0cmVhbUNhY2hlIiwic2NyaXB0VGFnIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJTdXNwZW5zZSIsImdldFJvdXRlciIsInNzciIsImdldFNpbmdsZUZldGNoRGF0YVN0cmF0ZWd5SW1wbCIsImhhc0NsaWVudExvYWRlciIsImhhc1Nob3VsZFJldmFsaWRhdGUiLCJmZXRjaEFuZERlY29kZVZpYVR1cmJvU3RyZWFtIiwiZ2V0Um91dGVJbmZvIiwiZmV0Y2hBbmREZWNvZGUiLCJzaW5nbGVGZXRjaEFjdGlvblN0cmF0ZWd5IiwiZm91bmRSZXZhbGlkYXRpbmdTZXJ2ZXJMb2FkZXIiLCJub25Tc3JTdHJhdGVneSIsInNpbmdsZUZldGNoTG9hZGVyRmV0Y2hlclN0cmF0ZWd5Iiwic2luZ2xlRmV0Y2hMb2FkZXJOYXZpZ2F0aW9uU3RyYXRlZ3kiLCJ1bndyYXBTaW5nbGVGZXRjaFJlc3VsdCIsInJvdXRlc1BhcmFtcyIsImZvdW5kT3B0T3V0Um91dGUiLCJyb3V0ZURmZHMiLCJjcmVhdGVEZWZlcnJlZDIiLCJzaW5nbGVGZXRjaERmZCIsInJlc29sdmVQcm9taXNlIiwic2hvdWxkQ2FsbCIsImlzSW5pdGlhbExvYWQiLCJfX3JlYWN0Um91dGVySGRyQWN0aXZlIiwidGFyZ2V0Um91dGVzIiwiYnViYmxlTWlkZGxld2FyZUVycm9ycyIsInNpbmdsZUZldGNoUHJvbWlzZSIsImZldGNoZWREYXRhIiwicm91dGVSZXN1bHQiLCJzdHJpcEluZGV4UGFyYW0iLCJpbmRleFZhbHVlc1RvS2VlcCIsImluZGV4VmFsdWUiLCJ0b0tlZXAiLCJzaW5nbGVGZXRjaFVybCIsInJlcVVybCIsInR5cGVkIiwiZ2xvYmFsMiIsIkNvbnN0cnVjdG9yIiwiUmVhY3Q4IiwiUmVhY3Q3IiwiUmVhY3Q1IiwiUmVtaXhSb290RGVmYXVsdEVycm9yQm91bmRhcnkiLCJpc091dHNpZGVSZW1peEFwcCIsImhleURldmVsb3BlciIsIkJvdW5kYXJ5U2hlbGwiLCJ0aXRsZSIsImZvbnRTaXplIiwiZXJyb3JJbnN0YW5jZSIsImVycm9yU3RyaW5nIiwiYmFja2dyb3VuZCIsImNvbG9yIiwib3ZlcmZsb3ciLCJyZW5kZXJTY3JpcHRzIiwidXNlRnJhbWV3b3JrQ29udGV4dCIsInJvb3QiLCJMYXlvdXQiLCJsYW5nIiwiY2hhclNldCIsImNvbnRlbnQiLCJmb250RmFtaWx5IiwiUmVhY3Q2IiwiUmVtaXhSb290RGVmYXVsdEh5ZHJhdGVGYWxsYmFjayIsImdyb3VwUm91dGVzQnlQYXJlbnRJZCIsInBhcmVudElkIiwiZ2V0Um91dGVDb21wb25lbnRzIiwiQ29tcG9uZW50NCIsImdldFJvdXRlTW9kdWxlQ29tcG9uZW50IiwiY3JlYXRlU2VydmVyUm91dGVzIiwicm91dGVzQnlQYXJlbnRJZCIsInNwYU1vZGVMYXp5UHJvbWlzZSIsImRhdGFSb3V0ZSIsIm5lZWRzUmV2YWxpZGF0aW9uIiwiaW5pdGlhbFN0YXRlIiwicHJldmVudEludmFsaWRTZXJ2ZXJIYW5kbGVyQ2FsbCIsImhhc0FjdGlvbiIsIm5vQWN0aW9uRGVmaW5lZEVycm9yIiwiYXJ0aWNsZSIsImZldGNoU2VydmVySGFuZGxlciIsInNpbmdsZUZldGNoIiwiZmV0Y2hTZXJ2ZXJMb2FkZXIiLCJmZXRjaFNlcnZlckFjdGlvbiIsInByZWZldGNoTW9kdWxlIiwibW9kdWxlUGF0aCIsInByZWZldGNoUm91dGVNb2R1bGVDaHVua3MiLCJyb3V0ZTIiLCJwcmVmZXRjaFN0eWxlc0FuZENhbGxIYW5kbGVyIiwiY2FjaGVkTW9kdWxlIiwibGlua1ByZWZldGNoUHJvbWlzZSIsInVuc3RhYmxlX2NsaWVudE1pZGRsZXdhcmUiLCJnZXRTaG91bGRSZXZhbGlkYXRlRnVuY3Rpb24iLCJoYXNJbml0aWFsRGF0YSIsImluaXRpYWxEYXRhIiwiaGFzSW5pdGlhbEVycm9yIiwiaW5pdGlhbEVycm9yIiwiaXNIeWRyYXRpb25SZXF1ZXN0IiwiY2xpZW50TG9hZGVyIiwic2VydmVyTG9hZGVyIiwiY2xpZW50QWN0aW9uIiwic2VydmVyQWN0aW9uIiwiaGFzQ2xpZW50QWN0aW9uIiwiZ2V0TGF6eVJvdXRlIiwic2V0VGltZW91dCIsInJvdXRlTW9kdWxlUHJvbWlzZSIsImxvYWRSb3V0ZU1vZHVsZVdpdGhCbG9ja2luZ0xpbmtzIiwiY2xpZW50QWN0aW9uUHJvbWlzZSIsImhhc0NsaWVudE1pZGRsZXdhcmUiLCJjbGllbnRNaWRkbGV3YXJlTW9kdWxlIiwid3JhcFNob3VsZFJldmFsaWRhdGVGb3JIZHIiLCJteVBhcmFtcyIsImRpZFBhcmFtc0NoYW5nZSIsInJvdXRlU2hvdWxkUmV2YWxpZGF0ZSIsImhhbmRsZWRSZXZhbGlkYXRpb24iLCJwcmVmZXRjaFJvdXRlQ3NzUHJvbWlzZSIsImRlZmF1bHQiLCJpc0VtcHR5T2JqZWN0IiwibmV4dFBhdGhzIiwiZGlzY292ZXJlZFBhdGhzTWF4U2l6ZSIsImRpc2NvdmVyZWRQYXRocyIsIlVSTF9MSU1JVCIsImlzRm9nT2ZXYXJFbmFibGVkIiwicm91dGVEaXNjb3ZlcnkiLCJnZXRQYXJ0aWFsTWFuaWZlc3QiLCJzcmkiLCJyb3V0ZUlkcyIsImluaXRpYWxSb3V0ZXMiLCJmZXRjaEFuZEFwcGx5TWFuaWZlc3RQYXRjaGVzIiwibWFuaWZlc3RQYXRoIiwiY29ubmVjdGlvbiIsInNhdmVEYXRhIiwicmVnaXN0ZXJFbGVtZW50IiwiZmV0Y2hQYXRjaGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImxhenlQYXRocyIsImRlYm91bmNlZEZldGNoUGF0Y2hlcyIsImRlYm91bmNlIiwib2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsImRvY3VtZW50RWxlbWVudCIsInN1YnRyZWUiLCJjaGlsZExpc3QiLCJhdHRyaWJ1dGVzIiwiYXR0cmlidXRlRmlsdGVyIiwiZGlzY29ubmVjdCIsImdldE1hbmlmZXN0UGF0aCIsIl9tYW5pZmVzdFBhdGgiLCJNQU5JRkVTVF9WRVJTSU9OX1NUT1JBR0VfS0VZIiwiZXJyb3JSZWxvYWRQYXRoIiwidmVyc2lvbiIsInNlcnZlclBhdGNoZXMiLCJvayIsInJlbW92ZUl0ZW0iLCJrbm93blJvdXRlcyIsInBhdGNoZXMiLCJhZGRUb0ZpZm9RdWV1ZSIsInBhcmVudElkcyIsInF1ZXVlIiwiY2FsbGJhY2siLCJ3YWl0IiwidGltZW91dElkIiwiY2xlYXJUaW1lb3V0IiwidXNlRGF0YVJvdXRlckNvbnRleHQyIiwidXNlRGF0YVJvdXRlclN0YXRlQ29udGV4dCIsInVzZVByZWZldGNoQmVoYXZpb3IiLCJwcmVmZXRjaCIsInRoZWlyRWxlbWVudFByb3BzIiwiZnJhbWV3b3JrQ29udGV4dCIsIm1heWJlUHJlZmV0Y2giLCJzZXRNYXliZVByZWZldGNoIiwic2hvdWxkUHJlZmV0Y2giLCJzZXRTaG91bGRQcmVmZXRjaCIsIm9uRm9jdXMiLCJvbkJsdXIiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJvblRvdWNoU3RhcnQiLCJyZWYiLCJpc0ludGVyc2VjdGluZyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwidGhyZXNob2xkIiwic2V0SW50ZW50IiwiY2FuY2VsSW50ZW50IiwiY29tcG9zZUV2ZW50SGFuZGxlcnMiLCJ0aGVpckhhbmRsZXIiLCJvdXJIYW5kbGVyIiwiZGVmYXVsdFByZXZlbnRlZCIsImdldEFjdGl2ZU1hdGNoZXMiLCJpc0h5ZHJhdGVkIiwiZXJyb3JJZHgiLCJjcml0aWNhbENzcyIsInJvdXRlck1hdGNoZXMiLCJrZXllZExpbmtzIiwiZGF0YUxpbmtQcm9wcyIsIlByZWZldGNoUGFnZUxpbmtzSW1wbCIsInVzZUtleWVkUHJlZmV0Y2hMaW5rcyIsImtleWVkUHJlZmV0Y2hMaW5rcyIsInNldEtleWVkUHJlZmV0Y2hMaW5rcyIsImludGVycnVwdGVkIiwibGlua1Byb3BzIiwibmV3TWF0Y2hlc0ZvckRhdGEiLCJuZXdNYXRjaGVzRm9yQXNzZXRzIiwiZGF0YUhyZWZzIiwibTIiLCJtb2R1bGVIcmVmcyIsIl9tYXRjaGVzIiwibGVhZk1ldGEiLCJfbWF0Y2giLCJyb3V0ZU1ldGEiLCJtZXRhUHJvcHMiLCJpc1ZhbGlkTWV0YVRhZyIsIkNvbXAiLCJjaGFyc2V0IiwiZXJyIiwic2VydmVySGFuZG9mZlN0cmluZyIsImVuYWJsZUZvZ09mV2FyIiwiaW5pdGlhbFNjcmlwdHMiLCJzdHJlYW1TY3JpcHQiLCJjb250ZXh0U2NyaXB0Iiwicm91dGVNb2R1bGVzU2NyaXB0IiwiaG1yIiwicnVudGltZSIsInJvdXRlSW5kZXgiLCJyb3V0ZVZhck5hbWUiLCJtYW5pZmVzdEVudHJ5IiwiY2h1bmtzIiwidmFyTmFtZSIsImNodW5rSW1wb3J0c1NuaXBwZXQiLCJtZXJnZWRDaHVua3NTbmlwcGV0Iiwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIiwiYXN5bmMiLCJkZWR1cGUiLCJpbnRlZ3JpdHkiLCJjcm9zc09yaWdpbiIsIm1lcmdlUmVmcyIsInJlZnMiLCJpc0Jyb3dzZXIiLCJfX3JlYWN0Um91dGVyVmVyc2lvbiIsInBhcnNlSHlkcmF0aW9uRGF0YSIsIl9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YSIsImRlc2VyaWFsaXplRXJyb3JzIiwic2VyaWFsaXplZCIsIl9fdHlwZSIsIl9fc3ViVHlwZSIsIkVycm9yQ29uc3RydWN0b3IiLCJBQlNPTFVURV9VUkxfUkVHRVgyIiwiZm9yd2FyZFJlZiIsIkxpbmtXaXRoUmVmIiwib25DbGljayIsImRpc2NvdmVyIiwicmVsb2FkRG9jdW1lbnQiLCJmb3J3YXJkZWRSZWYiLCJhYnNvbHV0ZUhyZWYiLCJpc0V4dGVybmFsIiwidGFyZ2V0VXJsIiwicHJlZmV0Y2hSZWYiLCJwcmVmZXRjaEhhbmRsZXJzIiwiaW50ZXJuYWxPbkNsaWNrIiwiaGFuZGxlQ2xpY2siLCJOYXZMaW5rV2l0aFJlZiIsImFyaWFDdXJyZW50UHJvcCIsImNsYXNzTmFtZSIsImNsYXNzTmFtZVByb3AiLCJzdHlsZVByb3AiLCJyb3V0ZXJTdGF0ZSIsIm5leHRMb2NhdGlvblBhdGhuYW1lIiwiZW5kU2xhc2hQb3NpdGlvbiIsImlzQWN0aXZlIiwiaXNQZW5kaW5nIiwicmVuZGVyUHJvcHMiLCJhcmlhQ3VycmVudCIsIm9uU3VibWl0Iiwic3VibWl0SGFuZGxlciIsInByZXZlbnREZWZhdWx0Iiwic3VibWl0dGVyIiwibmF0aXZlRXZlbnQiLCJzdWJtaXRNZXRob2QiLCJjdXJyZW50VGFyZ2V0Iiwic3RvcmFnZUtleSIsInJlbWl4Q29udGV4dCIsInNzcktleSIsInVzZXJLZXkiLCJnZXRTY3JvbGxSZXN0b3JhdGlvbktleSIsInJlc3RvcmVTY3JvbGwiLCJzdG9yYWdlS2V5MiIsInJlc3RvcmVLZXkiLCJzdG9yZWRZIiwic2Nyb2xsVG8iLCJTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkiLCJnZXREYXRhUm91dGVyQ29uc29sZUVycm9yMiIsInVzZURhdGFSb3V0ZXJDb250ZXh0MyIsInVzZURhdGFSb3V0ZXJTdGF0ZTIiLCJyZXBsYWNlUHJvcCIsImRlZmF1bHRJbml0IiwiZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiIsImhhc1NldFNlYXJjaFBhcmFtc1JlZiIsInNldFNlYXJjaFBhcmFtcyIsIm5leHRJbml0IiwibmF2aWdhdGVPcHRpb25zIiwibmV3U2VhcmNoUGFyYW1zIiwiZmV0Y2hlcklkIiwiZ2V0VW5pcXVlRmV0Y2hlcklkIiwiY3VycmVudFJvdXRlSWQiLCJoYXNOYWtlZEluZGV4UGFyYW0iLCJkZWZhdWx0S2V5IiwidXNlSWQiLCJzZXRGZXRjaGVyS2V5IiwibG9hZCIsInN1Ym1pdEltcGwiLCJGZXRjaGVyRm9ybSIsIkZldGNoZXJGb3JtMiIsImZldGNoZXJXaXRoQ29tcG9uZW50cyIsInNhdmVkU2Nyb2xsUG9zaXRpb25zIiwic2Nyb2xsUmVzdG9yYXRpb24iLCJ1c2VQYWdlSGlkZSIsInNjcm9sbFkiLCJkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwiY2FwdHVyZSIsIndoZW4iLCJjb25maXJtIiwibmV4dFBhdGgiLCJSZWFjdDExIiwic3RhdGljTmF2aWdhdG9yIiwiZ2V0U3RhdGVsZXNzTmF2aWdhdG9yIiwiaHlkcmF0ZTIiLCJmZXRjaGVyc0NvbnRleHQiLCJoeWRyYXRlU2NyaXB0Iiwic2VyaWFsaXplRXJyb3JzIiwiaHRtbEVzY2FwZSIsIkRhdGFSb3V0ZXMyIiwiYmFjayIsImZvcndhcmQiLCJlbmNvZGVkIiwiQUJTT0xVVEVfVVJMX1JFR0VYMyIsIkVTQ0FQRV9MT09LVVAyIiwiRVNDQVBFX1JFR0VYMiIsIlJlYWN0MTIiLCJzdGF0aWNIYW5kbGVyQ29udGV4dCIsInNlcmlhbGl6ZUVycm9yIiwic2VydmVySGFuZG9mZlN0cmVhbSIsIlJlYWN0MTMiLCJSb3V0ZXNUZXN0U3R1YiIsInJvdXRlclJlZiIsInJlbWl4Q29udGV4dFJlZiIsInVuc3RhYmxlX3N1YlJlc291cmNlSW50ZWdyaXR5IiwicGF0Y2hlZCIsInByb2Nlc3NSb3V0ZXMiLCJ3aXRoQ29tcG9uZW50UHJvcHMiLCJXcmFwcGVkIiwid2l0aEh5ZHJhdGVGYWxsYmFja1Byb3BzIiwid2l0aEVycm9yQm91bmRhcnlQcm9wcyIsImVudHJ5Um91dGUiLCJpbXBvcnRfY29va2llIiwiZW5jb2RlciIsInNpZ24iLCJzZWNyZXQiLCJjcmVhdGVLZXkyIiwic2lnbmF0dXJlIiwiY3J5cHRvIiwic3VidGxlIiwiYnRvYSIsImZyb21DaGFyQ29kZSIsIlVpbnQ4QXJyYXkiLCJ1bnNpZ24iLCJjb29raWUiLCJsYXN0SW5kZXhPZiIsImJ5dGVTdHJpbmdUb1VpbnQ4QXJyYXkiLCJhdG9iIiwidmFsaWQiLCJ2ZXJpZnkiLCJ1c2FnZXMiLCJpbXBvcnRLZXkiLCJieXRlU3RyaW5nIiwiY2hhckNvZGVBdCIsImNvb2tpZU9wdGlvbnMiLCJzZWNyZXRzIiwic2FtZVNpdGUiLCJ3YXJuT25jZUFib3V0RXhwaXJlc0Nvb2tpZSIsImV4cGlyZXMiLCJpc1NpZ25lZCIsIm1heEFnZSIsIm5vdyIsImNvb2tpZUhlYWRlciIsInBhcnNlT3B0aW9ucyIsImNvb2tpZXMiLCJkZWNvZGVDb29raWVWYWx1ZSIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZU9wdGlvbnMiLCJlbmNvZGVDb29raWVWYWx1ZSIsImVuY29kZURhdGEiLCJ1bnNpZ25lZFZhbHVlIiwiZGVjb2RlRGF0YSIsIm15VW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJteUVzY2FwZSIsImNociIsImNvZGUiLCJleGVjIiwiaGV4IiwicGFyc2VJbnQiLCJjcmVhdGVFbnRyeVJvdXRlTW9kdWxlcyIsIlNlcnZlck1vZGUyIiwiaXNTZXJ2ZXJNb2RlIiwic2FuaXRpemVFcnJvciIsInNlcnZlck1vZGUiLCJzYW5pdGl6ZWQiLCJzYW5pdGl6ZUVycm9ycyIsInNlcmlhbGl6ZUVycm9yczIiLCJtYXRjaFNlcnZlclJvdXRlcyIsImNhbGxSb3V0ZUhhbmRsZXIiLCJzdHJpcFJvdXRlc1BhcmFtIiwic3RyaXBJbmRleFBhcmFtMiIsImR1cGxleCIsImludmFyaWFudDMiLCJnbG9iYWxEZXZTZXJ2ZXJIb29rc0tleSIsImRldlNlcnZlckhvb2tzIiwiZ2V0RGV2U2VydmVySG9va3MiLCJnZXRCdWlsZFRpbWVIZWFkZXIiLCJoZWFkZXJOYW1lIiwicHJvY2VzcyIsImVudiIsIklTX1JSX0JVSUxEX1JFUVVFU1QiLCJncm91cFJvdXRlc0J5UGFyZW50SWQyIiwiY3JlYXRlUm91dGVzIiwiY3JlYXRlU3RhdGljSGFuZGxlckRhdGFSb3V0ZXMiLCJjb21tb25Sb3V0ZSIsInByZVJlbmRlcmVkRGF0YSIsImRlY29kZVVSSSIsInVpbnQ4YXJyYXkiLCJnbG9iYWwiLCJFU0NBUEVfTE9PS1VQMyIsIkVTQ0FQRV9SRUdFWDMiLCJlc2NhcGVIdG1sMiIsImNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmciLCJzZXJ2ZXJIYW5kb2ZmIiwiaW1wb3J0X3NldF9jb29raWVfcGFyc2VyIiwiZ2V0RG9jdW1lbnRIZWFkZXJzIiwiYnVpbGQiLCJib3VuZGFyeUlkeCIsImVycm9ySGVhZGVycyIsInBhcmVudEhlYWRlcnMiLCJpbmNsdWRlRXJyb3JIZWFkZXJzIiwiaW5jbHVkZUVycm9yQ29va2llcyIsImhlYWRlcnMyIiwicHJlcGVuZENvb2tpZXMiLCJjaGlsZEhlYWRlcnMiLCJwYXJlbnRTZXRDb29raWVTdHJpbmciLCJzcGxpdENvb2tpZXNTdHJpbmciLCJjaGlsZENvb2tpZXMiLCJnZXRTZXRDb29raWUiLCJTRVJWRVJfTk9fQk9EWV9TVEFUVVNfQ09ERVMiLCJzaW5nbGVGZXRjaEFjdGlvbiIsInN0YXRpY0hhbmRsZXIiLCJoYW5kbGVyVXJsIiwibG9hZENvbnRleHQiLCJoYW5kbGVFcnJvciIsInJlc3BvbmQyIiwiZ2VuZXJhdGVTaW5nbGVGZXRjaFJlc3BvbnNlIiwiZ2V0U2luZ2xlRmV0Y2hSZWRpcmVjdCIsInNpbmdsZUZldGNoUmVzdWx0IiwiaGFuZGxlclJlcXVlc3QiLCJzaW5nbGVGZXRjaExvYWRlcnMiLCJsb2FkZWRNYXRjaGVzIiwibG9hZFJvdXRlSWRzIiwicm91dGVzUGFyYW0iLCJyZXN1bHRIZWFkZXJzIiwiZW5jb2RlVmlhVHVyYm9TdHJlYW0iLCJzdHJlYW1UaW1lb3V0IiwicmVxdWVzdFNpZ25hbCIsImRhdGEzIiwiZnJvbUVudHJpZXMiLCJkZXJpdmUiLCJfYnVpbGQiLCJyZXF1ZXN0SGFuZGxlciIsImluaXRpYWxDb250ZXh0IiwiZGVyaXZlZCIsInByb2Nlc3NSZXF1ZXN0RXJyb3IiLCJyZXR1cm5MYXN0UmVzb3J0RXJyb3JSZXNwb25zZSIsIm5vcm1hbGl6ZWRCYXNlbmFtZSIsInByZXJlbmRlciIsIm1hbmlmZXN0VXJsIiwiaGFuZGxlTWFuaWZlc3RSZXF1ZXN0Iiwic2luZ2xlRmV0Y2hNYXRjaGVzIiwiaGFuZGxlU2luZ2xlRmV0Y2hSZXF1ZXN0IiwiaGFuZGxlRGF0YVJlcXVlc3QiLCJoYW5kbGVSZXNvdXJjZVJlcXVlc3QiLCJ1bnN0YWJsZV9nZXRDcml0aWNhbENzcyIsImdldENyaXRpY2FsQ3NzIiwiaGFuZGxlRG9jdW1lbnRSZXF1ZXN0IiwiYXNzZXRzIiwicGFydGlhbFBhdGgiLCJyZW5kZXJIdG1sIiwiaXNTcGFNb2RlMiIsImJhc2VTZXJ2ZXJIYW5kb2ZmIiwiZW50cnlDb250ZXh0IiwiaGFuZGxlRG9jdW1lbnRSZXF1ZXN0RnVuY3Rpb24iLCJlcnJvckZvclNlY29uZFJlbmRlciIsInVud3JhcFJlc3BvbnNlIiwiZXJyb3JSZXNwb25zZVRvSnNvbiIsIm5ld0Vycm9yIiwiZXJyb3JSZXNwb25zZSIsImZsYXNoIiwiZmxhc2hOYW1lIiwidW5zZXQiLCJjb29raWVBcmciLCJjcmVhdGVEYXRhIiwicmVhZERhdGEiLCJ1cGRhdGVEYXRhIiwiZGVsZXRlRGF0YSIsIndhcm5PbmNlQWJvdXRTaWduaW5nU2Vzc2lvbkNvb2tpZSIsImdldFNlc3Npb24iLCJjb21taXRTZXNzaW9uIiwic2Vzc2lvbiIsImRlc3Ryb3lTZXNzaW9uIiwic2VyaWFsaXplZENvb2tpZSIsIl9zZXNzaW9uIiwiaXNSZXF1aXJlZCIsInJvdXRlSW5mbyIsImhhc0h5ZHJhdGVGYWxsYmFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/development/index.js\n");

/***/ })

};
;